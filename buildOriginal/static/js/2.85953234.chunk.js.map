{"version":3,"sources":["../static/js/2.85953234.chunk.js","ui/pages/categories/categories-section.jsx","webpack:///./~/moment/moment.js?cbd3*","webpack:///./src/ui/components/Select/index.js?529d*","webpack:///./src/ui/components/Select/Select.jsx?7850*","webpack:///./src/utils/helpers/financial-hepers.js?f730"],"names":["webpackJsonp","505","module","__webpack_exports__","__webpack_require__","_toConsumableArray","arr","Array","isArray","i","arr2","length","from","_taggedTemplateLiteral","strings","raw","Object","freeze","defineProperties","value","_classCallCheck","instance","Constructor","TypeError","_possibleConstructorReturn","self","call","ReferenceError","_inherits","subClass","superClass","prototype","create","constructor","enumerable","writable","configurable","setPrototypeOf","__proto__","getProfile","localStorage","getItem","JSON","parse","profile","prepareFiancialAccounts","financialAccounts","reduce","fas","fa","concat","assign","currentBalance","openingBalance","getCurrentBalance","financialAccount","type","negativeTransactions","total","t","amount","positiveTransactions","defineProperty","__WEBPACK_IMPORTED_MODULE_0_react__","__WEBPACK_IMPORTED_MODULE_0_react___default","n","__WEBPACK_IMPORTED_MODULE_1_prop_types__","__WEBPACK_IMPORTED_MODULE_1_prop_types___default","__WEBPACK_IMPORTED_MODULE_2_react_apollo__","__WEBPACK_IMPORTED_MODULE_3_graphql_tag__","__WEBPACK_IMPORTED_MODULE_3_graphql_tag___default","__WEBPACK_IMPORTED_MODULE_4_moment__","__WEBPACK_IMPORTED_MODULE_4_moment___default","__WEBPACK_IMPORTED_MODULE_5__utils_helpers_financial_hepers_js__","__WEBPACK_IMPORTED_MODULE_6__components_Tile__","__WEBPACK_IMPORTED_MODULE_7__components_Select__","__WEBPACK_IMPORTED_MODULE_8__components_loader_loader_jsx__","_createClass","target","props","descriptor","key","protoProps","staticProps","_templateObject","CategoriesSection","_Component","this","_this","getPrototypeOf","renderOptions","bind","renderCategory","setCategoryId","state","categoryId","categories","id","nextProps","setState","_ref","_ref2","max","Math","floor","parseFloat","map","category","a","createElement","name","_this2","filter","percent","getPercentage","color","difference","currencyFormatted","className","_this3","isLoading","ref","categorySelector","onChange","propTypes","array","isRequired","bool","qCategoriesForBudget","CategoriesForBudget","options","variables","startDate","startOf","subtract","toISOString","endDate","endOf","auth0UserId","user_id","_ref3","ownProps","_ref3$data","data","loading","allCategories","refetch","534","exports","global","factory","hooks","hookCallback","apply","arguments","setHookCallback","callback","input","toString","isObject","isObjectEmpty","obj","k","isUndefined","isNumber","isDate","Date","fn","res","push","hasOwnProp","b","hasOwnProperty","extend","valueOf","createUTC","format","locale","strict","createLocalOrUTC","utc","defaultParsingFlags","empty","unusedTokens","unusedInput","overflow","charsLeftOver","nullInput","invalidMonth","invalidFormat","userInvalidated","iso","parsedDateParts","meridiem","rfc2822","weekdayMismatch","getParsingFlags","m","_pf","isValid","_isValid","flags","parsedParts","some$1","isNowValid","isNaN","_d","getTime","invalidWeekday","_strict","undefined","bigHour","isFrozen","createInvalid","NaN","copyConfig","to","prop","val","_isAMomentObject","_i","_f","_l","_tzm","_isUTC","_offset","_locale","momentProperties","Moment","config","updateInProgress","updateOffset","isMoment","absFloor","number","ceil","toInt","argumentForCoercion","coercedNumber","isFinite","compareArrays","array1","array2","dontConvert","len","min","lengthDiff","abs","diffs","warn","msg","suppressDeprecationWarnings","console","deprecate","firstTime","deprecationHandler","arg","args","slice","join","Error","stack","deprecateSimple","deprecations","isFunction","Function","set","_config","_dayOfMonthOrdinalParseLenient","RegExp","_dayOfMonthOrdinalParse","source","_ordinalParse","mergeConfigs","parentConfig","childConfig","Locale","calendar","mom","now","output","_calendar","longDateFormat","_longDateFormat","formatUpper","toUpperCase","replace","invalidDate","_invalidDate","ordinal","_ordinal","relativeTime","withoutSuffix","string","isFuture","_relativeTime","pastFuture","diff","addUnitAlias","unit","shorthand","lowerCase","toLowerCase","aliases","normalizeUnits","units","normalizeObjectUnits","inputObject","normalizedProp","normalizedInput","addUnitPriority","priority","priorities","getPrioritizedUnits","unitsObj","u","sort","makeGetSet","keepTime","set$1","get","stringGet","stringSet","prioritized","zeroFill","targetLength","forceSign","absNumber","zerosToFill","pow","substr","addFormatToken","token","padded","func","formatTokenFunctions","localeData","removeFormattingTokens","match","makeFormatFunction","formattingTokens","formatMoment","expandFormat","formatFunctions","replaceLongDateFormatTokens","localFormattingTokens","lastIndex","test","addRegexToken","regex","strictRegex","regexes","isStrict","getParseRegexForToken","unescapeFormat","s","regexEscape","matched","p1","p2","p3","p4","addParseToken","tokens","addWeekParseToken","_w","addTimeToArrayFromToken","_a","daysInMonth","year","month","UTC","getUTCDate","localeMonths","_months","isFormat","MONTHS_IN_FORMAT","localeMonthsShort","_monthsShort","handleStrictParse","monthName","ii","llc","toLocaleLowerCase","_monthsParse","_longMonthsParse","_shortMonthsParse","monthsShort","months","indexOf$1","localeMonthsParse","_monthsParseExact","setMonth","dayOfMonth","monthsParse","date","getSetMonth","getDaysInMonth","monthsShortRegex","computeMonthsParse","_monthsShortStrictRegex","_monthsShortRegex","defaultMonthsShortRegex","monthsRegex","_monthsStrictRegex","_monthsRegex","defaultMonthsRegex","cmpLenRev","shortPieces","longPieces","mixedPieces","daysInYear","isLeapYear","getIsLeapYear","createDate","y","d","h","M","ms","getFullYear","setFullYear","createUTCDate","getUTCFullYear","setUTCFullYear","firstWeekOffset","dow","doy","fwd","getUTCDay","dayOfYearFromWeeks","week","weekday","resYear","resDayOfYear","localWeekday","weekOffset","dayOfYear","weekOfYear","resWeek","weeksInYear","weekOffsetNext","localeWeek","_week","localeFirstDayOfWeek","localeFirstDayOfYear","getSetWeek","add","getSetISOWeek","parseWeekday","weekdaysParse","parseInt","parseIsoWeekday","localeWeekdays","_weekdays","day","localeWeekdaysShort","_weekdaysShort","localeWeekdaysMin","_weekdaysMin","handleStrictParse$1","weekdayName","_weekdaysParse","_shortWeekdaysParse","_minWeekdaysParse","weekdaysMin","weekdaysShort","weekdays","localeWeekdaysParse","_weekdaysParseExact","_fullWeekdaysParse","getSetDayOfWeek","getDay","getSetLocaleDayOfWeek","getSetISODayOfWeek","weekdaysRegex","computeWeekdaysParse","_weekdaysStrictRegex","_weekdaysRegex","defaultWeekdaysRegex","weekdaysShortRegex","_weekdaysShortStrictRegex","_weekdaysShortRegex","defaultWeekdaysShortRegex","weekdaysMinRegex","_weekdaysMinStrictRegex","_weekdaysMinRegex","defaultWeekdaysMinRegex","minp","shortp","longp","minPieces","hFormat","hours","kFormat","lowercase","minutes","matchMeridiem","_meridiemParse","localeIsPM","charAt","localeMeridiem","isLower","normalizeLocale","chooseLocale","names","j","next","split","loadLocale","oldLocale","locales","globalLocale","_abbr","e","code","getSetGlobalLocale","values","getLocale","defineLocale","baseConfig","abbr","parentLocale","localeFamilies","forEach","x","updateLocale","listLocales","keys$1","checkOverflow","MONTH","DATE","YEAR","HOUR","MINUTE","SECOND","MILLISECOND","_overflowDayOfYear","_overflowWeeks","WEEK","_overflowWeekday","WEEKDAY","configFromISO","l","allowTime","dateFormat","timeFormat","tzFormat","extendedIsoRegex","exec","basicIsoRegex","isoDates","isoTimes","tzRegex","configFromStringAndFormat","configFromRFC2822","dayFormat","timezone","timezoneIndex","timezones"," GMT"," EDT"," EST"," CDT"," CST"," MDT"," MST"," PDT"," PST","military","basicRfcRegex","momentDate","momentDay","indexOf","splice","configFromString","aspNetJsonRegex","createFromInputFallback","defaults","c","currentDateArray","nowValue","_useUTC","getUTCMonth","getMonth","getDate","configFromArray","currentDate","yearToUse","dayOfYearFromWeekInfo","_dayOfYear","_nextDay","setUTCMinutes","getUTCMinutes","w","weekYear","temp","weekdayOverflow","GG","W","E","createLocal","curWeek","gg","ISO_8601","RFC_2822","parsedInput","skipped","stringLength","totalParsedInputLength","_meridiem","meridiemFixWrap","hour","isPm","meridiemHour","isPM","configFromStringAndArray","tempConfig","bestMoment","scoreToBeat","currentScore","score","configFromObject","minute","second","millisecond","createFromConfig","prepareConfig","preparse","configFromInput","isUTC","pickBy","moments","isDurationValid","ordering","unitHasDecimal","isValid$1","createInvalid$1","createDuration","Duration","duration","years","quarters","quarter","weeks","days","seconds","milliseconds","_milliseconds","_days","_data","_bubble","isDuration","absRound","round","offset","separator","utcOffset","sign","offsetFromString","matcher","matches","chunk","parts","chunkOffset","cloneWithOffset","model","clone","setTime","local","getDateOffset","getTimezoneOffset","getSetOffset","keepLocalTime","keepMinutes","localAdjust","matchShortOffset","_changeInProgress","addSubtract","getSetZone","setOffsetToUTC","setOffsetToLocal","setOffsetToParsedOffset","tZone","matchOffset","hasAlignedHourOffset","isDaylightSavingTime","isDaylightSavingTimeShifted","_isDSTShifted","other","toArray","isLocal","isUtcOffset","isUtc","ret","diffRes","aspNetRegex","isoRegex","parseIso","momentsDifference","inp","positiveMomentsDifference","base","isAfter","isBefore","createAdder","direction","period","dur","tmp","isAdding","getCalendarFormat","myMoment","calendar$1","time","formats","sod","calendarFormat","localInput","isBetween","inclusivity","isSame","inputMs","isSameOrAfter","isSameOrBefore","asFloat","that","zoneDelta","delta","monthDiff","anchor2","adjust","wholeMonthDiff","anchor","toDate","inspect","zone","prefix","suffix","inputString","defaultFormatUtc","defaultFormat","postformat","humanize","fromNow","toNow","newLocaleData","isoWeekday","unix","toObject","toJSON","isValid$2","parsingFlags","invalidAt","creationData","addWeekYearFormatToken","getter","getSetWeekYear","getSetWeekYearHelper","getSetISOWeekYear","isoWeek","getISOWeeksInYear","getWeeksInYear","weekInfo","weeksTarget","setWeekAll","dayOfYearData","getSetQuarter","getSetDayOfYear","parseMs","getZoneAbbr","getZoneName","createUnix","createInZone","parseZone","preParsePostFormat","get$1","index","field","setter","listMonthsImpl","out","listWeekdaysImpl","localeSorted","shift","listMonths","listMonthsShort","listWeekdays","listWeekdaysShort","listWeekdaysMin","mathAbs","addSubtract$1","add$1","subtract$1","absCeil","bubble","monthsFromDays","monthsToDays","daysToMonths","as","valueOf$1","makeAs","alias","get$2","makeGetter","substituteTimeAgo","relativeTime$1","posNegDuration","thresholds","ss","getSetRelativeTimeRounding","roundingFunction","getSetRelativeTimeThreshold","threshold","limit","withSuffix","toISOString$1","abs$1","Y","D","asSeconds","some","fun","keys","defaultCalendar","sameDay","nextDay","nextWeek","lastDay","lastWeek","sameElse","defaultLongDateFormat","LTS","LT","L","LL","LLL","LLLL","defaultInvalidDate","defaultOrdinal","defaultDayOfMonthOrdinalParse","defaultRelativeTime","future","past","mm","hh","dd","MM","yy","match1","match2","match3","match4","match6","match1to2","match3to4","match5to6","match1to3","match1to4","match1to6","matchUnsigned","matchSigned","matchTimestamp","matchWord","o","defaultLocaleMonths","defaultLocaleMonthsShort","parseTwoDigitYear","getSetYear","defaultLocaleWeek","defaultLocaleWeekdays","defaultLocaleWeekdaysShort","defaultLocaleWeekdaysMin","kInput","_isPm","pos","pos1","pos2","defaultLocaleMeridiemParse","getSetHour","dayOfMonthOrdinalParse","meridiemParse","prototypeMin","prototypeMax","invalid","lang","isoWeekYear","getSetDayOfMonth","getSetMinute","getSetSecond","getSetMillisecond","proto","isoWeeks","isoWeeksInYear","isDST","zoneAbbr","zoneName","dates","isDSTShifted","proto$1","firstDayOfYear","firstDayOfWeek","langData","asMilliseconds","asMinutes","asHours","asDays","asWeeks","asMonths","asYears","proto$2","toIsoString","version","relativeTimeRounding","relativeTimeThreshold","538","__WEBPACK_IMPORTED_MODULE_0__Select__","547","__WEBPACK_IMPORTED_MODULE_0_glamorous__","Select","select","backgroundColor","appearance","display","flex","alignSelf","margin","textAlign","border","boxShadow","borderRadius","padding","fontSize","lineHeight","backgroundImage","backgroundPosition","backgroundSize","backgroundRepeat","563","FinancialHelpers","minus","String"],"mappings":"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","file":"static/js/2.85953234.chunk.js","sourcesContent":["webpackJsonp([2],{\n\n/***/ 505:\n/***/ (function(module, __webpack_exports__, __webpack_require__) {\n\n\"use strict\";\nObject.defineProperty(__webpack_exports__, \"__esModule\", { value: true });\n/* harmony import */ var __WEBPACK_IMPORTED_MODULE_0_react__ = __webpack_require__(0);\n/* harmony import */ var __WEBPACK_IMPORTED_MODULE_0_react___default = __webpack_require__.n(__WEBPACK_IMPORTED_MODULE_0_react__);\n/* harmony import */ var __WEBPACK_IMPORTED_MODULE_1_prop_types__ = __webpack_require__(1);\n/* harmony import */ var __WEBPACK_IMPORTED_MODULE_1_prop_types___default = __webpack_require__.n(__WEBPACK_IMPORTED_MODULE_1_prop_types__);\n/* harmony import */ var __WEBPACK_IMPORTED_MODULE_2_react_apollo__ = __webpack_require__(51);\n/* harmony import */ var __WEBPACK_IMPORTED_MODULE_2_react_apollo___default = __webpack_require__.n(__WEBPACK_IMPORTED_MODULE_2_react_apollo__);\n/* harmony import */ var __WEBPACK_IMPORTED_MODULE_3_graphql_tag__ = __webpack_require__(62);\n/* harmony import */ var __WEBPACK_IMPORTED_MODULE_3_graphql_tag___default = __webpack_require__.n(__WEBPACK_IMPORTED_MODULE_3_graphql_tag__);\n/* harmony import */ var __WEBPACK_IMPORTED_MODULE_4_moment__ = __webpack_require__(534);\n/* harmony import */ var __WEBPACK_IMPORTED_MODULE_4_moment___default = __webpack_require__.n(__WEBPACK_IMPORTED_MODULE_4_moment__);\n/* harmony import */ var __WEBPACK_IMPORTED_MODULE_5__utils_helpers_financial_hepers_js__ = __webpack_require__(563);\n/* harmony import */ var __WEBPACK_IMPORTED_MODULE_6__components_Tile__ = __webpack_require__(82);\n/* harmony import */ var __WEBPACK_IMPORTED_MODULE_7__components_Select__ = __webpack_require__(538);\n/* harmony import */ var __WEBPACK_IMPORTED_MODULE_8__components_loader_loader_jsx__ = __webpack_require__(132);\nvar _createClass = function () { function defineProperties(target, props) { for (var i = 0; i < props.length; i++) { var descriptor = props[i]; descriptor.enumerable = descriptor.enumerable || false; descriptor.configurable = true; if (\"value\" in descriptor) descriptor.writable = true; Object.defineProperty(target, descriptor.key, descriptor); } } return function (Constructor, protoProps, staticProps) { if (protoProps) defineProperties(Constructor.prototype, protoProps); if (staticProps) defineProperties(Constructor, staticProps); return Constructor; }; }();\n\nvar _templateObject = _taggedTemplateLiteral(['\\nquery qDashboard(\\n  $auth0UserId: String!,\\n  $startDate: DateTime!,\\n  $endDate: DateTime!,\\n){\\n  allCategories(\\n    filter: {\\n      user: {\\n        auth0UserId: $auth0UserId\\n      }\\n    }\\n  ){\\n    id\\n    name\\n    max\\n    positiveTransactions(\\n      filter:{\\n        transactionDate_gte: $startDate,\\n        transactionDate_lte: $endDate\\n      }\\n    ){\\n      id\\n      amount\\n      transactionDate\\n    }\\n    negativeTransactions(\\n      filter:{\\n        transactionDate_gte: $startDate,\\n        transactionDate_lte: $endDate\\n      }\\n    ){\\n      id\\n      amount\\n      transactionDate\\n    }\\n  }\\n}\\n'], ['\\nquery qDashboard(\\n  $auth0UserId: String!,\\n  $startDate: DateTime!,\\n  $endDate: DateTime!,\\n){\\n  allCategories(\\n    filter: {\\n      user: {\\n        auth0UserId: $auth0UserId\\n      }\\n    }\\n  ){\\n    id\\n    name\\n    max\\n    positiveTransactions(\\n      filter:{\\n        transactionDate_gte: $startDate,\\n        transactionDate_lte: $endDate\\n      }\\n    ){\\n      id\\n      amount\\n      transactionDate\\n    }\\n    negativeTransactions(\\n      filter:{\\n        transactionDate_gte: $startDate,\\n        transactionDate_lte: $endDate\\n      }\\n    ){\\n      id\\n      amount\\n      transactionDate\\n    }\\n  }\\n}\\n']);\n\nfunction _toConsumableArray(arr) { if (Array.isArray(arr)) { for (var i = 0, arr2 = Array(arr.length); i < arr.length; i++) { arr2[i] = arr[i]; } return arr2; } else { return Array.from(arr); } }\n\nfunction _taggedTemplateLiteral(strings, raw) { return Object.freeze(Object.defineProperties(strings, { raw: { value: Object.freeze(raw) } })); }\n\nfunction _classCallCheck(instance, Constructor) { if (!(instance instanceof Constructor)) { throw new TypeError(\"Cannot call a class as a function\"); } }\n\nfunction _possibleConstructorReturn(self, call) { if (!self) { throw new ReferenceError(\"this hasn't been initialised - super() hasn't been called\"); } return call && (typeof call === \"object\" || typeof call === \"function\") ? call : self; }\n\nfunction _inherits(subClass, superClass) { if (typeof superClass !== \"function\" && superClass !== null) { throw new TypeError(\"Super expression must either be null or a function, not \" + typeof superClass); } subClass.prototype = Object.create(superClass && superClass.prototype, { constructor: { value: subClass, enumerable: false, writable: true, configurable: true } }); if (superClass) Object.setPrototypeOf ? Object.setPrototypeOf(subClass, superClass) : subClass.__proto__ = superClass; }\n\n\n\n\n\n\n\n\n\n\n\n\nvar CategoriesSection = function (_Component) {\n  _inherits(CategoriesSection, _Component);\n\n  function CategoriesSection(props) {\n    _classCallCheck(this, CategoriesSection);\n\n    var _this = _possibleConstructorReturn(this, (CategoriesSection.__proto__ || Object.getPrototypeOf(CategoriesSection)).call(this, props));\n\n    _this.renderOptions = _this.renderOptions.bind(_this);\n    _this.renderCategory = _this.renderCategory.bind(_this);\n    _this.setCategoryId = _this.setCategoryId.bind(_this);\n\n    _this.state = {\n      categoryId: props.categories && props.categories[0] && props.categories[0].id\n    };\n    return _this;\n  }\n\n  _createClass(CategoriesSection, [{\n    key: 'componentWillReceiveProps',\n    value: function componentWillReceiveProps(nextProps) {\n      this.setState(function () {\n        return {\n          categoryId: nextProps.categories && nextProps.categories[0] && nextProps.categories[0].id\n        };\n      });\n    }\n  }, {\n    key: 'setCategoryId',\n    value: function setCategoryId(_ref) {\n      var target = _ref.target;\n\n      this.setState(function () {\n        return { categoryId: target.value };\n      });\n    }\n  }, {\n    key: 'getPercentage',\n    value: function getPercentage(_ref2) {\n      var currentBalance = _ref2.currentBalance,\n          max = _ref2.max;\n\n      var value = currentBalance !== 0 ? Math.floor(parseFloat(currentBalance) / parseFloat(max) * 100, 0) : 0.001;\n      value = currentBalance > 0 && value < 1 ? 1 : value;\n      return value;\n    }\n  }, {\n    key: 'renderOptions',\n    value: function renderOptions() {\n      return this.props.categories.map(function (category) {\n        return __WEBPACK_IMPORTED_MODULE_0_react___default.a.createElement(\n          'option',\n          { value: category.id },\n          category.name\n        );\n      });\n    }\n  }, {\n    key: 'renderCategory',\n    value: function renderCategory() {\n      var _this2 = this;\n\n      return this.props.categories.filter(function (category) {\n        return category.id === _this2.state.categoryId;\n      }).map(function (category) {\n        var percent = _this2.getPercentage({\n          currentBalance: category.currentBalance,\n          max: category.max\n        });\n        var color = 'success';\n        if (percent >= 75 && percent < 90) {\n          color = 'warning';\n        } else if (percent >= 75 && percent >= 90) {\n          color = 'danger';\n        }\n        var difference = __WEBPACK_IMPORTED_MODULE_5__utils_helpers_financial_hepers_js__[\"a\" /* default */].currencyFormatted(category.max - category.currentBalance);\n        return __WEBPACK_IMPORTED_MODULE_0_react___default.a.createElement(\n          __WEBPACK_IMPORTED_MODULE_6__components_Tile__[\"a\" /* default */],\n          null,\n          __WEBPACK_IMPORTED_MODULE_0_react___default.a.createElement(\n            'h4',\n            null,\n            category.name\n          ),\n          __WEBPACK_IMPORTED_MODULE_0_react___default.a.createElement(\n            'h4',\n            null,\n            difference\n          ),\n          __WEBPACK_IMPORTED_MODULE_0_react___default.a.createElement('progress', {\n            className: 'progress progress-' + color,\n            value: percent > 100 ? 100 : percent,\n            max: '100'\n          })\n        );\n      });\n    }\n  }, {\n    key: 'render',\n    value: function render() {\n      var _this3 = this;\n\n      return this.props.isLoading ? __WEBPACK_IMPORTED_MODULE_0_react___default.a.createElement(__WEBPACK_IMPORTED_MODULE_8__components_loader_loader_jsx__[\"a\" /* default */], null) : __WEBPACK_IMPORTED_MODULE_0_react___default.a.createElement(\n        'div',\n        null,\n        __WEBPACK_IMPORTED_MODULE_0_react___default.a.createElement(\n          __WEBPACK_IMPORTED_MODULE_6__components_Tile__[\"a\" /* default */],\n          null,\n          __WEBPACK_IMPORTED_MODULE_0_react___default.a.createElement(\n            __WEBPACK_IMPORTED_MODULE_7__components_Select__[\"a\" /* default */],\n            {\n              ref: function ref(categorySelector) {\n                _this3.categorySelector = categorySelector;\n              },\n              onChange: this.setCategoryId\n            },\n            this.renderOptions()\n          )\n        ),\n        this.renderCategory()\n      );\n    }\n  }]);\n\n  return CategoriesSection;\n}(__WEBPACK_IMPORTED_MODULE_0_react__[\"Component\"]);\n\nCategoriesSection.propTypes = {\n  categories: __WEBPACK_IMPORTED_MODULE_1_prop_types___default.a.array.isRequired,\n  isLoading: __WEBPACK_IMPORTED_MODULE_1_prop_types___default.a.bool.isRequired\n};\n\nvar qCategoriesForBudget = __WEBPACK_IMPORTED_MODULE_3_graphql_tag___default()(_templateObject);\n\nfunction getProfile() {\n  // Retrieves the profile data from local storage\n  var profile = localStorage.getItem('profile');\n  return profile ? JSON.parse(localStorage.profile) : {};\n}\n\nvar CategoriesForBudget = __webpack_require__.i(__WEBPACK_IMPORTED_MODULE_2_react_apollo__[\"graphql\"])(qCategoriesForBudget, {\n  options: function options() {\n    var startDate = __WEBPACK_IMPORTED_MODULE_4_moment___default()().startOf('month').subtract(0, 'month').toISOString();\n    var endDate = __WEBPACK_IMPORTED_MODULE_4_moment___default()().endOf('month').subtract(0, 'month').toISOString();\n    var auth0UserId = getProfile().user_id;\n    return {\n      variables: {\n        startDate: startDate,\n        endDate: endDate,\n        auth0UserId: auth0UserId\n      }\n    };\n  },\n\n\n  // ownProps are the props that are passed into the `ProfileWithData`\n  // when it is used by a parent component\n  props: function props(_ref3) {\n    var ownProps = _ref3.ownProps,\n        _ref3$data = _ref3.data,\n        loading = _ref3$data.loading,\n        allCategories = _ref3$data.allCategories,\n        refetch = _ref3$data.refetch;\n    return {\n      ownProps: ownProps,\n      isLoading: loading,\n      categories: prepareFiancialAccounts(allCategories) || [],\n      refetch: refetch\n    };\n  }\n})(CategoriesSection);\n\n/* harmony default export */ __webpack_exports__[\"default\"] = (CategoriesForBudget);\n\nfunction prepareFiancialAccounts(financialAccounts) {\n  return !financialAccounts || financialAccounts.length < 1 ? null : financialAccounts.reduce(function (fas, fa) {\n    return [].concat(_toConsumableArray(fas), [Object.assign({}, fa, {\n      currentBalance: fa.openingBalance ? fa.openingBalance + getCurrentBalance(fa) : getCurrentBalance(fa)\n    })]);\n  }, []);\n}\n\nfunction getCurrentBalance(financialAccount) {\n  if (financialAccount.type === 'debt') {\n    return financialAccount.negativeTransactions.reduce(function (total, t) {\n      return total + t.amount;\n    }, 0) - financialAccount.positiveTransactions.reduce(function (total, t) {\n      return total + t.amount;\n    }, 0);\n  }\n  return financialAccount.positiveTransactions.reduce(function (total, t) {\n    return total + t.amount;\n  }, 0) - financialAccount.negativeTransactions.reduce(function (total, t) {\n    return total + t.amount;\n  }, 0);\n}\n\n/***/ }),\n\n/***/ 534:\n/***/ (function(module, exports, __webpack_require__) {\n\n/* WEBPACK VAR INJECTION */(function(module) {//! moment.js\n//! version : 2.18.1\n//! authors : Tim Wood, Iskren Chernev, Moment.js contributors\n//! license : MIT\n//! momentjs.com\n\n;(function (global, factory) {\n     true ? module.exports = factory() :\n    typeof define === 'function' && define.amd ? define(factory) :\n    global.moment = factory()\n}(this, (function () { 'use strict';\n\nvar hookCallback;\n\nfunction hooks () {\n    return hookCallback.apply(null, arguments);\n}\n\n// This is done to register the method called with moment()\n// without creating circular dependencies.\nfunction setHookCallback (callback) {\n    hookCallback = callback;\n}\n\nfunction isArray(input) {\n    return input instanceof Array || Object.prototype.toString.call(input) === '[object Array]';\n}\n\nfunction isObject(input) {\n    // IE8 will treat undefined and null as object if it wasn't for\n    // input != null\n    return input != null && Object.prototype.toString.call(input) === '[object Object]';\n}\n\nfunction isObjectEmpty(obj) {\n    var k;\n    for (k in obj) {\n        // even if its not own property I'd still call it non-empty\n        return false;\n    }\n    return true;\n}\n\nfunction isUndefined(input) {\n    return input === void 0;\n}\n\nfunction isNumber(input) {\n    return typeof input === 'number' || Object.prototype.toString.call(input) === '[object Number]';\n}\n\nfunction isDate(input) {\n    return input instanceof Date || Object.prototype.toString.call(input) === '[object Date]';\n}\n\nfunction map(arr, fn) {\n    var res = [], i;\n    for (i = 0; i < arr.length; ++i) {\n        res.push(fn(arr[i], i));\n    }\n    return res;\n}\n\nfunction hasOwnProp(a, b) {\n    return Object.prototype.hasOwnProperty.call(a, b);\n}\n\nfunction extend(a, b) {\n    for (var i in b) {\n        if (hasOwnProp(b, i)) {\n            a[i] = b[i];\n        }\n    }\n\n    if (hasOwnProp(b, 'toString')) {\n        a.toString = b.toString;\n    }\n\n    if (hasOwnProp(b, 'valueOf')) {\n        a.valueOf = b.valueOf;\n    }\n\n    return a;\n}\n\nfunction createUTC (input, format, locale, strict) {\n    return createLocalOrUTC(input, format, locale, strict, true).utc();\n}\n\nfunction defaultParsingFlags() {\n    // We need to deep clone this object.\n    return {\n        empty           : false,\n        unusedTokens    : [],\n        unusedInput     : [],\n        overflow        : -2,\n        charsLeftOver   : 0,\n        nullInput       : false,\n        invalidMonth    : null,\n        invalidFormat   : false,\n        userInvalidated : false,\n        iso             : false,\n        parsedDateParts : [],\n        meridiem        : null,\n        rfc2822         : false,\n        weekdayMismatch : false\n    };\n}\n\nfunction getParsingFlags(m) {\n    if (m._pf == null) {\n        m._pf = defaultParsingFlags();\n    }\n    return m._pf;\n}\n\nvar some;\nif (Array.prototype.some) {\n    some = Array.prototype.some;\n} else {\n    some = function (fun) {\n        var t = Object(this);\n        var len = t.length >>> 0;\n\n        for (var i = 0; i < len; i++) {\n            if (i in t && fun.call(this, t[i], i, t)) {\n                return true;\n            }\n        }\n\n        return false;\n    };\n}\n\nvar some$1 = some;\n\nfunction isValid(m) {\n    if (m._isValid == null) {\n        var flags = getParsingFlags(m);\n        var parsedParts = some$1.call(flags.parsedDateParts, function (i) {\n            return i != null;\n        });\n        var isNowValid = !isNaN(m._d.getTime()) &&\n            flags.overflow < 0 &&\n            !flags.empty &&\n            !flags.invalidMonth &&\n            !flags.invalidWeekday &&\n            !flags.nullInput &&\n            !flags.invalidFormat &&\n            !flags.userInvalidated &&\n            (!flags.meridiem || (flags.meridiem && parsedParts));\n\n        if (m._strict) {\n            isNowValid = isNowValid &&\n                flags.charsLeftOver === 0 &&\n                flags.unusedTokens.length === 0 &&\n                flags.bigHour === undefined;\n        }\n\n        if (Object.isFrozen == null || !Object.isFrozen(m)) {\n            m._isValid = isNowValid;\n        }\n        else {\n            return isNowValid;\n        }\n    }\n    return m._isValid;\n}\n\nfunction createInvalid (flags) {\n    var m = createUTC(NaN);\n    if (flags != null) {\n        extend(getParsingFlags(m), flags);\n    }\n    else {\n        getParsingFlags(m).userInvalidated = true;\n    }\n\n    return m;\n}\n\n// Plugins that add properties should also add the key here (null value),\n// so we can properly clone ourselves.\nvar momentProperties = hooks.momentProperties = [];\n\nfunction copyConfig(to, from) {\n    var i, prop, val;\n\n    if (!isUndefined(from._isAMomentObject)) {\n        to._isAMomentObject = from._isAMomentObject;\n    }\n    if (!isUndefined(from._i)) {\n        to._i = from._i;\n    }\n    if (!isUndefined(from._f)) {\n        to._f = from._f;\n    }\n    if (!isUndefined(from._l)) {\n        to._l = from._l;\n    }\n    if (!isUndefined(from._strict)) {\n        to._strict = from._strict;\n    }\n    if (!isUndefined(from._tzm)) {\n        to._tzm = from._tzm;\n    }\n    if (!isUndefined(from._isUTC)) {\n        to._isUTC = from._isUTC;\n    }\n    if (!isUndefined(from._offset)) {\n        to._offset = from._offset;\n    }\n    if (!isUndefined(from._pf)) {\n        to._pf = getParsingFlags(from);\n    }\n    if (!isUndefined(from._locale)) {\n        to._locale = from._locale;\n    }\n\n    if (momentProperties.length > 0) {\n        for (i = 0; i < momentProperties.length; i++) {\n            prop = momentProperties[i];\n            val = from[prop];\n            if (!isUndefined(val)) {\n                to[prop] = val;\n            }\n        }\n    }\n\n    return to;\n}\n\nvar updateInProgress = false;\n\n// Moment prototype object\nfunction Moment(config) {\n    copyConfig(this, config);\n    this._d = new Date(config._d != null ? config._d.getTime() : NaN);\n    if (!this.isValid()) {\n        this._d = new Date(NaN);\n    }\n    // Prevent infinite loop in case updateOffset creates new moment\n    // objects.\n    if (updateInProgress === false) {\n        updateInProgress = true;\n        hooks.updateOffset(this);\n        updateInProgress = false;\n    }\n}\n\nfunction isMoment (obj) {\n    return obj instanceof Moment || (obj != null && obj._isAMomentObject != null);\n}\n\nfunction absFloor (number) {\n    if (number < 0) {\n        // -0 -> 0\n        return Math.ceil(number) || 0;\n    } else {\n        return Math.floor(number);\n    }\n}\n\nfunction toInt(argumentForCoercion) {\n    var coercedNumber = +argumentForCoercion,\n        value = 0;\n\n    if (coercedNumber !== 0 && isFinite(coercedNumber)) {\n        value = absFloor(coercedNumber);\n    }\n\n    return value;\n}\n\n// compare two arrays, return the number of differences\nfunction compareArrays(array1, array2, dontConvert) {\n    var len = Math.min(array1.length, array2.length),\n        lengthDiff = Math.abs(array1.length - array2.length),\n        diffs = 0,\n        i;\n    for (i = 0; i < len; i++) {\n        if ((dontConvert && array1[i] !== array2[i]) ||\n            (!dontConvert && toInt(array1[i]) !== toInt(array2[i]))) {\n            diffs++;\n        }\n    }\n    return diffs + lengthDiff;\n}\n\nfunction warn(msg) {\n    if (hooks.suppressDeprecationWarnings === false &&\n            (typeof console !==  'undefined') && console.warn) {\n        console.warn('Deprecation warning: ' + msg);\n    }\n}\n\nfunction deprecate(msg, fn) {\n    var firstTime = true;\n\n    return extend(function () {\n        if (hooks.deprecationHandler != null) {\n            hooks.deprecationHandler(null, msg);\n        }\n        if (firstTime) {\n            var args = [];\n            var arg;\n            for (var i = 0; i < arguments.length; i++) {\n                arg = '';\n                if (typeof arguments[i] === 'object') {\n                    arg += '\\n[' + i + '] ';\n                    for (var key in arguments[0]) {\n                        arg += key + ': ' + arguments[0][key] + ', ';\n                    }\n                    arg = arg.slice(0, -2); // Remove trailing comma and space\n                } else {\n                    arg = arguments[i];\n                }\n                args.push(arg);\n            }\n            warn(msg + '\\nArguments: ' + Array.prototype.slice.call(args).join('') + '\\n' + (new Error()).stack);\n            firstTime = false;\n        }\n        return fn.apply(this, arguments);\n    }, fn);\n}\n\nvar deprecations = {};\n\nfunction deprecateSimple(name, msg) {\n    if (hooks.deprecationHandler != null) {\n        hooks.deprecationHandler(name, msg);\n    }\n    if (!deprecations[name]) {\n        warn(msg);\n        deprecations[name] = true;\n    }\n}\n\nhooks.suppressDeprecationWarnings = false;\nhooks.deprecationHandler = null;\n\nfunction isFunction(input) {\n    return input instanceof Function || Object.prototype.toString.call(input) === '[object Function]';\n}\n\nfunction set (config) {\n    var prop, i;\n    for (i in config) {\n        prop = config[i];\n        if (isFunction(prop)) {\n            this[i] = prop;\n        } else {\n            this['_' + i] = prop;\n        }\n    }\n    this._config = config;\n    // Lenient ordinal parsing accepts just a number in addition to\n    // number + (possibly) stuff coming from _dayOfMonthOrdinalParse.\n    // TODO: Remove \"ordinalParse\" fallback in next major release.\n    this._dayOfMonthOrdinalParseLenient = new RegExp(\n        (this._dayOfMonthOrdinalParse.source || this._ordinalParse.source) +\n            '|' + (/\\d{1,2}/).source);\n}\n\nfunction mergeConfigs(parentConfig, childConfig) {\n    var res = extend({}, parentConfig), prop;\n    for (prop in childConfig) {\n        if (hasOwnProp(childConfig, prop)) {\n            if (isObject(parentConfig[prop]) && isObject(childConfig[prop])) {\n                res[prop] = {};\n                extend(res[prop], parentConfig[prop]);\n                extend(res[prop], childConfig[prop]);\n            } else if (childConfig[prop] != null) {\n                res[prop] = childConfig[prop];\n            } else {\n                delete res[prop];\n            }\n        }\n    }\n    for (prop in parentConfig) {\n        if (hasOwnProp(parentConfig, prop) &&\n                !hasOwnProp(childConfig, prop) &&\n                isObject(parentConfig[prop])) {\n            // make sure changes to properties don't modify parent config\n            res[prop] = extend({}, res[prop]);\n        }\n    }\n    return res;\n}\n\nfunction Locale(config) {\n    if (config != null) {\n        this.set(config);\n    }\n}\n\nvar keys;\n\nif (Object.keys) {\n    keys = Object.keys;\n} else {\n    keys = function (obj) {\n        var i, res = [];\n        for (i in obj) {\n            if (hasOwnProp(obj, i)) {\n                res.push(i);\n            }\n        }\n        return res;\n    };\n}\n\nvar keys$1 = keys;\n\nvar defaultCalendar = {\n    sameDay : '[Today at] LT',\n    nextDay : '[Tomorrow at] LT',\n    nextWeek : 'dddd [at] LT',\n    lastDay : '[Yesterday at] LT',\n    lastWeek : '[Last] dddd [at] LT',\n    sameElse : 'L'\n};\n\nfunction calendar (key, mom, now) {\n    var output = this._calendar[key] || this._calendar['sameElse'];\n    return isFunction(output) ? output.call(mom, now) : output;\n}\n\nvar defaultLongDateFormat = {\n    LTS  : 'h:mm:ss A',\n    LT   : 'h:mm A',\n    L    : 'MM/DD/YYYY',\n    LL   : 'MMMM D, YYYY',\n    LLL  : 'MMMM D, YYYY h:mm A',\n    LLLL : 'dddd, MMMM D, YYYY h:mm A'\n};\n\nfunction longDateFormat (key) {\n    var format = this._longDateFormat[key],\n        formatUpper = this._longDateFormat[key.toUpperCase()];\n\n    if (format || !formatUpper) {\n        return format;\n    }\n\n    this._longDateFormat[key] = formatUpper.replace(/MMMM|MM|DD|dddd/g, function (val) {\n        return val.slice(1);\n    });\n\n    return this._longDateFormat[key];\n}\n\nvar defaultInvalidDate = 'Invalid date';\n\nfunction invalidDate () {\n    return this._invalidDate;\n}\n\nvar defaultOrdinal = '%d';\nvar defaultDayOfMonthOrdinalParse = /\\d{1,2}/;\n\nfunction ordinal (number) {\n    return this._ordinal.replace('%d', number);\n}\n\nvar defaultRelativeTime = {\n    future : 'in %s',\n    past   : '%s ago',\n    s  : 'a few seconds',\n    ss : '%d seconds',\n    m  : 'a minute',\n    mm : '%d minutes',\n    h  : 'an hour',\n    hh : '%d hours',\n    d  : 'a day',\n    dd : '%d days',\n    M  : 'a month',\n    MM : '%d months',\n    y  : 'a year',\n    yy : '%d years'\n};\n\nfunction relativeTime (number, withoutSuffix, string, isFuture) {\n    var output = this._relativeTime[string];\n    return (isFunction(output)) ?\n        output(number, withoutSuffix, string, isFuture) :\n        output.replace(/%d/i, number);\n}\n\nfunction pastFuture (diff, output) {\n    var format = this._relativeTime[diff > 0 ? 'future' : 'past'];\n    return isFunction(format) ? format(output) : format.replace(/%s/i, output);\n}\n\nvar aliases = {};\n\nfunction addUnitAlias (unit, shorthand) {\n    var lowerCase = unit.toLowerCase();\n    aliases[lowerCase] = aliases[lowerCase + 's'] = aliases[shorthand] = unit;\n}\n\nfunction normalizeUnits(units) {\n    return typeof units === 'string' ? aliases[units] || aliases[units.toLowerCase()] : undefined;\n}\n\nfunction normalizeObjectUnits(inputObject) {\n    var normalizedInput = {},\n        normalizedProp,\n        prop;\n\n    for (prop in inputObject) {\n        if (hasOwnProp(inputObject, prop)) {\n            normalizedProp = normalizeUnits(prop);\n            if (normalizedProp) {\n                normalizedInput[normalizedProp] = inputObject[prop];\n            }\n        }\n    }\n\n    return normalizedInput;\n}\n\nvar priorities = {};\n\nfunction addUnitPriority(unit, priority) {\n    priorities[unit] = priority;\n}\n\nfunction getPrioritizedUnits(unitsObj) {\n    var units = [];\n    for (var u in unitsObj) {\n        units.push({unit: u, priority: priorities[u]});\n    }\n    units.sort(function (a, b) {\n        return a.priority - b.priority;\n    });\n    return units;\n}\n\nfunction makeGetSet (unit, keepTime) {\n    return function (value) {\n        if (value != null) {\n            set$1(this, unit, value);\n            hooks.updateOffset(this, keepTime);\n            return this;\n        } else {\n            return get(this, unit);\n        }\n    };\n}\n\nfunction get (mom, unit) {\n    return mom.isValid() ?\n        mom._d['get' + (mom._isUTC ? 'UTC' : '') + unit]() : NaN;\n}\n\nfunction set$1 (mom, unit, value) {\n    if (mom.isValid()) {\n        mom._d['set' + (mom._isUTC ? 'UTC' : '') + unit](value);\n    }\n}\n\n// MOMENTS\n\nfunction stringGet (units) {\n    units = normalizeUnits(units);\n    if (isFunction(this[units])) {\n        return this[units]();\n    }\n    return this;\n}\n\n\nfunction stringSet (units, value) {\n    if (typeof units === 'object') {\n        units = normalizeObjectUnits(units);\n        var prioritized = getPrioritizedUnits(units);\n        for (var i = 0; i < prioritized.length; i++) {\n            this[prioritized[i].unit](units[prioritized[i].unit]);\n        }\n    } else {\n        units = normalizeUnits(units);\n        if (isFunction(this[units])) {\n            return this[units](value);\n        }\n    }\n    return this;\n}\n\nfunction zeroFill(number, targetLength, forceSign) {\n    var absNumber = '' + Math.abs(number),\n        zerosToFill = targetLength - absNumber.length,\n        sign = number >= 0;\n    return (sign ? (forceSign ? '+' : '') : '-') +\n        Math.pow(10, Math.max(0, zerosToFill)).toString().substr(1) + absNumber;\n}\n\nvar formattingTokens = /(\\[[^\\[]*\\])|(\\\\)?([Hh]mm(ss)?|Mo|MM?M?M?|Do|DDDo|DD?D?D?|ddd?d?|do?|w[o|w]?|W[o|W]?|Qo?|YYYYYY|YYYYY|YYYY|YY|gg(ggg?)?|GG(GGG?)?|e|E|a|A|hh?|HH?|kk?|mm?|ss?|S{1,9}|x|X|zz?|ZZ?|.)/g;\n\nvar localFormattingTokens = /(\\[[^\\[]*\\])|(\\\\)?(LTS|LT|LL?L?L?|l{1,4})/g;\n\nvar formatFunctions = {};\n\nvar formatTokenFunctions = {};\n\n// token:    'M'\n// padded:   ['MM', 2]\n// ordinal:  'Mo'\n// callback: function () { this.month() + 1 }\nfunction addFormatToken (token, padded, ordinal, callback) {\n    var func = callback;\n    if (typeof callback === 'string') {\n        func = function () {\n            return this[callback]();\n        };\n    }\n    if (token) {\n        formatTokenFunctions[token] = func;\n    }\n    if (padded) {\n        formatTokenFunctions[padded[0]] = function () {\n            return zeroFill(func.apply(this, arguments), padded[1], padded[2]);\n        };\n    }\n    if (ordinal) {\n        formatTokenFunctions[ordinal] = function () {\n            return this.localeData().ordinal(func.apply(this, arguments), token);\n        };\n    }\n}\n\nfunction removeFormattingTokens(input) {\n    if (input.match(/\\[[\\s\\S]/)) {\n        return input.replace(/^\\[|\\]$/g, '');\n    }\n    return input.replace(/\\\\/g, '');\n}\n\nfunction makeFormatFunction(format) {\n    var array = format.match(formattingTokens), i, length;\n\n    for (i = 0, length = array.length; i < length; i++) {\n        if (formatTokenFunctions[array[i]]) {\n            array[i] = formatTokenFunctions[array[i]];\n        } else {\n            array[i] = removeFormattingTokens(array[i]);\n        }\n    }\n\n    return function (mom) {\n        var output = '', i;\n        for (i = 0; i < length; i++) {\n            output += isFunction(array[i]) ? array[i].call(mom, format) : array[i];\n        }\n        return output;\n    };\n}\n\n// format date using native date object\nfunction formatMoment(m, format) {\n    if (!m.isValid()) {\n        return m.localeData().invalidDate();\n    }\n\n    format = expandFormat(format, m.localeData());\n    formatFunctions[format] = formatFunctions[format] || makeFormatFunction(format);\n\n    return formatFunctions[format](m);\n}\n\nfunction expandFormat(format, locale) {\n    var i = 5;\n\n    function replaceLongDateFormatTokens(input) {\n        return locale.longDateFormat(input) || input;\n    }\n\n    localFormattingTokens.lastIndex = 0;\n    while (i >= 0 && localFormattingTokens.test(format)) {\n        format = format.replace(localFormattingTokens, replaceLongDateFormatTokens);\n        localFormattingTokens.lastIndex = 0;\n        i -= 1;\n    }\n\n    return format;\n}\n\nvar match1         = /\\d/;            //       0 - 9\nvar match2         = /\\d\\d/;          //      00 - 99\nvar match3         = /\\d{3}/;         //     000 - 999\nvar match4         = /\\d{4}/;         //    0000 - 9999\nvar match6         = /[+-]?\\d{6}/;    // -999999 - 999999\nvar match1to2      = /\\d\\d?/;         //       0 - 99\nvar match3to4      = /\\d\\d\\d\\d?/;     //     999 - 9999\nvar match5to6      = /\\d\\d\\d\\d\\d\\d?/; //   99999 - 999999\nvar match1to3      = /\\d{1,3}/;       //       0 - 999\nvar match1to4      = /\\d{1,4}/;       //       0 - 9999\nvar match1to6      = /[+-]?\\d{1,6}/;  // -999999 - 999999\n\nvar matchUnsigned  = /\\d+/;           //       0 - inf\nvar matchSigned    = /[+-]?\\d+/;      //    -inf - inf\n\nvar matchOffset    = /Z|[+-]\\d\\d:?\\d\\d/gi; // +00:00 -00:00 +0000 -0000 or Z\nvar matchShortOffset = /Z|[+-]\\d\\d(?::?\\d\\d)?/gi; // +00 -00 +00:00 -00:00 +0000 -0000 or Z\n\nvar matchTimestamp = /[+-]?\\d+(\\.\\d{1,3})?/; // 123456789 123456789.123\n\n// any word (or two) characters or numbers including two/three word month in arabic.\n// includes scottish gaelic two word and hyphenated months\nvar matchWord = /[0-9]*['a-z\\u00A0-\\u05FF\\u0700-\\uD7FF\\uF900-\\uFDCF\\uFDF0-\\uFFEF]+|[\\u0600-\\u06FF\\/]+(\\s*?[\\u0600-\\u06FF]+){1,2}/i;\n\n\nvar regexes = {};\n\nfunction addRegexToken (token, regex, strictRegex) {\n    regexes[token] = isFunction(regex) ? regex : function (isStrict, localeData) {\n        return (isStrict && strictRegex) ? strictRegex : regex;\n    };\n}\n\nfunction getParseRegexForToken (token, config) {\n    if (!hasOwnProp(regexes, token)) {\n        return new RegExp(unescapeFormat(token));\n    }\n\n    return regexes[token](config._strict, config._locale);\n}\n\n// Code from http://stackoverflow.com/questions/3561493/is-there-a-regexp-escape-function-in-javascript\nfunction unescapeFormat(s) {\n    return regexEscape(s.replace('\\\\', '').replace(/\\\\(\\[)|\\\\(\\])|\\[([^\\]\\[]*)\\]|\\\\(.)/g, function (matched, p1, p2, p3, p4) {\n        return p1 || p2 || p3 || p4;\n    }));\n}\n\nfunction regexEscape(s) {\n    return s.replace(/[-\\/\\\\^$*+?.()|[\\]{}]/g, '\\\\$&');\n}\n\nvar tokens = {};\n\nfunction addParseToken (token, callback) {\n    var i, func = callback;\n    if (typeof token === 'string') {\n        token = [token];\n    }\n    if (isNumber(callback)) {\n        func = function (input, array) {\n            array[callback] = toInt(input);\n        };\n    }\n    for (i = 0; i < token.length; i++) {\n        tokens[token[i]] = func;\n    }\n}\n\nfunction addWeekParseToken (token, callback) {\n    addParseToken(token, function (input, array, config, token) {\n        config._w = config._w || {};\n        callback(input, config._w, config, token);\n    });\n}\n\nfunction addTimeToArrayFromToken(token, input, config) {\n    if (input != null && hasOwnProp(tokens, token)) {\n        tokens[token](input, config._a, config, token);\n    }\n}\n\nvar YEAR = 0;\nvar MONTH = 1;\nvar DATE = 2;\nvar HOUR = 3;\nvar MINUTE = 4;\nvar SECOND = 5;\nvar MILLISECOND = 6;\nvar WEEK = 7;\nvar WEEKDAY = 8;\n\nvar indexOf;\n\nif (Array.prototype.indexOf) {\n    indexOf = Array.prototype.indexOf;\n} else {\n    indexOf = function (o) {\n        // I know\n        var i;\n        for (i = 0; i < this.length; ++i) {\n            if (this[i] === o) {\n                return i;\n            }\n        }\n        return -1;\n    };\n}\n\nvar indexOf$1 = indexOf;\n\nfunction daysInMonth(year, month) {\n    return new Date(Date.UTC(year, month + 1, 0)).getUTCDate();\n}\n\n// FORMATTING\n\naddFormatToken('M', ['MM', 2], 'Mo', function () {\n    return this.month() + 1;\n});\n\naddFormatToken('MMM', 0, 0, function (format) {\n    return this.localeData().monthsShort(this, format);\n});\n\naddFormatToken('MMMM', 0, 0, function (format) {\n    return this.localeData().months(this, format);\n});\n\n// ALIASES\n\naddUnitAlias('month', 'M');\n\n// PRIORITY\n\naddUnitPriority('month', 8);\n\n// PARSING\n\naddRegexToken('M',    match1to2);\naddRegexToken('MM',   match1to2, match2);\naddRegexToken('MMM',  function (isStrict, locale) {\n    return locale.monthsShortRegex(isStrict);\n});\naddRegexToken('MMMM', function (isStrict, locale) {\n    return locale.monthsRegex(isStrict);\n});\n\naddParseToken(['M', 'MM'], function (input, array) {\n    array[MONTH] = toInt(input) - 1;\n});\n\naddParseToken(['MMM', 'MMMM'], function (input, array, config, token) {\n    var month = config._locale.monthsParse(input, token, config._strict);\n    // if we didn't find a month name, mark the date as invalid.\n    if (month != null) {\n        array[MONTH] = month;\n    } else {\n        getParsingFlags(config).invalidMonth = input;\n    }\n});\n\n// LOCALES\n\nvar MONTHS_IN_FORMAT = /D[oD]?(\\[[^\\[\\]]*\\]|\\s)+MMMM?/;\nvar defaultLocaleMonths = 'January_February_March_April_May_June_July_August_September_October_November_December'.split('_');\nfunction localeMonths (m, format) {\n    if (!m) {\n        return isArray(this._months) ? this._months :\n            this._months['standalone'];\n    }\n    return isArray(this._months) ? this._months[m.month()] :\n        this._months[(this._months.isFormat || MONTHS_IN_FORMAT).test(format) ? 'format' : 'standalone'][m.month()];\n}\n\nvar defaultLocaleMonthsShort = 'Jan_Feb_Mar_Apr_May_Jun_Jul_Aug_Sep_Oct_Nov_Dec'.split('_');\nfunction localeMonthsShort (m, format) {\n    if (!m) {\n        return isArray(this._monthsShort) ? this._monthsShort :\n            this._monthsShort['standalone'];\n    }\n    return isArray(this._monthsShort) ? this._monthsShort[m.month()] :\n        this._monthsShort[MONTHS_IN_FORMAT.test(format) ? 'format' : 'standalone'][m.month()];\n}\n\nfunction handleStrictParse(monthName, format, strict) {\n    var i, ii, mom, llc = monthName.toLocaleLowerCase();\n    if (!this._monthsParse) {\n        // this is not used\n        this._monthsParse = [];\n        this._longMonthsParse = [];\n        this._shortMonthsParse = [];\n        for (i = 0; i < 12; ++i) {\n            mom = createUTC([2000, i]);\n            this._shortMonthsParse[i] = this.monthsShort(mom, '').toLocaleLowerCase();\n            this._longMonthsParse[i] = this.months(mom, '').toLocaleLowerCase();\n        }\n    }\n\n    if (strict) {\n        if (format === 'MMM') {\n            ii = indexOf$1.call(this._shortMonthsParse, llc);\n            return ii !== -1 ? ii : null;\n        } else {\n            ii = indexOf$1.call(this._longMonthsParse, llc);\n            return ii !== -1 ? ii : null;\n        }\n    } else {\n        if (format === 'MMM') {\n            ii = indexOf$1.call(this._shortMonthsParse, llc);\n            if (ii !== -1) {\n                return ii;\n            }\n            ii = indexOf$1.call(this._longMonthsParse, llc);\n            return ii !== -1 ? ii : null;\n        } else {\n            ii = indexOf$1.call(this._longMonthsParse, llc);\n            if (ii !== -1) {\n                return ii;\n            }\n            ii = indexOf$1.call(this._shortMonthsParse, llc);\n            return ii !== -1 ? ii : null;\n        }\n    }\n}\n\nfunction localeMonthsParse (monthName, format, strict) {\n    var i, mom, regex;\n\n    if (this._monthsParseExact) {\n        return handleStrictParse.call(this, monthName, format, strict);\n    }\n\n    if (!this._monthsParse) {\n        this._monthsParse = [];\n        this._longMonthsParse = [];\n        this._shortMonthsParse = [];\n    }\n\n    // TODO: add sorting\n    // Sorting makes sure if one month (or abbr) is a prefix of another\n    // see sorting in computeMonthsParse\n    for (i = 0; i < 12; i++) {\n        // make the regex if we don't have it already\n        mom = createUTC([2000, i]);\n        if (strict && !this._longMonthsParse[i]) {\n            this._longMonthsParse[i] = new RegExp('^' + this.months(mom, '').replace('.', '') + '$', 'i');\n            this._shortMonthsParse[i] = new RegExp('^' + this.monthsShort(mom, '').replace('.', '') + '$', 'i');\n        }\n        if (!strict && !this._monthsParse[i]) {\n            regex = '^' + this.months(mom, '') + '|^' + this.monthsShort(mom, '');\n            this._monthsParse[i] = new RegExp(regex.replace('.', ''), 'i');\n        }\n        // test the regex\n        if (strict && format === 'MMMM' && this._longMonthsParse[i].test(monthName)) {\n            return i;\n        } else if (strict && format === 'MMM' && this._shortMonthsParse[i].test(monthName)) {\n            return i;\n        } else if (!strict && this._monthsParse[i].test(monthName)) {\n            return i;\n        }\n    }\n}\n\n// MOMENTS\n\nfunction setMonth (mom, value) {\n    var dayOfMonth;\n\n    if (!mom.isValid()) {\n        // No op\n        return mom;\n    }\n\n    if (typeof value === 'string') {\n        if (/^\\d+$/.test(value)) {\n            value = toInt(value);\n        } else {\n            value = mom.localeData().monthsParse(value);\n            // TODO: Another silent failure?\n            if (!isNumber(value)) {\n                return mom;\n            }\n        }\n    }\n\n    dayOfMonth = Math.min(mom.date(), daysInMonth(mom.year(), value));\n    mom._d['set' + (mom._isUTC ? 'UTC' : '') + 'Month'](value, dayOfMonth);\n    return mom;\n}\n\nfunction getSetMonth (value) {\n    if (value != null) {\n        setMonth(this, value);\n        hooks.updateOffset(this, true);\n        return this;\n    } else {\n        return get(this, 'Month');\n    }\n}\n\nfunction getDaysInMonth () {\n    return daysInMonth(this.year(), this.month());\n}\n\nvar defaultMonthsShortRegex = matchWord;\nfunction monthsShortRegex (isStrict) {\n    if (this._monthsParseExact) {\n        if (!hasOwnProp(this, '_monthsRegex')) {\n            computeMonthsParse.call(this);\n        }\n        if (isStrict) {\n            return this._monthsShortStrictRegex;\n        } else {\n            return this._monthsShortRegex;\n        }\n    } else {\n        if (!hasOwnProp(this, '_monthsShortRegex')) {\n            this._monthsShortRegex = defaultMonthsShortRegex;\n        }\n        return this._monthsShortStrictRegex && isStrict ?\n            this._monthsShortStrictRegex : this._monthsShortRegex;\n    }\n}\n\nvar defaultMonthsRegex = matchWord;\nfunction monthsRegex (isStrict) {\n    if (this._monthsParseExact) {\n        if (!hasOwnProp(this, '_monthsRegex')) {\n            computeMonthsParse.call(this);\n        }\n        if (isStrict) {\n            return this._monthsStrictRegex;\n        } else {\n            return this._monthsRegex;\n        }\n    } else {\n        if (!hasOwnProp(this, '_monthsRegex')) {\n            this._monthsRegex = defaultMonthsRegex;\n        }\n        return this._monthsStrictRegex && isStrict ?\n            this._monthsStrictRegex : this._monthsRegex;\n    }\n}\n\nfunction computeMonthsParse () {\n    function cmpLenRev(a, b) {\n        return b.length - a.length;\n    }\n\n    var shortPieces = [], longPieces = [], mixedPieces = [],\n        i, mom;\n    for (i = 0; i < 12; i++) {\n        // make the regex if we don't have it already\n        mom = createUTC([2000, i]);\n        shortPieces.push(this.monthsShort(mom, ''));\n        longPieces.push(this.months(mom, ''));\n        mixedPieces.push(this.months(mom, ''));\n        mixedPieces.push(this.monthsShort(mom, ''));\n    }\n    // Sorting makes sure if one month (or abbr) is a prefix of another it\n    // will match the longer piece.\n    shortPieces.sort(cmpLenRev);\n    longPieces.sort(cmpLenRev);\n    mixedPieces.sort(cmpLenRev);\n    for (i = 0; i < 12; i++) {\n        shortPieces[i] = regexEscape(shortPieces[i]);\n        longPieces[i] = regexEscape(longPieces[i]);\n    }\n    for (i = 0; i < 24; i++) {\n        mixedPieces[i] = regexEscape(mixedPieces[i]);\n    }\n\n    this._monthsRegex = new RegExp('^(' + mixedPieces.join('|') + ')', 'i');\n    this._monthsShortRegex = this._monthsRegex;\n    this._monthsStrictRegex = new RegExp('^(' + longPieces.join('|') + ')', 'i');\n    this._monthsShortStrictRegex = new RegExp('^(' + shortPieces.join('|') + ')', 'i');\n}\n\n// FORMATTING\n\naddFormatToken('Y', 0, 0, function () {\n    var y = this.year();\n    return y <= 9999 ? '' + y : '+' + y;\n});\n\naddFormatToken(0, ['YY', 2], 0, function () {\n    return this.year() % 100;\n});\n\naddFormatToken(0, ['YYYY',   4],       0, 'year');\naddFormatToken(0, ['YYYYY',  5],       0, 'year');\naddFormatToken(0, ['YYYYYY', 6, true], 0, 'year');\n\n// ALIASES\n\naddUnitAlias('year', 'y');\n\n// PRIORITIES\n\naddUnitPriority('year', 1);\n\n// PARSING\n\naddRegexToken('Y',      matchSigned);\naddRegexToken('YY',     match1to2, match2);\naddRegexToken('YYYY',   match1to4, match4);\naddRegexToken('YYYYY',  match1to6, match6);\naddRegexToken('YYYYYY', match1to6, match6);\n\naddParseToken(['YYYYY', 'YYYYYY'], YEAR);\naddParseToken('YYYY', function (input, array) {\n    array[YEAR] = input.length === 2 ? hooks.parseTwoDigitYear(input) : toInt(input);\n});\naddParseToken('YY', function (input, array) {\n    array[YEAR] = hooks.parseTwoDigitYear(input);\n});\naddParseToken('Y', function (input, array) {\n    array[YEAR] = parseInt(input, 10);\n});\n\n// HELPERS\n\nfunction daysInYear(year) {\n    return isLeapYear(year) ? 366 : 365;\n}\n\nfunction isLeapYear(year) {\n    return (year % 4 === 0 && year % 100 !== 0) || year % 400 === 0;\n}\n\n// HOOKS\n\nhooks.parseTwoDigitYear = function (input) {\n    return toInt(input) + (toInt(input) > 68 ? 1900 : 2000);\n};\n\n// MOMENTS\n\nvar getSetYear = makeGetSet('FullYear', true);\n\nfunction getIsLeapYear () {\n    return isLeapYear(this.year());\n}\n\nfunction createDate (y, m, d, h, M, s, ms) {\n    // can't just apply() to create a date:\n    // https://stackoverflow.com/q/181348\n    var date = new Date(y, m, d, h, M, s, ms);\n\n    // the date constructor remaps years 0-99 to 1900-1999\n    if (y < 100 && y >= 0 && isFinite(date.getFullYear())) {\n        date.setFullYear(y);\n    }\n    return date;\n}\n\nfunction createUTCDate (y) {\n    var date = new Date(Date.UTC.apply(null, arguments));\n\n    // the Date.UTC function remaps years 0-99 to 1900-1999\n    if (y < 100 && y >= 0 && isFinite(date.getUTCFullYear())) {\n        date.setUTCFullYear(y);\n    }\n    return date;\n}\n\n// start-of-first-week - start-of-year\nfunction firstWeekOffset(year, dow, doy) {\n    var // first-week day -- which january is always in the first week (4 for iso, 1 for other)\n        fwd = 7 + dow - doy,\n        // first-week day local weekday -- which local weekday is fwd\n        fwdlw = (7 + createUTCDate(year, 0, fwd).getUTCDay() - dow) % 7;\n\n    return -fwdlw + fwd - 1;\n}\n\n// https://en.wikipedia.org/wiki/ISO_week_date#Calculating_a_date_given_the_year.2C_week_number_and_weekday\nfunction dayOfYearFromWeeks(year, week, weekday, dow, doy) {\n    var localWeekday = (7 + weekday - dow) % 7,\n        weekOffset = firstWeekOffset(year, dow, doy),\n        dayOfYear = 1 + 7 * (week - 1) + localWeekday + weekOffset,\n        resYear, resDayOfYear;\n\n    if (dayOfYear <= 0) {\n        resYear = year - 1;\n        resDayOfYear = daysInYear(resYear) + dayOfYear;\n    } else if (dayOfYear > daysInYear(year)) {\n        resYear = year + 1;\n        resDayOfYear = dayOfYear - daysInYear(year);\n    } else {\n        resYear = year;\n        resDayOfYear = dayOfYear;\n    }\n\n    return {\n        year: resYear,\n        dayOfYear: resDayOfYear\n    };\n}\n\nfunction weekOfYear(mom, dow, doy) {\n    var weekOffset = firstWeekOffset(mom.year(), dow, doy),\n        week = Math.floor((mom.dayOfYear() - weekOffset - 1) / 7) + 1,\n        resWeek, resYear;\n\n    if (week < 1) {\n        resYear = mom.year() - 1;\n        resWeek = week + weeksInYear(resYear, dow, doy);\n    } else if (week > weeksInYear(mom.year(), dow, doy)) {\n        resWeek = week - weeksInYear(mom.year(), dow, doy);\n        resYear = mom.year() + 1;\n    } else {\n        resYear = mom.year();\n        resWeek = week;\n    }\n\n    return {\n        week: resWeek,\n        year: resYear\n    };\n}\n\nfunction weeksInYear(year, dow, doy) {\n    var weekOffset = firstWeekOffset(year, dow, doy),\n        weekOffsetNext = firstWeekOffset(year + 1, dow, doy);\n    return (daysInYear(year) - weekOffset + weekOffsetNext) / 7;\n}\n\n// FORMATTING\n\naddFormatToken('w', ['ww', 2], 'wo', 'week');\naddFormatToken('W', ['WW', 2], 'Wo', 'isoWeek');\n\n// ALIASES\n\naddUnitAlias('week', 'w');\naddUnitAlias('isoWeek', 'W');\n\n// PRIORITIES\n\naddUnitPriority('week', 5);\naddUnitPriority('isoWeek', 5);\n\n// PARSING\n\naddRegexToken('w',  match1to2);\naddRegexToken('ww', match1to2, match2);\naddRegexToken('W',  match1to2);\naddRegexToken('WW', match1to2, match2);\n\naddWeekParseToken(['w', 'ww', 'W', 'WW'], function (input, week, config, token) {\n    week[token.substr(0, 1)] = toInt(input);\n});\n\n// HELPERS\n\n// LOCALES\n\nfunction localeWeek (mom) {\n    return weekOfYear(mom, this._week.dow, this._week.doy).week;\n}\n\nvar defaultLocaleWeek = {\n    dow : 0, // Sunday is the first day of the week.\n    doy : 6  // The week that contains Jan 1st is the first week of the year.\n};\n\nfunction localeFirstDayOfWeek () {\n    return this._week.dow;\n}\n\nfunction localeFirstDayOfYear () {\n    return this._week.doy;\n}\n\n// MOMENTS\n\nfunction getSetWeek (input) {\n    var week = this.localeData().week(this);\n    return input == null ? week : this.add((input - week) * 7, 'd');\n}\n\nfunction getSetISOWeek (input) {\n    var week = weekOfYear(this, 1, 4).week;\n    return input == null ? week : this.add((input - week) * 7, 'd');\n}\n\n// FORMATTING\n\naddFormatToken('d', 0, 'do', 'day');\n\naddFormatToken('dd', 0, 0, function (format) {\n    return this.localeData().weekdaysMin(this, format);\n});\n\naddFormatToken('ddd', 0, 0, function (format) {\n    return this.localeData().weekdaysShort(this, format);\n});\n\naddFormatToken('dddd', 0, 0, function (format) {\n    return this.localeData().weekdays(this, format);\n});\n\naddFormatToken('e', 0, 0, 'weekday');\naddFormatToken('E', 0, 0, 'isoWeekday');\n\n// ALIASES\n\naddUnitAlias('day', 'd');\naddUnitAlias('weekday', 'e');\naddUnitAlias('isoWeekday', 'E');\n\n// PRIORITY\naddUnitPriority('day', 11);\naddUnitPriority('weekday', 11);\naddUnitPriority('isoWeekday', 11);\n\n// PARSING\n\naddRegexToken('d',    match1to2);\naddRegexToken('e',    match1to2);\naddRegexToken('E',    match1to2);\naddRegexToken('dd',   function (isStrict, locale) {\n    return locale.weekdaysMinRegex(isStrict);\n});\naddRegexToken('ddd',   function (isStrict, locale) {\n    return locale.weekdaysShortRegex(isStrict);\n});\naddRegexToken('dddd',   function (isStrict, locale) {\n    return locale.weekdaysRegex(isStrict);\n});\n\naddWeekParseToken(['dd', 'ddd', 'dddd'], function (input, week, config, token) {\n    var weekday = config._locale.weekdaysParse(input, token, config._strict);\n    // if we didn't get a weekday name, mark the date as invalid\n    if (weekday != null) {\n        week.d = weekday;\n    } else {\n        getParsingFlags(config).invalidWeekday = input;\n    }\n});\n\naddWeekParseToken(['d', 'e', 'E'], function (input, week, config, token) {\n    week[token] = toInt(input);\n});\n\n// HELPERS\n\nfunction parseWeekday(input, locale) {\n    if (typeof input !== 'string') {\n        return input;\n    }\n\n    if (!isNaN(input)) {\n        return parseInt(input, 10);\n    }\n\n    input = locale.weekdaysParse(input);\n    if (typeof input === 'number') {\n        return input;\n    }\n\n    return null;\n}\n\nfunction parseIsoWeekday(input, locale) {\n    if (typeof input === 'string') {\n        return locale.weekdaysParse(input) % 7 || 7;\n    }\n    return isNaN(input) ? null : input;\n}\n\n// LOCALES\n\nvar defaultLocaleWeekdays = 'Sunday_Monday_Tuesday_Wednesday_Thursday_Friday_Saturday'.split('_');\nfunction localeWeekdays (m, format) {\n    if (!m) {\n        return isArray(this._weekdays) ? this._weekdays :\n            this._weekdays['standalone'];\n    }\n    return isArray(this._weekdays) ? this._weekdays[m.day()] :\n        this._weekdays[this._weekdays.isFormat.test(format) ? 'format' : 'standalone'][m.day()];\n}\n\nvar defaultLocaleWeekdaysShort = 'Sun_Mon_Tue_Wed_Thu_Fri_Sat'.split('_');\nfunction localeWeekdaysShort (m) {\n    return (m) ? this._weekdaysShort[m.day()] : this._weekdaysShort;\n}\n\nvar defaultLocaleWeekdaysMin = 'Su_Mo_Tu_We_Th_Fr_Sa'.split('_');\nfunction localeWeekdaysMin (m) {\n    return (m) ? this._weekdaysMin[m.day()] : this._weekdaysMin;\n}\n\nfunction handleStrictParse$1(weekdayName, format, strict) {\n    var i, ii, mom, llc = weekdayName.toLocaleLowerCase();\n    if (!this._weekdaysParse) {\n        this._weekdaysParse = [];\n        this._shortWeekdaysParse = [];\n        this._minWeekdaysParse = [];\n\n        for (i = 0; i < 7; ++i) {\n            mom = createUTC([2000, 1]).day(i);\n            this._minWeekdaysParse[i] = this.weekdaysMin(mom, '').toLocaleLowerCase();\n            this._shortWeekdaysParse[i] = this.weekdaysShort(mom, '').toLocaleLowerCase();\n            this._weekdaysParse[i] = this.weekdays(mom, '').toLocaleLowerCase();\n        }\n    }\n\n    if (strict) {\n        if (format === 'dddd') {\n            ii = indexOf$1.call(this._weekdaysParse, llc);\n            return ii !== -1 ? ii : null;\n        } else if (format === 'ddd') {\n            ii = indexOf$1.call(this._shortWeekdaysParse, llc);\n            return ii !== -1 ? ii : null;\n        } else {\n            ii = indexOf$1.call(this._minWeekdaysParse, llc);\n            return ii !== -1 ? ii : null;\n        }\n    } else {\n        if (format === 'dddd') {\n            ii = indexOf$1.call(this._weekdaysParse, llc);\n            if (ii !== -1) {\n                return ii;\n            }\n            ii = indexOf$1.call(this._shortWeekdaysParse, llc);\n            if (ii !== -1) {\n                return ii;\n            }\n            ii = indexOf$1.call(this._minWeekdaysParse, llc);\n            return ii !== -1 ? ii : null;\n        } else if (format === 'ddd') {\n            ii = indexOf$1.call(this._shortWeekdaysParse, llc);\n            if (ii !== -1) {\n                return ii;\n            }\n            ii = indexOf$1.call(this._weekdaysParse, llc);\n            if (ii !== -1) {\n                return ii;\n            }\n            ii = indexOf$1.call(this._minWeekdaysParse, llc);\n            return ii !== -1 ? ii : null;\n        } else {\n            ii = indexOf$1.call(this._minWeekdaysParse, llc);\n            if (ii !== -1) {\n                return ii;\n            }\n            ii = indexOf$1.call(this._weekdaysParse, llc);\n            if (ii !== -1) {\n                return ii;\n            }\n            ii = indexOf$1.call(this._shortWeekdaysParse, llc);\n            return ii !== -1 ? ii : null;\n        }\n    }\n}\n\nfunction localeWeekdaysParse (weekdayName, format, strict) {\n    var i, mom, regex;\n\n    if (this._weekdaysParseExact) {\n        return handleStrictParse$1.call(this, weekdayName, format, strict);\n    }\n\n    if (!this._weekdaysParse) {\n        this._weekdaysParse = [];\n        this._minWeekdaysParse = [];\n        this._shortWeekdaysParse = [];\n        this._fullWeekdaysParse = [];\n    }\n\n    for (i = 0; i < 7; i++) {\n        // make the regex if we don't have it already\n\n        mom = createUTC([2000, 1]).day(i);\n        if (strict && !this._fullWeekdaysParse[i]) {\n            this._fullWeekdaysParse[i] = new RegExp('^' + this.weekdays(mom, '').replace('.', '\\.?') + '$', 'i');\n            this._shortWeekdaysParse[i] = new RegExp('^' + this.weekdaysShort(mom, '').replace('.', '\\.?') + '$', 'i');\n            this._minWeekdaysParse[i] = new RegExp('^' + this.weekdaysMin(mom, '').replace('.', '\\.?') + '$', 'i');\n        }\n        if (!this._weekdaysParse[i]) {\n            regex = '^' + this.weekdays(mom, '') + '|^' + this.weekdaysShort(mom, '') + '|^' + this.weekdaysMin(mom, '');\n            this._weekdaysParse[i] = new RegExp(regex.replace('.', ''), 'i');\n        }\n        // test the regex\n        if (strict && format === 'dddd' && this._fullWeekdaysParse[i].test(weekdayName)) {\n            return i;\n        } else if (strict && format === 'ddd' && this._shortWeekdaysParse[i].test(weekdayName)) {\n            return i;\n        } else if (strict && format === 'dd' && this._minWeekdaysParse[i].test(weekdayName)) {\n            return i;\n        } else if (!strict && this._weekdaysParse[i].test(weekdayName)) {\n            return i;\n        }\n    }\n}\n\n// MOMENTS\n\nfunction getSetDayOfWeek (input) {\n    if (!this.isValid()) {\n        return input != null ? this : NaN;\n    }\n    var day = this._isUTC ? this._d.getUTCDay() : this._d.getDay();\n    if (input != null) {\n        input = parseWeekday(input, this.localeData());\n        return this.add(input - day, 'd');\n    } else {\n        return day;\n    }\n}\n\nfunction getSetLocaleDayOfWeek (input) {\n    if (!this.isValid()) {\n        return input != null ? this : NaN;\n    }\n    var weekday = (this.day() + 7 - this.localeData()._week.dow) % 7;\n    return input == null ? weekday : this.add(input - weekday, 'd');\n}\n\nfunction getSetISODayOfWeek (input) {\n    if (!this.isValid()) {\n        return input != null ? this : NaN;\n    }\n\n    // behaves the same as moment#day except\n    // as a getter, returns 7 instead of 0 (1-7 range instead of 0-6)\n    // as a setter, sunday should belong to the previous week.\n\n    if (input != null) {\n        var weekday = parseIsoWeekday(input, this.localeData());\n        return this.day(this.day() % 7 ? weekday : weekday - 7);\n    } else {\n        return this.day() || 7;\n    }\n}\n\nvar defaultWeekdaysRegex = matchWord;\nfunction weekdaysRegex (isStrict) {\n    if (this._weekdaysParseExact) {\n        if (!hasOwnProp(this, '_weekdaysRegex')) {\n            computeWeekdaysParse.call(this);\n        }\n        if (isStrict) {\n            return this._weekdaysStrictRegex;\n        } else {\n            return this._weekdaysRegex;\n        }\n    } else {\n        if (!hasOwnProp(this, '_weekdaysRegex')) {\n            this._weekdaysRegex = defaultWeekdaysRegex;\n        }\n        return this._weekdaysStrictRegex && isStrict ?\n            this._weekdaysStrictRegex : this._weekdaysRegex;\n    }\n}\n\nvar defaultWeekdaysShortRegex = matchWord;\nfunction weekdaysShortRegex (isStrict) {\n    if (this._weekdaysParseExact) {\n        if (!hasOwnProp(this, '_weekdaysRegex')) {\n            computeWeekdaysParse.call(this);\n        }\n        if (isStrict) {\n            return this._weekdaysShortStrictRegex;\n        } else {\n            return this._weekdaysShortRegex;\n        }\n    } else {\n        if (!hasOwnProp(this, '_weekdaysShortRegex')) {\n            this._weekdaysShortRegex = defaultWeekdaysShortRegex;\n        }\n        return this._weekdaysShortStrictRegex && isStrict ?\n            this._weekdaysShortStrictRegex : this._weekdaysShortRegex;\n    }\n}\n\nvar defaultWeekdaysMinRegex = matchWord;\nfunction weekdaysMinRegex (isStrict) {\n    if (this._weekdaysParseExact) {\n        if (!hasOwnProp(this, '_weekdaysRegex')) {\n            computeWeekdaysParse.call(this);\n        }\n        if (isStrict) {\n            return this._weekdaysMinStrictRegex;\n        } else {\n            return this._weekdaysMinRegex;\n        }\n    } else {\n        if (!hasOwnProp(this, '_weekdaysMinRegex')) {\n            this._weekdaysMinRegex = defaultWeekdaysMinRegex;\n        }\n        return this._weekdaysMinStrictRegex && isStrict ?\n            this._weekdaysMinStrictRegex : this._weekdaysMinRegex;\n    }\n}\n\n\nfunction computeWeekdaysParse () {\n    function cmpLenRev(a, b) {\n        return b.length - a.length;\n    }\n\n    var minPieces = [], shortPieces = [], longPieces = [], mixedPieces = [],\n        i, mom, minp, shortp, longp;\n    for (i = 0; i < 7; i++) {\n        // make the regex if we don't have it already\n        mom = createUTC([2000, 1]).day(i);\n        minp = this.weekdaysMin(mom, '');\n        shortp = this.weekdaysShort(mom, '');\n        longp = this.weekdays(mom, '');\n        minPieces.push(minp);\n        shortPieces.push(shortp);\n        longPieces.push(longp);\n        mixedPieces.push(minp);\n        mixedPieces.push(shortp);\n        mixedPieces.push(longp);\n    }\n    // Sorting makes sure if one weekday (or abbr) is a prefix of another it\n    // will match the longer piece.\n    minPieces.sort(cmpLenRev);\n    shortPieces.sort(cmpLenRev);\n    longPieces.sort(cmpLenRev);\n    mixedPieces.sort(cmpLenRev);\n    for (i = 0; i < 7; i++) {\n        shortPieces[i] = regexEscape(shortPieces[i]);\n        longPieces[i] = regexEscape(longPieces[i]);\n        mixedPieces[i] = regexEscape(mixedPieces[i]);\n    }\n\n    this._weekdaysRegex = new RegExp('^(' + mixedPieces.join('|') + ')', 'i');\n    this._weekdaysShortRegex = this._weekdaysRegex;\n    this._weekdaysMinRegex = this._weekdaysRegex;\n\n    this._weekdaysStrictRegex = new RegExp('^(' + longPieces.join('|') + ')', 'i');\n    this._weekdaysShortStrictRegex = new RegExp('^(' + shortPieces.join('|') + ')', 'i');\n    this._weekdaysMinStrictRegex = new RegExp('^(' + minPieces.join('|') + ')', 'i');\n}\n\n// FORMATTING\n\nfunction hFormat() {\n    return this.hours() % 12 || 12;\n}\n\nfunction kFormat() {\n    return this.hours() || 24;\n}\n\naddFormatToken('H', ['HH', 2], 0, 'hour');\naddFormatToken('h', ['hh', 2], 0, hFormat);\naddFormatToken('k', ['kk', 2], 0, kFormat);\n\naddFormatToken('hmm', 0, 0, function () {\n    return '' + hFormat.apply(this) + zeroFill(this.minutes(), 2);\n});\n\naddFormatToken('hmmss', 0, 0, function () {\n    return '' + hFormat.apply(this) + zeroFill(this.minutes(), 2) +\n        zeroFill(this.seconds(), 2);\n});\n\naddFormatToken('Hmm', 0, 0, function () {\n    return '' + this.hours() + zeroFill(this.minutes(), 2);\n});\n\naddFormatToken('Hmmss', 0, 0, function () {\n    return '' + this.hours() + zeroFill(this.minutes(), 2) +\n        zeroFill(this.seconds(), 2);\n});\n\nfunction meridiem (token, lowercase) {\n    addFormatToken(token, 0, 0, function () {\n        return this.localeData().meridiem(this.hours(), this.minutes(), lowercase);\n    });\n}\n\nmeridiem('a', true);\nmeridiem('A', false);\n\n// ALIASES\n\naddUnitAlias('hour', 'h');\n\n// PRIORITY\naddUnitPriority('hour', 13);\n\n// PARSING\n\nfunction matchMeridiem (isStrict, locale) {\n    return locale._meridiemParse;\n}\n\naddRegexToken('a',  matchMeridiem);\naddRegexToken('A',  matchMeridiem);\naddRegexToken('H',  match1to2);\naddRegexToken('h',  match1to2);\naddRegexToken('k',  match1to2);\naddRegexToken('HH', match1to2, match2);\naddRegexToken('hh', match1to2, match2);\naddRegexToken('kk', match1to2, match2);\n\naddRegexToken('hmm', match3to4);\naddRegexToken('hmmss', match5to6);\naddRegexToken('Hmm', match3to4);\naddRegexToken('Hmmss', match5to6);\n\naddParseToken(['H', 'HH'], HOUR);\naddParseToken(['k', 'kk'], function (input, array, config) {\n    var kInput = toInt(input);\n    array[HOUR] = kInput === 24 ? 0 : kInput;\n});\naddParseToken(['a', 'A'], function (input, array, config) {\n    config._isPm = config._locale.isPM(input);\n    config._meridiem = input;\n});\naddParseToken(['h', 'hh'], function (input, array, config) {\n    array[HOUR] = toInt(input);\n    getParsingFlags(config).bigHour = true;\n});\naddParseToken('hmm', function (input, array, config) {\n    var pos = input.length - 2;\n    array[HOUR] = toInt(input.substr(0, pos));\n    array[MINUTE] = toInt(input.substr(pos));\n    getParsingFlags(config).bigHour = true;\n});\naddParseToken('hmmss', function (input, array, config) {\n    var pos1 = input.length - 4;\n    var pos2 = input.length - 2;\n    array[HOUR] = toInt(input.substr(0, pos1));\n    array[MINUTE] = toInt(input.substr(pos1, 2));\n    array[SECOND] = toInt(input.substr(pos2));\n    getParsingFlags(config).bigHour = true;\n});\naddParseToken('Hmm', function (input, array, config) {\n    var pos = input.length - 2;\n    array[HOUR] = toInt(input.substr(0, pos));\n    array[MINUTE] = toInt(input.substr(pos));\n});\naddParseToken('Hmmss', function (input, array, config) {\n    var pos1 = input.length - 4;\n    var pos2 = input.length - 2;\n    array[HOUR] = toInt(input.substr(0, pos1));\n    array[MINUTE] = toInt(input.substr(pos1, 2));\n    array[SECOND] = toInt(input.substr(pos2));\n});\n\n// LOCALES\n\nfunction localeIsPM (input) {\n    // IE8 Quirks Mode & IE7 Standards Mode do not allow accessing strings like arrays\n    // Using charAt should be more compatible.\n    return ((input + '').toLowerCase().charAt(0) === 'p');\n}\n\nvar defaultLocaleMeridiemParse = /[ap]\\.?m?\\.?/i;\nfunction localeMeridiem (hours, minutes, isLower) {\n    if (hours > 11) {\n        return isLower ? 'pm' : 'PM';\n    } else {\n        return isLower ? 'am' : 'AM';\n    }\n}\n\n\n// MOMENTS\n\n// Setting the hour should keep the time, because the user explicitly\n// specified which hour he wants. So trying to maintain the same hour (in\n// a new timezone) makes sense. Adding/subtracting hours does not follow\n// this rule.\nvar getSetHour = makeGetSet('Hours', true);\n\n// months\n// week\n// weekdays\n// meridiem\nvar baseConfig = {\n    calendar: defaultCalendar,\n    longDateFormat: defaultLongDateFormat,\n    invalidDate: defaultInvalidDate,\n    ordinal: defaultOrdinal,\n    dayOfMonthOrdinalParse: defaultDayOfMonthOrdinalParse,\n    relativeTime: defaultRelativeTime,\n\n    months: defaultLocaleMonths,\n    monthsShort: defaultLocaleMonthsShort,\n\n    week: defaultLocaleWeek,\n\n    weekdays: defaultLocaleWeekdays,\n    weekdaysMin: defaultLocaleWeekdaysMin,\n    weekdaysShort: defaultLocaleWeekdaysShort,\n\n    meridiemParse: defaultLocaleMeridiemParse\n};\n\n// internal storage for locale config files\nvar locales = {};\nvar localeFamilies = {};\nvar globalLocale;\n\nfunction normalizeLocale(key) {\n    return key ? key.toLowerCase().replace('_', '-') : key;\n}\n\n// pick the locale from the array\n// try ['en-au', 'en-gb'] as 'en-au', 'en-gb', 'en', as in move through the list trying each\n// substring from most specific to least, but move to the next array item if it's a more specific variant than the current root\nfunction chooseLocale(names) {\n    var i = 0, j, next, locale, split;\n\n    while (i < names.length) {\n        split = normalizeLocale(names[i]).split('-');\n        j = split.length;\n        next = normalizeLocale(names[i + 1]);\n        next = next ? next.split('-') : null;\n        while (j > 0) {\n            locale = loadLocale(split.slice(0, j).join('-'));\n            if (locale) {\n                return locale;\n            }\n            if (next && next.length >= j && compareArrays(split, next, true) >= j - 1) {\n                //the next array item is better than a shallower substring of this one\n                break;\n            }\n            j--;\n        }\n        i++;\n    }\n    return null;\n}\n\nfunction loadLocale(name) {\n    var oldLocale = null;\n    // TODO: Find a better way to register and load all the locales in Node\n    if (!locales[name] && (typeof module !== 'undefined') &&\n            module && module.exports) {\n        try {\n            oldLocale = globalLocale._abbr;\n            !(function webpackMissingModule() { var e = new Error(\"Cannot find module \\\"./locale\\\"\"); e.code = 'MODULE_NOT_FOUND'; throw e; }());\n            // because defineLocale currently also sets the global locale, we\n            // want to undo that for lazy loaded locales\n            getSetGlobalLocale(oldLocale);\n        } catch (e) { }\n    }\n    return locales[name];\n}\n\n// This function will load locale and then set the global locale.  If\n// no arguments are passed in, it will simply return the current global\n// locale key.\nfunction getSetGlobalLocale (key, values) {\n    var data;\n    if (key) {\n        if (isUndefined(values)) {\n            data = getLocale(key);\n        }\n        else {\n            data = defineLocale(key, values);\n        }\n\n        if (data) {\n            // moment.duration._locale = moment._locale = data;\n            globalLocale = data;\n        }\n    }\n\n    return globalLocale._abbr;\n}\n\nfunction defineLocale (name, config) {\n    if (config !== null) {\n        var parentConfig = baseConfig;\n        config.abbr = name;\n        if (locales[name] != null) {\n            deprecateSimple('defineLocaleOverride',\n                    'use moment.updateLocale(localeName, config) to change ' +\n                    'an existing locale. moment.defineLocale(localeName, ' +\n                    'config) should only be used for creating a new locale ' +\n                    'See http://momentjs.com/guides/#/warnings/define-locale/ for more info.');\n            parentConfig = locales[name]._config;\n        } else if (config.parentLocale != null) {\n            if (locales[config.parentLocale] != null) {\n                parentConfig = locales[config.parentLocale]._config;\n            } else {\n                if (!localeFamilies[config.parentLocale]) {\n                    localeFamilies[config.parentLocale] = [];\n                }\n                localeFamilies[config.parentLocale].push({\n                    name: name,\n                    config: config\n                });\n                return null;\n            }\n        }\n        locales[name] = new Locale(mergeConfigs(parentConfig, config));\n\n        if (localeFamilies[name]) {\n            localeFamilies[name].forEach(function (x) {\n                defineLocale(x.name, x.config);\n            });\n        }\n\n        // backwards compat for now: also set the locale\n        // make sure we set the locale AFTER all child locales have been\n        // created, so we won't end up with the child locale set.\n        getSetGlobalLocale(name);\n\n\n        return locales[name];\n    } else {\n        // useful for testing\n        delete locales[name];\n        return null;\n    }\n}\n\nfunction updateLocale(name, config) {\n    if (config != null) {\n        var locale, parentConfig = baseConfig;\n        // MERGE\n        if (locales[name] != null) {\n            parentConfig = locales[name]._config;\n        }\n        config = mergeConfigs(parentConfig, config);\n        locale = new Locale(config);\n        locale.parentLocale = locales[name];\n        locales[name] = locale;\n\n        // backwards compat for now: also set the locale\n        getSetGlobalLocale(name);\n    } else {\n        // pass null for config to unupdate, useful for tests\n        if (locales[name] != null) {\n            if (locales[name].parentLocale != null) {\n                locales[name] = locales[name].parentLocale;\n            } else if (locales[name] != null) {\n                delete locales[name];\n            }\n        }\n    }\n    return locales[name];\n}\n\n// returns locale data\nfunction getLocale (key) {\n    var locale;\n\n    if (key && key._locale && key._locale._abbr) {\n        key = key._locale._abbr;\n    }\n\n    if (!key) {\n        return globalLocale;\n    }\n\n    if (!isArray(key)) {\n        //short-circuit everything else\n        locale = loadLocale(key);\n        if (locale) {\n            return locale;\n        }\n        key = [key];\n    }\n\n    return chooseLocale(key);\n}\n\nfunction listLocales() {\n    return keys$1(locales);\n}\n\nfunction checkOverflow (m) {\n    var overflow;\n    var a = m._a;\n\n    if (a && getParsingFlags(m).overflow === -2) {\n        overflow =\n            a[MONTH]       < 0 || a[MONTH]       > 11  ? MONTH :\n            a[DATE]        < 1 || a[DATE]        > daysInMonth(a[YEAR], a[MONTH]) ? DATE :\n            a[HOUR]        < 0 || a[HOUR]        > 24 || (a[HOUR] === 24 && (a[MINUTE] !== 0 || a[SECOND] !== 0 || a[MILLISECOND] !== 0)) ? HOUR :\n            a[MINUTE]      < 0 || a[MINUTE]      > 59  ? MINUTE :\n            a[SECOND]      < 0 || a[SECOND]      > 59  ? SECOND :\n            a[MILLISECOND] < 0 || a[MILLISECOND] > 999 ? MILLISECOND :\n            -1;\n\n        if (getParsingFlags(m)._overflowDayOfYear && (overflow < YEAR || overflow > DATE)) {\n            overflow = DATE;\n        }\n        if (getParsingFlags(m)._overflowWeeks && overflow === -1) {\n            overflow = WEEK;\n        }\n        if (getParsingFlags(m)._overflowWeekday && overflow === -1) {\n            overflow = WEEKDAY;\n        }\n\n        getParsingFlags(m).overflow = overflow;\n    }\n\n    return m;\n}\n\n// iso 8601 regex\n// 0000-00-00 0000-W00 or 0000-W00-0 + T + 00 or 00:00 or 00:00:00 or 00:00:00.000 + +00:00 or +0000 or +00)\nvar extendedIsoRegex = /^\\s*((?:[+-]\\d{6}|\\d{4})-(?:\\d\\d-\\d\\d|W\\d\\d-\\d|W\\d\\d|\\d\\d\\d|\\d\\d))(?:(T| )(\\d\\d(?::\\d\\d(?::\\d\\d(?:[.,]\\d+)?)?)?)([\\+\\-]\\d\\d(?::?\\d\\d)?|\\s*Z)?)?$/;\nvar basicIsoRegex = /^\\s*((?:[+-]\\d{6}|\\d{4})(?:\\d\\d\\d\\d|W\\d\\d\\d|W\\d\\d|\\d\\d\\d|\\d\\d))(?:(T| )(\\d\\d(?:\\d\\d(?:\\d\\d(?:[.,]\\d+)?)?)?)([\\+\\-]\\d\\d(?::?\\d\\d)?|\\s*Z)?)?$/;\n\nvar tzRegex = /Z|[+-]\\d\\d(?::?\\d\\d)?/;\n\nvar isoDates = [\n    ['YYYYYY-MM-DD', /[+-]\\d{6}-\\d\\d-\\d\\d/],\n    ['YYYY-MM-DD', /\\d{4}-\\d\\d-\\d\\d/],\n    ['GGGG-[W]WW-E', /\\d{4}-W\\d\\d-\\d/],\n    ['GGGG-[W]WW', /\\d{4}-W\\d\\d/, false],\n    ['YYYY-DDD', /\\d{4}-\\d{3}/],\n    ['YYYY-MM', /\\d{4}-\\d\\d/, false],\n    ['YYYYYYMMDD', /[+-]\\d{10}/],\n    ['YYYYMMDD', /\\d{8}/],\n    // YYYYMM is NOT allowed by the standard\n    ['GGGG[W]WWE', /\\d{4}W\\d{3}/],\n    ['GGGG[W]WW', /\\d{4}W\\d{2}/, false],\n    ['YYYYDDD', /\\d{7}/]\n];\n\n// iso time formats and regexes\nvar isoTimes = [\n    ['HH:mm:ss.SSSS', /\\d\\d:\\d\\d:\\d\\d\\.\\d+/],\n    ['HH:mm:ss,SSSS', /\\d\\d:\\d\\d:\\d\\d,\\d+/],\n    ['HH:mm:ss', /\\d\\d:\\d\\d:\\d\\d/],\n    ['HH:mm', /\\d\\d:\\d\\d/],\n    ['HHmmss.SSSS', /\\d\\d\\d\\d\\d\\d\\.\\d+/],\n    ['HHmmss,SSSS', /\\d\\d\\d\\d\\d\\d,\\d+/],\n    ['HHmmss', /\\d\\d\\d\\d\\d\\d/],\n    ['HHmm', /\\d\\d\\d\\d/],\n    ['HH', /\\d\\d/]\n];\n\nvar aspNetJsonRegex = /^\\/?Date\\((\\-?\\d+)/i;\n\n// date from iso format\nfunction configFromISO(config) {\n    var i, l,\n        string = config._i,\n        match = extendedIsoRegex.exec(string) || basicIsoRegex.exec(string),\n        allowTime, dateFormat, timeFormat, tzFormat;\n\n    if (match) {\n        getParsingFlags(config).iso = true;\n\n        for (i = 0, l = isoDates.length; i < l; i++) {\n            if (isoDates[i][1].exec(match[1])) {\n                dateFormat = isoDates[i][0];\n                allowTime = isoDates[i][2] !== false;\n                break;\n            }\n        }\n        if (dateFormat == null) {\n            config._isValid = false;\n            return;\n        }\n        if (match[3]) {\n            for (i = 0, l = isoTimes.length; i < l; i++) {\n                if (isoTimes[i][1].exec(match[3])) {\n                    // match[2] should be 'T' or space\n                    timeFormat = (match[2] || ' ') + isoTimes[i][0];\n                    break;\n                }\n            }\n            if (timeFormat == null) {\n                config._isValid = false;\n                return;\n            }\n        }\n        if (!allowTime && timeFormat != null) {\n            config._isValid = false;\n            return;\n        }\n        if (match[4]) {\n            if (tzRegex.exec(match[4])) {\n                tzFormat = 'Z';\n            } else {\n                config._isValid = false;\n                return;\n            }\n        }\n        config._f = dateFormat + (timeFormat || '') + (tzFormat || '');\n        configFromStringAndFormat(config);\n    } else {\n        config._isValid = false;\n    }\n}\n\n// RFC 2822 regex: For details see https://tools.ietf.org/html/rfc2822#section-3.3\nvar basicRfcRegex = /^((?:Mon|Tue|Wed|Thu|Fri|Sat|Sun),?\\s)?(\\d?\\d\\s(?:Jan|Feb|Mar|Apr|May|Jun|Jul|Aug|Sep|Oct|Nov|Dec)\\s(?:\\d\\d)?\\d\\d\\s)(\\d\\d:\\d\\d)(\\:\\d\\d)?(\\s(?:UT|GMT|[ECMP][SD]T|[A-IK-Za-ik-z]|[+-]\\d{4}))$/;\n\n// date and time from ref 2822 format\nfunction configFromRFC2822(config) {\n    var string, match, dayFormat,\n        dateFormat, timeFormat, tzFormat;\n    var timezones = {\n        ' GMT': ' +0000',\n        ' EDT': ' -0400',\n        ' EST': ' -0500',\n        ' CDT': ' -0500',\n        ' CST': ' -0600',\n        ' MDT': ' -0600',\n        ' MST': ' -0700',\n        ' PDT': ' -0700',\n        ' PST': ' -0800'\n    };\n    var military = 'YXWVUTSRQPONZABCDEFGHIKLM';\n    var timezone, timezoneIndex;\n\n    string = config._i\n        .replace(/\\([^\\)]*\\)|[\\n\\t]/g, ' ') // Remove comments and folding whitespace\n        .replace(/(\\s\\s+)/g, ' ') // Replace multiple-spaces with a single space\n        .replace(/^\\s|\\s$/g, ''); // Remove leading and trailing spaces\n    match = basicRfcRegex.exec(string);\n\n    if (match) {\n        dayFormat = match[1] ? 'ddd' + ((match[1].length === 5) ? ', ' : ' ') : '';\n        dateFormat = 'D MMM ' + ((match[2].length > 10) ? 'YYYY ' : 'YY ');\n        timeFormat = 'HH:mm' + (match[4] ? ':ss' : '');\n\n        // TODO: Replace the vanilla JS Date object with an indepentent day-of-week check.\n        if (match[1]) { // day of week given\n            var momentDate = new Date(match[2]);\n            var momentDay = ['Sun','Mon','Tue','Wed','Thu','Fri','Sat'][momentDate.getDay()];\n\n            if (match[1].substr(0,3) !== momentDay) {\n                getParsingFlags(config).weekdayMismatch = true;\n                config._isValid = false;\n                return;\n            }\n        }\n\n        switch (match[5].length) {\n            case 2: // military\n                if (timezoneIndex === 0) {\n                    timezone = ' +0000';\n                } else {\n                    timezoneIndex = military.indexOf(match[5][1].toUpperCase()) - 12;\n                    timezone = ((timezoneIndex < 0) ? ' -' : ' +') +\n                        (('' + timezoneIndex).replace(/^-?/, '0')).match(/..$/)[0] + '00';\n                }\n                break;\n            case 4: // Zone\n                timezone = timezones[match[5]];\n                break;\n            default: // UT or +/-9999\n                timezone = timezones[' GMT'];\n        }\n        match[5] = timezone;\n        config._i = match.splice(1).join('');\n        tzFormat = ' ZZ';\n        config._f = dayFormat + dateFormat + timeFormat + tzFormat;\n        configFromStringAndFormat(config);\n        getParsingFlags(config).rfc2822 = true;\n    } else {\n        config._isValid = false;\n    }\n}\n\n// date from iso format or fallback\nfunction configFromString(config) {\n    var matched = aspNetJsonRegex.exec(config._i);\n\n    if (matched !== null) {\n        config._d = new Date(+matched[1]);\n        return;\n    }\n\n    configFromISO(config);\n    if (config._isValid === false) {\n        delete config._isValid;\n    } else {\n        return;\n    }\n\n    configFromRFC2822(config);\n    if (config._isValid === false) {\n        delete config._isValid;\n    } else {\n        return;\n    }\n\n    // Final attempt, use Input Fallback\n    hooks.createFromInputFallback(config);\n}\n\nhooks.createFromInputFallback = deprecate(\n    'value provided is not in a recognized RFC2822 or ISO format. moment construction falls back to js Date(), ' +\n    'which is not reliable across all browsers and versions. Non RFC2822/ISO date formats are ' +\n    'discouraged and will be removed in an upcoming major release. Please refer to ' +\n    'http://momentjs.com/guides/#/warnings/js-date/ for more info.',\n    function (config) {\n        config._d = new Date(config._i + (config._useUTC ? ' UTC' : ''));\n    }\n);\n\n// Pick the first defined of two or three arguments.\nfunction defaults(a, b, c) {\n    if (a != null) {\n        return a;\n    }\n    if (b != null) {\n        return b;\n    }\n    return c;\n}\n\nfunction currentDateArray(config) {\n    // hooks is actually the exported moment object\n    var nowValue = new Date(hooks.now());\n    if (config._useUTC) {\n        return [nowValue.getUTCFullYear(), nowValue.getUTCMonth(), nowValue.getUTCDate()];\n    }\n    return [nowValue.getFullYear(), nowValue.getMonth(), nowValue.getDate()];\n}\n\n// convert an array to a date.\n// the array should mirror the parameters below\n// note: all values past the year are optional and will default to the lowest possible value.\n// [year, month, day , hour, minute, second, millisecond]\nfunction configFromArray (config) {\n    var i, date, input = [], currentDate, yearToUse;\n\n    if (config._d) {\n        return;\n    }\n\n    currentDate = currentDateArray(config);\n\n    //compute day of the year from weeks and weekdays\n    if (config._w && config._a[DATE] == null && config._a[MONTH] == null) {\n        dayOfYearFromWeekInfo(config);\n    }\n\n    //if the day of the year is set, figure out what it is\n    if (config._dayOfYear != null) {\n        yearToUse = defaults(config._a[YEAR], currentDate[YEAR]);\n\n        if (config._dayOfYear > daysInYear(yearToUse) || config._dayOfYear === 0) {\n            getParsingFlags(config)._overflowDayOfYear = true;\n        }\n\n        date = createUTCDate(yearToUse, 0, config._dayOfYear);\n        config._a[MONTH] = date.getUTCMonth();\n        config._a[DATE] = date.getUTCDate();\n    }\n\n    // Default to current date.\n    // * if no year, month, day of month are given, default to today\n    // * if day of month is given, default month and year\n    // * if month is given, default only year\n    // * if year is given, don't default anything\n    for (i = 0; i < 3 && config._a[i] == null; ++i) {\n        config._a[i] = input[i] = currentDate[i];\n    }\n\n    // Zero out whatever was not defaulted, including time\n    for (; i < 7; i++) {\n        config._a[i] = input[i] = (config._a[i] == null) ? (i === 2 ? 1 : 0) : config._a[i];\n    }\n\n    // Check for 24:00:00.000\n    if (config._a[HOUR] === 24 &&\n            config._a[MINUTE] === 0 &&\n            config._a[SECOND] === 0 &&\n            config._a[MILLISECOND] === 0) {\n        config._nextDay = true;\n        config._a[HOUR] = 0;\n    }\n\n    config._d = (config._useUTC ? createUTCDate : createDate).apply(null, input);\n    // Apply timezone offset from input. The actual utcOffset can be changed\n    // with parseZone.\n    if (config._tzm != null) {\n        config._d.setUTCMinutes(config._d.getUTCMinutes() - config._tzm);\n    }\n\n    if (config._nextDay) {\n        config._a[HOUR] = 24;\n    }\n}\n\nfunction dayOfYearFromWeekInfo(config) {\n    var w, weekYear, week, weekday, dow, doy, temp, weekdayOverflow;\n\n    w = config._w;\n    if (w.GG != null || w.W != null || w.E != null) {\n        dow = 1;\n        doy = 4;\n\n        // TODO: We need to take the current isoWeekYear, but that depends on\n        // how we interpret now (local, utc, fixed offset). So create\n        // a now version of current config (take local/utc/offset flags, and\n        // create now).\n        weekYear = defaults(w.GG, config._a[YEAR], weekOfYear(createLocal(), 1, 4).year);\n        week = defaults(w.W, 1);\n        weekday = defaults(w.E, 1);\n        if (weekday < 1 || weekday > 7) {\n            weekdayOverflow = true;\n        }\n    } else {\n        dow = config._locale._week.dow;\n        doy = config._locale._week.doy;\n\n        var curWeek = weekOfYear(createLocal(), dow, doy);\n\n        weekYear = defaults(w.gg, config._a[YEAR], curWeek.year);\n\n        // Default to current week.\n        week = defaults(w.w, curWeek.week);\n\n        if (w.d != null) {\n            // weekday -- low day numbers are considered next week\n            weekday = w.d;\n            if (weekday < 0 || weekday > 6) {\n                weekdayOverflow = true;\n            }\n        } else if (w.e != null) {\n            // local weekday -- counting starts from begining of week\n            weekday = w.e + dow;\n            if (w.e < 0 || w.e > 6) {\n                weekdayOverflow = true;\n            }\n        } else {\n            // default to begining of week\n            weekday = dow;\n        }\n    }\n    if (week < 1 || week > weeksInYear(weekYear, dow, doy)) {\n        getParsingFlags(config)._overflowWeeks = true;\n    } else if (weekdayOverflow != null) {\n        getParsingFlags(config)._overflowWeekday = true;\n    } else {\n        temp = dayOfYearFromWeeks(weekYear, week, weekday, dow, doy);\n        config._a[YEAR] = temp.year;\n        config._dayOfYear = temp.dayOfYear;\n    }\n}\n\n// constant that refers to the ISO standard\nhooks.ISO_8601 = function () {};\n\n// constant that refers to the RFC 2822 form\nhooks.RFC_2822 = function () {};\n\n// date from string and format string\nfunction configFromStringAndFormat(config) {\n    // TODO: Move this to another part of the creation flow to prevent circular deps\n    if (config._f === hooks.ISO_8601) {\n        configFromISO(config);\n        return;\n    }\n    if (config._f === hooks.RFC_2822) {\n        configFromRFC2822(config);\n        return;\n    }\n    config._a = [];\n    getParsingFlags(config).empty = true;\n\n    // This array is used to make a Date, either with `new Date` or `Date.UTC`\n    var string = '' + config._i,\n        i, parsedInput, tokens, token, skipped,\n        stringLength = string.length,\n        totalParsedInputLength = 0;\n\n    tokens = expandFormat(config._f, config._locale).match(formattingTokens) || [];\n\n    for (i = 0; i < tokens.length; i++) {\n        token = tokens[i];\n        parsedInput = (string.match(getParseRegexForToken(token, config)) || [])[0];\n        // console.log('token', token, 'parsedInput', parsedInput,\n        //         'regex', getParseRegexForToken(token, config));\n        if (parsedInput) {\n            skipped = string.substr(0, string.indexOf(parsedInput));\n            if (skipped.length > 0) {\n                getParsingFlags(config).unusedInput.push(skipped);\n            }\n            string = string.slice(string.indexOf(parsedInput) + parsedInput.length);\n            totalParsedInputLength += parsedInput.length;\n        }\n        // don't parse if it's not a known token\n        if (formatTokenFunctions[token]) {\n            if (parsedInput) {\n                getParsingFlags(config).empty = false;\n            }\n            else {\n                getParsingFlags(config).unusedTokens.push(token);\n            }\n            addTimeToArrayFromToken(token, parsedInput, config);\n        }\n        else if (config._strict && !parsedInput) {\n            getParsingFlags(config).unusedTokens.push(token);\n        }\n    }\n\n    // add remaining unparsed input length to the string\n    getParsingFlags(config).charsLeftOver = stringLength - totalParsedInputLength;\n    if (string.length > 0) {\n        getParsingFlags(config).unusedInput.push(string);\n    }\n\n    // clear _12h flag if hour is <= 12\n    if (config._a[HOUR] <= 12 &&\n        getParsingFlags(config).bigHour === true &&\n        config._a[HOUR] > 0) {\n        getParsingFlags(config).bigHour = undefined;\n    }\n\n    getParsingFlags(config).parsedDateParts = config._a.slice(0);\n    getParsingFlags(config).meridiem = config._meridiem;\n    // handle meridiem\n    config._a[HOUR] = meridiemFixWrap(config._locale, config._a[HOUR], config._meridiem);\n\n    configFromArray(config);\n    checkOverflow(config);\n}\n\n\nfunction meridiemFixWrap (locale, hour, meridiem) {\n    var isPm;\n\n    if (meridiem == null) {\n        // nothing to do\n        return hour;\n    }\n    if (locale.meridiemHour != null) {\n        return locale.meridiemHour(hour, meridiem);\n    } else if (locale.isPM != null) {\n        // Fallback\n        isPm = locale.isPM(meridiem);\n        if (isPm && hour < 12) {\n            hour += 12;\n        }\n        if (!isPm && hour === 12) {\n            hour = 0;\n        }\n        return hour;\n    } else {\n        // this is not supposed to happen\n        return hour;\n    }\n}\n\n// date from string and array of format strings\nfunction configFromStringAndArray(config) {\n    var tempConfig,\n        bestMoment,\n\n        scoreToBeat,\n        i,\n        currentScore;\n\n    if (config._f.length === 0) {\n        getParsingFlags(config).invalidFormat = true;\n        config._d = new Date(NaN);\n        return;\n    }\n\n    for (i = 0; i < config._f.length; i++) {\n        currentScore = 0;\n        tempConfig = copyConfig({}, config);\n        if (config._useUTC != null) {\n            tempConfig._useUTC = config._useUTC;\n        }\n        tempConfig._f = config._f[i];\n        configFromStringAndFormat(tempConfig);\n\n        if (!isValid(tempConfig)) {\n            continue;\n        }\n\n        // if there is any input that was not parsed add a penalty for that format\n        currentScore += getParsingFlags(tempConfig).charsLeftOver;\n\n        //or tokens\n        currentScore += getParsingFlags(tempConfig).unusedTokens.length * 10;\n\n        getParsingFlags(tempConfig).score = currentScore;\n\n        if (scoreToBeat == null || currentScore < scoreToBeat) {\n            scoreToBeat = currentScore;\n            bestMoment = tempConfig;\n        }\n    }\n\n    extend(config, bestMoment || tempConfig);\n}\n\nfunction configFromObject(config) {\n    if (config._d) {\n        return;\n    }\n\n    var i = normalizeObjectUnits(config._i);\n    config._a = map([i.year, i.month, i.day || i.date, i.hour, i.minute, i.second, i.millisecond], function (obj) {\n        return obj && parseInt(obj, 10);\n    });\n\n    configFromArray(config);\n}\n\nfunction createFromConfig (config) {\n    var res = new Moment(checkOverflow(prepareConfig(config)));\n    if (res._nextDay) {\n        // Adding is smart enough around DST\n        res.add(1, 'd');\n        res._nextDay = undefined;\n    }\n\n    return res;\n}\n\nfunction prepareConfig (config) {\n    var input = config._i,\n        format = config._f;\n\n    config._locale = config._locale || getLocale(config._l);\n\n    if (input === null || (format === undefined && input === '')) {\n        return createInvalid({nullInput: true});\n    }\n\n    if (typeof input === 'string') {\n        config._i = input = config._locale.preparse(input);\n    }\n\n    if (isMoment(input)) {\n        return new Moment(checkOverflow(input));\n    } else if (isDate(input)) {\n        config._d = input;\n    } else if (isArray(format)) {\n        configFromStringAndArray(config);\n    } else if (format) {\n        configFromStringAndFormat(config);\n    }  else {\n        configFromInput(config);\n    }\n\n    if (!isValid(config)) {\n        config._d = null;\n    }\n\n    return config;\n}\n\nfunction configFromInput(config) {\n    var input = config._i;\n    if (isUndefined(input)) {\n        config._d = new Date(hooks.now());\n    } else if (isDate(input)) {\n        config._d = new Date(input.valueOf());\n    } else if (typeof input === 'string') {\n        configFromString(config);\n    } else if (isArray(input)) {\n        config._a = map(input.slice(0), function (obj) {\n            return parseInt(obj, 10);\n        });\n        configFromArray(config);\n    } else if (isObject(input)) {\n        configFromObject(config);\n    } else if (isNumber(input)) {\n        // from milliseconds\n        config._d = new Date(input);\n    } else {\n        hooks.createFromInputFallback(config);\n    }\n}\n\nfunction createLocalOrUTC (input, format, locale, strict, isUTC) {\n    var c = {};\n\n    if (locale === true || locale === false) {\n        strict = locale;\n        locale = undefined;\n    }\n\n    if ((isObject(input) && isObjectEmpty(input)) ||\n            (isArray(input) && input.length === 0)) {\n        input = undefined;\n    }\n    // object construction must be done this way.\n    // https://github.com/moment/moment/issues/1423\n    c._isAMomentObject = true;\n    c._useUTC = c._isUTC = isUTC;\n    c._l = locale;\n    c._i = input;\n    c._f = format;\n    c._strict = strict;\n\n    return createFromConfig(c);\n}\n\nfunction createLocal (input, format, locale, strict) {\n    return createLocalOrUTC(input, format, locale, strict, false);\n}\n\nvar prototypeMin = deprecate(\n    'moment().min is deprecated, use moment.max instead. http://momentjs.com/guides/#/warnings/min-max/',\n    function () {\n        var other = createLocal.apply(null, arguments);\n        if (this.isValid() && other.isValid()) {\n            return other < this ? this : other;\n        } else {\n            return createInvalid();\n        }\n    }\n);\n\nvar prototypeMax = deprecate(\n    'moment().max is deprecated, use moment.min instead. http://momentjs.com/guides/#/warnings/min-max/',\n    function () {\n        var other = createLocal.apply(null, arguments);\n        if (this.isValid() && other.isValid()) {\n            return other > this ? this : other;\n        } else {\n            return createInvalid();\n        }\n    }\n);\n\n// Pick a moment m from moments so that m[fn](other) is true for all\n// other. This relies on the function fn to be transitive.\n//\n// moments should either be an array of moment objects or an array, whose\n// first element is an array of moment objects.\nfunction pickBy(fn, moments) {\n    var res, i;\n    if (moments.length === 1 && isArray(moments[0])) {\n        moments = moments[0];\n    }\n    if (!moments.length) {\n        return createLocal();\n    }\n    res = moments[0];\n    for (i = 1; i < moments.length; ++i) {\n        if (!moments[i].isValid() || moments[i][fn](res)) {\n            res = moments[i];\n        }\n    }\n    return res;\n}\n\n// TODO: Use [].sort instead?\nfunction min () {\n    var args = [].slice.call(arguments, 0);\n\n    return pickBy('isBefore', args);\n}\n\nfunction max () {\n    var args = [].slice.call(arguments, 0);\n\n    return pickBy('isAfter', args);\n}\n\nvar now = function () {\n    return Date.now ? Date.now() : +(new Date());\n};\n\nvar ordering = ['year', 'quarter', 'month', 'week', 'day', 'hour', 'minute', 'second', 'millisecond'];\n\nfunction isDurationValid(m) {\n    for (var key in m) {\n        if (!(ordering.indexOf(key) !== -1 && (m[key] == null || !isNaN(m[key])))) {\n            return false;\n        }\n    }\n\n    var unitHasDecimal = false;\n    for (var i = 0; i < ordering.length; ++i) {\n        if (m[ordering[i]]) {\n            if (unitHasDecimal) {\n                return false; // only allow non-integers for smallest unit\n            }\n            if (parseFloat(m[ordering[i]]) !== toInt(m[ordering[i]])) {\n                unitHasDecimal = true;\n            }\n        }\n    }\n\n    return true;\n}\n\nfunction isValid$1() {\n    return this._isValid;\n}\n\nfunction createInvalid$1() {\n    return createDuration(NaN);\n}\n\nfunction Duration (duration) {\n    var normalizedInput = normalizeObjectUnits(duration),\n        years = normalizedInput.year || 0,\n        quarters = normalizedInput.quarter || 0,\n        months = normalizedInput.month || 0,\n        weeks = normalizedInput.week || 0,\n        days = normalizedInput.day || 0,\n        hours = normalizedInput.hour || 0,\n        minutes = normalizedInput.minute || 0,\n        seconds = normalizedInput.second || 0,\n        milliseconds = normalizedInput.millisecond || 0;\n\n    this._isValid = isDurationValid(normalizedInput);\n\n    // representation for dateAddRemove\n    this._milliseconds = +milliseconds +\n        seconds * 1e3 + // 1000\n        minutes * 6e4 + // 1000 * 60\n        hours * 1000 * 60 * 60; //using 1000 * 60 * 60 instead of 36e5 to avoid floating point rounding errors https://github.com/moment/moment/issues/2978\n    // Because of dateAddRemove treats 24 hours as different from a\n    // day when working around DST, we need to store them separately\n    this._days = +days +\n        weeks * 7;\n    // It is impossible translate months into days without knowing\n    // which months you are are talking about, so we have to store\n    // it separately.\n    this._months = +months +\n        quarters * 3 +\n        years * 12;\n\n    this._data = {};\n\n    this._locale = getLocale();\n\n    this._bubble();\n}\n\nfunction isDuration (obj) {\n    return obj instanceof Duration;\n}\n\nfunction absRound (number) {\n    if (number < 0) {\n        return Math.round(-1 * number) * -1;\n    } else {\n        return Math.round(number);\n    }\n}\n\n// FORMATTING\n\nfunction offset (token, separator) {\n    addFormatToken(token, 0, 0, function () {\n        var offset = this.utcOffset();\n        var sign = '+';\n        if (offset < 0) {\n            offset = -offset;\n            sign = '-';\n        }\n        return sign + zeroFill(~~(offset / 60), 2) + separator + zeroFill(~~(offset) % 60, 2);\n    });\n}\n\noffset('Z', ':');\noffset('ZZ', '');\n\n// PARSING\n\naddRegexToken('Z',  matchShortOffset);\naddRegexToken('ZZ', matchShortOffset);\naddParseToken(['Z', 'ZZ'], function (input, array, config) {\n    config._useUTC = true;\n    config._tzm = offsetFromString(matchShortOffset, input);\n});\n\n// HELPERS\n\n// timezone chunker\n// '+10:00' > ['10',  '00']\n// '-1530'  > ['-15', '30']\nvar chunkOffset = /([\\+\\-]|\\d\\d)/gi;\n\nfunction offsetFromString(matcher, string) {\n    var matches = (string || '').match(matcher);\n\n    if (matches === null) {\n        return null;\n    }\n\n    var chunk   = matches[matches.length - 1] || [];\n    var parts   = (chunk + '').match(chunkOffset) || ['-', 0, 0];\n    var minutes = +(parts[1] * 60) + toInt(parts[2]);\n\n    return minutes === 0 ?\n      0 :\n      parts[0] === '+' ? minutes : -minutes;\n}\n\n// Return a moment from input, that is local/utc/zone equivalent to model.\nfunction cloneWithOffset(input, model) {\n    var res, diff;\n    if (model._isUTC) {\n        res = model.clone();\n        diff = (isMoment(input) || isDate(input) ? input.valueOf() : createLocal(input).valueOf()) - res.valueOf();\n        // Use low-level api, because this fn is low-level api.\n        res._d.setTime(res._d.valueOf() + diff);\n        hooks.updateOffset(res, false);\n        return res;\n    } else {\n        return createLocal(input).local();\n    }\n}\n\nfunction getDateOffset (m) {\n    // On Firefox.24 Date#getTimezoneOffset returns a floating point.\n    // https://github.com/moment/moment/pull/1871\n    return -Math.round(m._d.getTimezoneOffset() / 15) * 15;\n}\n\n// HOOKS\n\n// This function will be called whenever a moment is mutated.\n// It is intended to keep the offset in sync with the timezone.\nhooks.updateOffset = function () {};\n\n// MOMENTS\n\n// keepLocalTime = true means only change the timezone, without\n// affecting the local hour. So 5:31:26 +0300 --[utcOffset(2, true)]-->\n// 5:31:26 +0200 It is possible that 5:31:26 doesn't exist with offset\n// +0200, so we adjust the time as needed, to be valid.\n//\n// Keeping the time actually adds/subtracts (one hour)\n// from the actual represented time. That is why we call updateOffset\n// a second time. In case it wants us to change the offset again\n// _changeInProgress == true case, then we have to adjust, because\n// there is no such time in the given timezone.\nfunction getSetOffset (input, keepLocalTime, keepMinutes) {\n    var offset = this._offset || 0,\n        localAdjust;\n    if (!this.isValid()) {\n        return input != null ? this : NaN;\n    }\n    if (input != null) {\n        if (typeof input === 'string') {\n            input = offsetFromString(matchShortOffset, input);\n            if (input === null) {\n                return this;\n            }\n        } else if (Math.abs(input) < 16 && !keepMinutes) {\n            input = input * 60;\n        }\n        if (!this._isUTC && keepLocalTime) {\n            localAdjust = getDateOffset(this);\n        }\n        this._offset = input;\n        this._isUTC = true;\n        if (localAdjust != null) {\n            this.add(localAdjust, 'm');\n        }\n        if (offset !== input) {\n            if (!keepLocalTime || this._changeInProgress) {\n                addSubtract(this, createDuration(input - offset, 'm'), 1, false);\n            } else if (!this._changeInProgress) {\n                this._changeInProgress = true;\n                hooks.updateOffset(this, true);\n                this._changeInProgress = null;\n            }\n        }\n        return this;\n    } else {\n        return this._isUTC ? offset : getDateOffset(this);\n    }\n}\n\nfunction getSetZone (input, keepLocalTime) {\n    if (input != null) {\n        if (typeof input !== 'string') {\n            input = -input;\n        }\n\n        this.utcOffset(input, keepLocalTime);\n\n        return this;\n    } else {\n        return -this.utcOffset();\n    }\n}\n\nfunction setOffsetToUTC (keepLocalTime) {\n    return this.utcOffset(0, keepLocalTime);\n}\n\nfunction setOffsetToLocal (keepLocalTime) {\n    if (this._isUTC) {\n        this.utcOffset(0, keepLocalTime);\n        this._isUTC = false;\n\n        if (keepLocalTime) {\n            this.subtract(getDateOffset(this), 'm');\n        }\n    }\n    return this;\n}\n\nfunction setOffsetToParsedOffset () {\n    if (this._tzm != null) {\n        this.utcOffset(this._tzm, false, true);\n    } else if (typeof this._i === 'string') {\n        var tZone = offsetFromString(matchOffset, this._i);\n        if (tZone != null) {\n            this.utcOffset(tZone);\n        }\n        else {\n            this.utcOffset(0, true);\n        }\n    }\n    return this;\n}\n\nfunction hasAlignedHourOffset (input) {\n    if (!this.isValid()) {\n        return false;\n    }\n    input = input ? createLocal(input).utcOffset() : 0;\n\n    return (this.utcOffset() - input) % 60 === 0;\n}\n\nfunction isDaylightSavingTime () {\n    return (\n        this.utcOffset() > this.clone().month(0).utcOffset() ||\n        this.utcOffset() > this.clone().month(5).utcOffset()\n    );\n}\n\nfunction isDaylightSavingTimeShifted () {\n    if (!isUndefined(this._isDSTShifted)) {\n        return this._isDSTShifted;\n    }\n\n    var c = {};\n\n    copyConfig(c, this);\n    c = prepareConfig(c);\n\n    if (c._a) {\n        var other = c._isUTC ? createUTC(c._a) : createLocal(c._a);\n        this._isDSTShifted = this.isValid() &&\n            compareArrays(c._a, other.toArray()) > 0;\n    } else {\n        this._isDSTShifted = false;\n    }\n\n    return this._isDSTShifted;\n}\n\nfunction isLocal () {\n    return this.isValid() ? !this._isUTC : false;\n}\n\nfunction isUtcOffset () {\n    return this.isValid() ? this._isUTC : false;\n}\n\nfunction isUtc () {\n    return this.isValid() ? this._isUTC && this._offset === 0 : false;\n}\n\n// ASP.NET json date format regex\nvar aspNetRegex = /^(\\-)?(?:(\\d*)[. ])?(\\d+)\\:(\\d+)(?:\\:(\\d+)(\\.\\d*)?)?$/;\n\n// from http://docs.closure-library.googlecode.com/git/closure_goog_date_date.js.source.html\n// somewhat more in line with 4.4.3.2 2004 spec, but allows decimal anywhere\n// and further modified to allow for strings containing both week and day\nvar isoRegex = /^(-)?P(?:(-?[0-9,.]*)Y)?(?:(-?[0-9,.]*)M)?(?:(-?[0-9,.]*)W)?(?:(-?[0-9,.]*)D)?(?:T(?:(-?[0-9,.]*)H)?(?:(-?[0-9,.]*)M)?(?:(-?[0-9,.]*)S)?)?$/;\n\nfunction createDuration (input, key) {\n    var duration = input,\n        // matching against regexp is expensive, do it on demand\n        match = null,\n        sign,\n        ret,\n        diffRes;\n\n    if (isDuration(input)) {\n        duration = {\n            ms : input._milliseconds,\n            d  : input._days,\n            M  : input._months\n        };\n    } else if (isNumber(input)) {\n        duration = {};\n        if (key) {\n            duration[key] = input;\n        } else {\n            duration.milliseconds = input;\n        }\n    } else if (!!(match = aspNetRegex.exec(input))) {\n        sign = (match[1] === '-') ? -1 : 1;\n        duration = {\n            y  : 0,\n            d  : toInt(match[DATE])                         * sign,\n            h  : toInt(match[HOUR])                         * sign,\n            m  : toInt(match[MINUTE])                       * sign,\n            s  : toInt(match[SECOND])                       * sign,\n            ms : toInt(absRound(match[MILLISECOND] * 1000)) * sign // the millisecond decimal point is included in the match\n        };\n    } else if (!!(match = isoRegex.exec(input))) {\n        sign = (match[1] === '-') ? -1 : 1;\n        duration = {\n            y : parseIso(match[2], sign),\n            M : parseIso(match[3], sign),\n            w : parseIso(match[4], sign),\n            d : parseIso(match[5], sign),\n            h : parseIso(match[6], sign),\n            m : parseIso(match[7], sign),\n            s : parseIso(match[8], sign)\n        };\n    } else if (duration == null) {// checks for null or undefined\n        duration = {};\n    } else if (typeof duration === 'object' && ('from' in duration || 'to' in duration)) {\n        diffRes = momentsDifference(createLocal(duration.from), createLocal(duration.to));\n\n        duration = {};\n        duration.ms = diffRes.milliseconds;\n        duration.M = diffRes.months;\n    }\n\n    ret = new Duration(duration);\n\n    if (isDuration(input) && hasOwnProp(input, '_locale')) {\n        ret._locale = input._locale;\n    }\n\n    return ret;\n}\n\ncreateDuration.fn = Duration.prototype;\ncreateDuration.invalid = createInvalid$1;\n\nfunction parseIso (inp, sign) {\n    // We'd normally use ~~inp for this, but unfortunately it also\n    // converts floats to ints.\n    // inp may be undefined, so careful calling replace on it.\n    var res = inp && parseFloat(inp.replace(',', '.'));\n    // apply sign while we're at it\n    return (isNaN(res) ? 0 : res) * sign;\n}\n\nfunction positiveMomentsDifference(base, other) {\n    var res = {milliseconds: 0, months: 0};\n\n    res.months = other.month() - base.month() +\n        (other.year() - base.year()) * 12;\n    if (base.clone().add(res.months, 'M').isAfter(other)) {\n        --res.months;\n    }\n\n    res.milliseconds = +other - +(base.clone().add(res.months, 'M'));\n\n    return res;\n}\n\nfunction momentsDifference(base, other) {\n    var res;\n    if (!(base.isValid() && other.isValid())) {\n        return {milliseconds: 0, months: 0};\n    }\n\n    other = cloneWithOffset(other, base);\n    if (base.isBefore(other)) {\n        res = positiveMomentsDifference(base, other);\n    } else {\n        res = positiveMomentsDifference(other, base);\n        res.milliseconds = -res.milliseconds;\n        res.months = -res.months;\n    }\n\n    return res;\n}\n\n// TODO: remove 'name' arg after deprecation is removed\nfunction createAdder(direction, name) {\n    return function (val, period) {\n        var dur, tmp;\n        //invert the arguments, but complain about it\n        if (period !== null && !isNaN(+period)) {\n            deprecateSimple(name, 'moment().' + name  + '(period, number) is deprecated. Please use moment().' + name + '(number, period). ' +\n            'See http://momentjs.com/guides/#/warnings/add-inverted-param/ for more info.');\n            tmp = val; val = period; period = tmp;\n        }\n\n        val = typeof val === 'string' ? +val : val;\n        dur = createDuration(val, period);\n        addSubtract(this, dur, direction);\n        return this;\n    };\n}\n\nfunction addSubtract (mom, duration, isAdding, updateOffset) {\n    var milliseconds = duration._milliseconds,\n        days = absRound(duration._days),\n        months = absRound(duration._months);\n\n    if (!mom.isValid()) {\n        // No op\n        return;\n    }\n\n    updateOffset = updateOffset == null ? true : updateOffset;\n\n    if (milliseconds) {\n        mom._d.setTime(mom._d.valueOf() + milliseconds * isAdding);\n    }\n    if (days) {\n        set$1(mom, 'Date', get(mom, 'Date') + days * isAdding);\n    }\n    if (months) {\n        setMonth(mom, get(mom, 'Month') + months * isAdding);\n    }\n    if (updateOffset) {\n        hooks.updateOffset(mom, days || months);\n    }\n}\n\nvar add      = createAdder(1, 'add');\nvar subtract = createAdder(-1, 'subtract');\n\nfunction getCalendarFormat(myMoment, now) {\n    var diff = myMoment.diff(now, 'days', true);\n    return diff < -6 ? 'sameElse' :\n            diff < -1 ? 'lastWeek' :\n            diff < 0 ? 'lastDay' :\n            diff < 1 ? 'sameDay' :\n            diff < 2 ? 'nextDay' :\n            diff < 7 ? 'nextWeek' : 'sameElse';\n}\n\nfunction calendar$1 (time, formats) {\n    // We want to compare the start of today, vs this.\n    // Getting start-of-today depends on whether we're local/utc/offset or not.\n    var now = time || createLocal(),\n        sod = cloneWithOffset(now, this).startOf('day'),\n        format = hooks.calendarFormat(this, sod) || 'sameElse';\n\n    var output = formats && (isFunction(formats[format]) ? formats[format].call(this, now) : formats[format]);\n\n    return this.format(output || this.localeData().calendar(format, this, createLocal(now)));\n}\n\nfunction clone () {\n    return new Moment(this);\n}\n\nfunction isAfter (input, units) {\n    var localInput = isMoment(input) ? input : createLocal(input);\n    if (!(this.isValid() && localInput.isValid())) {\n        return false;\n    }\n    units = normalizeUnits(!isUndefined(units) ? units : 'millisecond');\n    if (units === 'millisecond') {\n        return this.valueOf() > localInput.valueOf();\n    } else {\n        return localInput.valueOf() < this.clone().startOf(units).valueOf();\n    }\n}\n\nfunction isBefore (input, units) {\n    var localInput = isMoment(input) ? input : createLocal(input);\n    if (!(this.isValid() && localInput.isValid())) {\n        return false;\n    }\n    units = normalizeUnits(!isUndefined(units) ? units : 'millisecond');\n    if (units === 'millisecond') {\n        return this.valueOf() < localInput.valueOf();\n    } else {\n        return this.clone().endOf(units).valueOf() < localInput.valueOf();\n    }\n}\n\nfunction isBetween (from, to, units, inclusivity) {\n    inclusivity = inclusivity || '()';\n    return (inclusivity[0] === '(' ? this.isAfter(from, units) : !this.isBefore(from, units)) &&\n        (inclusivity[1] === ')' ? this.isBefore(to, units) : !this.isAfter(to, units));\n}\n\nfunction isSame (input, units) {\n    var localInput = isMoment(input) ? input : createLocal(input),\n        inputMs;\n    if (!(this.isValid() && localInput.isValid())) {\n        return false;\n    }\n    units = normalizeUnits(units || 'millisecond');\n    if (units === 'millisecond') {\n        return this.valueOf() === localInput.valueOf();\n    } else {\n        inputMs = localInput.valueOf();\n        return this.clone().startOf(units).valueOf() <= inputMs && inputMs <= this.clone().endOf(units).valueOf();\n    }\n}\n\nfunction isSameOrAfter (input, units) {\n    return this.isSame(input, units) || this.isAfter(input,units);\n}\n\nfunction isSameOrBefore (input, units) {\n    return this.isSame(input, units) || this.isBefore(input,units);\n}\n\nfunction diff (input, units, asFloat) {\n    var that,\n        zoneDelta,\n        delta, output;\n\n    if (!this.isValid()) {\n        return NaN;\n    }\n\n    that = cloneWithOffset(input, this);\n\n    if (!that.isValid()) {\n        return NaN;\n    }\n\n    zoneDelta = (that.utcOffset() - this.utcOffset()) * 6e4;\n\n    units = normalizeUnits(units);\n\n    if (units === 'year' || units === 'month' || units === 'quarter') {\n        output = monthDiff(this, that);\n        if (units === 'quarter') {\n            output = output / 3;\n        } else if (units === 'year') {\n            output = output / 12;\n        }\n    } else {\n        delta = this - that;\n        output = units === 'second' ? delta / 1e3 : // 1000\n            units === 'minute' ? delta / 6e4 : // 1000 * 60\n            units === 'hour' ? delta / 36e5 : // 1000 * 60 * 60\n            units === 'day' ? (delta - zoneDelta) / 864e5 : // 1000 * 60 * 60 * 24, negate dst\n            units === 'week' ? (delta - zoneDelta) / 6048e5 : // 1000 * 60 * 60 * 24 * 7, negate dst\n            delta;\n    }\n    return asFloat ? output : absFloor(output);\n}\n\nfunction monthDiff (a, b) {\n    // difference in months\n    var wholeMonthDiff = ((b.year() - a.year()) * 12) + (b.month() - a.month()),\n        // b is in (anchor - 1 month, anchor + 1 month)\n        anchor = a.clone().add(wholeMonthDiff, 'months'),\n        anchor2, adjust;\n\n    if (b - anchor < 0) {\n        anchor2 = a.clone().add(wholeMonthDiff - 1, 'months');\n        // linear across the month\n        adjust = (b - anchor) / (anchor - anchor2);\n    } else {\n        anchor2 = a.clone().add(wholeMonthDiff + 1, 'months');\n        // linear across the month\n        adjust = (b - anchor) / (anchor2 - anchor);\n    }\n\n    //check for negative zero, return zero if negative zero\n    return -(wholeMonthDiff + adjust) || 0;\n}\n\nhooks.defaultFormat = 'YYYY-MM-DDTHH:mm:ssZ';\nhooks.defaultFormatUtc = 'YYYY-MM-DDTHH:mm:ss[Z]';\n\nfunction toString () {\n    return this.clone().locale('en').format('ddd MMM DD YYYY HH:mm:ss [GMT]ZZ');\n}\n\nfunction toISOString() {\n    if (!this.isValid()) {\n        return null;\n    }\n    var m = this.clone().utc();\n    if (m.year() < 0 || m.year() > 9999) {\n        return formatMoment(m, 'YYYYYY-MM-DD[T]HH:mm:ss.SSS[Z]');\n    }\n    if (isFunction(Date.prototype.toISOString)) {\n        // native implementation is ~50x faster, use it when we can\n        return this.toDate().toISOString();\n    }\n    return formatMoment(m, 'YYYY-MM-DD[T]HH:mm:ss.SSS[Z]');\n}\n\n/**\n * Return a human readable representation of a moment that can\n * also be evaluated to get a new moment which is the same\n *\n * @link https://nodejs.org/dist/latest/docs/api/util.html#util_custom_inspect_function_on_objects\n */\nfunction inspect () {\n    if (!this.isValid()) {\n        return 'moment.invalid(/* ' + this._i + ' */)';\n    }\n    var func = 'moment';\n    var zone = '';\n    if (!this.isLocal()) {\n        func = this.utcOffset() === 0 ? 'moment.utc' : 'moment.parseZone';\n        zone = 'Z';\n    }\n    var prefix = '[' + func + '(\"]';\n    var year = (0 <= this.year() && this.year() <= 9999) ? 'YYYY' : 'YYYYYY';\n    var datetime = '-MM-DD[T]HH:mm:ss.SSS';\n    var suffix = zone + '[\")]';\n\n    return this.format(prefix + year + datetime + suffix);\n}\n\nfunction format (inputString) {\n    if (!inputString) {\n        inputString = this.isUtc() ? hooks.defaultFormatUtc : hooks.defaultFormat;\n    }\n    var output = formatMoment(this, inputString);\n    return this.localeData().postformat(output);\n}\n\nfunction from (time, withoutSuffix) {\n    if (this.isValid() &&\n            ((isMoment(time) && time.isValid()) ||\n             createLocal(time).isValid())) {\n        return createDuration({to: this, from: time}).locale(this.locale()).humanize(!withoutSuffix);\n    } else {\n        return this.localeData().invalidDate();\n    }\n}\n\nfunction fromNow (withoutSuffix) {\n    return this.from(createLocal(), withoutSuffix);\n}\n\nfunction to (time, withoutSuffix) {\n    if (this.isValid() &&\n            ((isMoment(time) && time.isValid()) ||\n             createLocal(time).isValid())) {\n        return createDuration({from: this, to: time}).locale(this.locale()).humanize(!withoutSuffix);\n    } else {\n        return this.localeData().invalidDate();\n    }\n}\n\nfunction toNow (withoutSuffix) {\n    return this.to(createLocal(), withoutSuffix);\n}\n\n// If passed a locale key, it will set the locale for this\n// instance.  Otherwise, it will return the locale configuration\n// variables for this instance.\nfunction locale (key) {\n    var newLocaleData;\n\n    if (key === undefined) {\n        return this._locale._abbr;\n    } else {\n        newLocaleData = getLocale(key);\n        if (newLocaleData != null) {\n            this._locale = newLocaleData;\n        }\n        return this;\n    }\n}\n\nvar lang = deprecate(\n    'moment().lang() is deprecated. Instead, use moment().localeData() to get the language configuration. Use moment().locale() to change languages.',\n    function (key) {\n        if (key === undefined) {\n            return this.localeData();\n        } else {\n            return this.locale(key);\n        }\n    }\n);\n\nfunction localeData () {\n    return this._locale;\n}\n\nfunction startOf (units) {\n    units = normalizeUnits(units);\n    // the following switch intentionally omits break keywords\n    // to utilize falling through the cases.\n    switch (units) {\n        case 'year':\n            this.month(0);\n            /* falls through */\n        case 'quarter':\n        case 'month':\n            this.date(1);\n            /* falls through */\n        case 'week':\n        case 'isoWeek':\n        case 'day':\n        case 'date':\n            this.hours(0);\n            /* falls through */\n        case 'hour':\n            this.minutes(0);\n            /* falls through */\n        case 'minute':\n            this.seconds(0);\n            /* falls through */\n        case 'second':\n            this.milliseconds(0);\n    }\n\n    // weeks are a special case\n    if (units === 'week') {\n        this.weekday(0);\n    }\n    if (units === 'isoWeek') {\n        this.isoWeekday(1);\n    }\n\n    // quarters are also special\n    if (units === 'quarter') {\n        this.month(Math.floor(this.month() / 3) * 3);\n    }\n\n    return this;\n}\n\nfunction endOf (units) {\n    units = normalizeUnits(units);\n    if (units === undefined || units === 'millisecond') {\n        return this;\n    }\n\n    // 'date' is an alias for 'day', so it should be considered as such.\n    if (units === 'date') {\n        units = 'day';\n    }\n\n    return this.startOf(units).add(1, (units === 'isoWeek' ? 'week' : units)).subtract(1, 'ms');\n}\n\nfunction valueOf () {\n    return this._d.valueOf() - ((this._offset || 0) * 60000);\n}\n\nfunction unix () {\n    return Math.floor(this.valueOf() / 1000);\n}\n\nfunction toDate () {\n    return new Date(this.valueOf());\n}\n\nfunction toArray () {\n    var m = this;\n    return [m.year(), m.month(), m.date(), m.hour(), m.minute(), m.second(), m.millisecond()];\n}\n\nfunction toObject () {\n    var m = this;\n    return {\n        years: m.year(),\n        months: m.month(),\n        date: m.date(),\n        hours: m.hours(),\n        minutes: m.minutes(),\n        seconds: m.seconds(),\n        milliseconds: m.milliseconds()\n    };\n}\n\nfunction toJSON () {\n    // new Date(NaN).toJSON() === null\n    return this.isValid() ? this.toISOString() : null;\n}\n\nfunction isValid$2 () {\n    return isValid(this);\n}\n\nfunction parsingFlags () {\n    return extend({}, getParsingFlags(this));\n}\n\nfunction invalidAt () {\n    return getParsingFlags(this).overflow;\n}\n\nfunction creationData() {\n    return {\n        input: this._i,\n        format: this._f,\n        locale: this._locale,\n        isUTC: this._isUTC,\n        strict: this._strict\n    };\n}\n\n// FORMATTING\n\naddFormatToken(0, ['gg', 2], 0, function () {\n    return this.weekYear() % 100;\n});\n\naddFormatToken(0, ['GG', 2], 0, function () {\n    return this.isoWeekYear() % 100;\n});\n\nfunction addWeekYearFormatToken (token, getter) {\n    addFormatToken(0, [token, token.length], 0, getter);\n}\n\naddWeekYearFormatToken('gggg',     'weekYear');\naddWeekYearFormatToken('ggggg',    'weekYear');\naddWeekYearFormatToken('GGGG',  'isoWeekYear');\naddWeekYearFormatToken('GGGGG', 'isoWeekYear');\n\n// ALIASES\n\naddUnitAlias('weekYear', 'gg');\naddUnitAlias('isoWeekYear', 'GG');\n\n// PRIORITY\n\naddUnitPriority('weekYear', 1);\naddUnitPriority('isoWeekYear', 1);\n\n\n// PARSING\n\naddRegexToken('G',      matchSigned);\naddRegexToken('g',      matchSigned);\naddRegexToken('GG',     match1to2, match2);\naddRegexToken('gg',     match1to2, match2);\naddRegexToken('GGGG',   match1to4, match4);\naddRegexToken('gggg',   match1to4, match4);\naddRegexToken('GGGGG',  match1to6, match6);\naddRegexToken('ggggg',  match1to6, match6);\n\naddWeekParseToken(['gggg', 'ggggg', 'GGGG', 'GGGGG'], function (input, week, config, token) {\n    week[token.substr(0, 2)] = toInt(input);\n});\n\naddWeekParseToken(['gg', 'GG'], function (input, week, config, token) {\n    week[token] = hooks.parseTwoDigitYear(input);\n});\n\n// MOMENTS\n\nfunction getSetWeekYear (input) {\n    return getSetWeekYearHelper.call(this,\n            input,\n            this.week(),\n            this.weekday(),\n            this.localeData()._week.dow,\n            this.localeData()._week.doy);\n}\n\nfunction getSetISOWeekYear (input) {\n    return getSetWeekYearHelper.call(this,\n            input, this.isoWeek(), this.isoWeekday(), 1, 4);\n}\n\nfunction getISOWeeksInYear () {\n    return weeksInYear(this.year(), 1, 4);\n}\n\nfunction getWeeksInYear () {\n    var weekInfo = this.localeData()._week;\n    return weeksInYear(this.year(), weekInfo.dow, weekInfo.doy);\n}\n\nfunction getSetWeekYearHelper(input, week, weekday, dow, doy) {\n    var weeksTarget;\n    if (input == null) {\n        return weekOfYear(this, dow, doy).year;\n    } else {\n        weeksTarget = weeksInYear(input, dow, doy);\n        if (week > weeksTarget) {\n            week = weeksTarget;\n        }\n        return setWeekAll.call(this, input, week, weekday, dow, doy);\n    }\n}\n\nfunction setWeekAll(weekYear, week, weekday, dow, doy) {\n    var dayOfYearData = dayOfYearFromWeeks(weekYear, week, weekday, dow, doy),\n        date = createUTCDate(dayOfYearData.year, 0, dayOfYearData.dayOfYear);\n\n    this.year(date.getUTCFullYear());\n    this.month(date.getUTCMonth());\n    this.date(date.getUTCDate());\n    return this;\n}\n\n// FORMATTING\n\naddFormatToken('Q', 0, 'Qo', 'quarter');\n\n// ALIASES\n\naddUnitAlias('quarter', 'Q');\n\n// PRIORITY\n\naddUnitPriority('quarter', 7);\n\n// PARSING\n\naddRegexToken('Q', match1);\naddParseToken('Q', function (input, array) {\n    array[MONTH] = (toInt(input) - 1) * 3;\n});\n\n// MOMENTS\n\nfunction getSetQuarter (input) {\n    return input == null ? Math.ceil((this.month() + 1) / 3) : this.month((input - 1) * 3 + this.month() % 3);\n}\n\n// FORMATTING\n\naddFormatToken('D', ['DD', 2], 'Do', 'date');\n\n// ALIASES\n\naddUnitAlias('date', 'D');\n\n// PRIOROITY\naddUnitPriority('date', 9);\n\n// PARSING\n\naddRegexToken('D',  match1to2);\naddRegexToken('DD', match1to2, match2);\naddRegexToken('Do', function (isStrict, locale) {\n    // TODO: Remove \"ordinalParse\" fallback in next major release.\n    return isStrict ?\n      (locale._dayOfMonthOrdinalParse || locale._ordinalParse) :\n      locale._dayOfMonthOrdinalParseLenient;\n});\n\naddParseToken(['D', 'DD'], DATE);\naddParseToken('Do', function (input, array) {\n    array[DATE] = toInt(input.match(match1to2)[0], 10);\n});\n\n// MOMENTS\n\nvar getSetDayOfMonth = makeGetSet('Date', true);\n\n// FORMATTING\n\naddFormatToken('DDD', ['DDDD', 3], 'DDDo', 'dayOfYear');\n\n// ALIASES\n\naddUnitAlias('dayOfYear', 'DDD');\n\n// PRIORITY\naddUnitPriority('dayOfYear', 4);\n\n// PARSING\n\naddRegexToken('DDD',  match1to3);\naddRegexToken('DDDD', match3);\naddParseToken(['DDD', 'DDDD'], function (input, array, config) {\n    config._dayOfYear = toInt(input);\n});\n\n// HELPERS\n\n// MOMENTS\n\nfunction getSetDayOfYear (input) {\n    var dayOfYear = Math.round((this.clone().startOf('day') - this.clone().startOf('year')) / 864e5) + 1;\n    return input == null ? dayOfYear : this.add((input - dayOfYear), 'd');\n}\n\n// FORMATTING\n\naddFormatToken('m', ['mm', 2], 0, 'minute');\n\n// ALIASES\n\naddUnitAlias('minute', 'm');\n\n// PRIORITY\n\naddUnitPriority('minute', 14);\n\n// PARSING\n\naddRegexToken('m',  match1to2);\naddRegexToken('mm', match1to2, match2);\naddParseToken(['m', 'mm'], MINUTE);\n\n// MOMENTS\n\nvar getSetMinute = makeGetSet('Minutes', false);\n\n// FORMATTING\n\naddFormatToken('s', ['ss', 2], 0, 'second');\n\n// ALIASES\n\naddUnitAlias('second', 's');\n\n// PRIORITY\n\naddUnitPriority('second', 15);\n\n// PARSING\n\naddRegexToken('s',  match1to2);\naddRegexToken('ss', match1to2, match2);\naddParseToken(['s', 'ss'], SECOND);\n\n// MOMENTS\n\nvar getSetSecond = makeGetSet('Seconds', false);\n\n// FORMATTING\n\naddFormatToken('S', 0, 0, function () {\n    return ~~(this.millisecond() / 100);\n});\n\naddFormatToken(0, ['SS', 2], 0, function () {\n    return ~~(this.millisecond() / 10);\n});\n\naddFormatToken(0, ['SSS', 3], 0, 'millisecond');\naddFormatToken(0, ['SSSS', 4], 0, function () {\n    return this.millisecond() * 10;\n});\naddFormatToken(0, ['SSSSS', 5], 0, function () {\n    return this.millisecond() * 100;\n});\naddFormatToken(0, ['SSSSSS', 6], 0, function () {\n    return this.millisecond() * 1000;\n});\naddFormatToken(0, ['SSSSSSS', 7], 0, function () {\n    return this.millisecond() * 10000;\n});\naddFormatToken(0, ['SSSSSSSS', 8], 0, function () {\n    return this.millisecond() * 100000;\n});\naddFormatToken(0, ['SSSSSSSSS', 9], 0, function () {\n    return this.millisecond() * 1000000;\n});\n\n\n// ALIASES\n\naddUnitAlias('millisecond', 'ms');\n\n// PRIORITY\n\naddUnitPriority('millisecond', 16);\n\n// PARSING\n\naddRegexToken('S',    match1to3, match1);\naddRegexToken('SS',   match1to3, match2);\naddRegexToken('SSS',  match1to3, match3);\n\nvar token;\nfor (token = 'SSSS'; token.length <= 9; token += 'S') {\n    addRegexToken(token, matchUnsigned);\n}\n\nfunction parseMs(input, array) {\n    array[MILLISECOND] = toInt(('0.' + input) * 1000);\n}\n\nfor (token = 'S'; token.length <= 9; token += 'S') {\n    addParseToken(token, parseMs);\n}\n// MOMENTS\n\nvar getSetMillisecond = makeGetSet('Milliseconds', false);\n\n// FORMATTING\n\naddFormatToken('z',  0, 0, 'zoneAbbr');\naddFormatToken('zz', 0, 0, 'zoneName');\n\n// MOMENTS\n\nfunction getZoneAbbr () {\n    return this._isUTC ? 'UTC' : '';\n}\n\nfunction getZoneName () {\n    return this._isUTC ? 'Coordinated Universal Time' : '';\n}\n\nvar proto = Moment.prototype;\n\nproto.add               = add;\nproto.calendar          = calendar$1;\nproto.clone             = clone;\nproto.diff              = diff;\nproto.endOf             = endOf;\nproto.format            = format;\nproto.from              = from;\nproto.fromNow           = fromNow;\nproto.to                = to;\nproto.toNow             = toNow;\nproto.get               = stringGet;\nproto.invalidAt         = invalidAt;\nproto.isAfter           = isAfter;\nproto.isBefore          = isBefore;\nproto.isBetween         = isBetween;\nproto.isSame            = isSame;\nproto.isSameOrAfter     = isSameOrAfter;\nproto.isSameOrBefore    = isSameOrBefore;\nproto.isValid           = isValid$2;\nproto.lang              = lang;\nproto.locale            = locale;\nproto.localeData        = localeData;\nproto.max               = prototypeMax;\nproto.min               = prototypeMin;\nproto.parsingFlags      = parsingFlags;\nproto.set               = stringSet;\nproto.startOf           = startOf;\nproto.subtract          = subtract;\nproto.toArray           = toArray;\nproto.toObject          = toObject;\nproto.toDate            = toDate;\nproto.toISOString       = toISOString;\nproto.inspect           = inspect;\nproto.toJSON            = toJSON;\nproto.toString          = toString;\nproto.unix              = unix;\nproto.valueOf           = valueOf;\nproto.creationData      = creationData;\n\n// Year\nproto.year       = getSetYear;\nproto.isLeapYear = getIsLeapYear;\n\n// Week Year\nproto.weekYear    = getSetWeekYear;\nproto.isoWeekYear = getSetISOWeekYear;\n\n// Quarter\nproto.quarter = proto.quarters = getSetQuarter;\n\n// Month\nproto.month       = getSetMonth;\nproto.daysInMonth = getDaysInMonth;\n\n// Week\nproto.week           = proto.weeks        = getSetWeek;\nproto.isoWeek        = proto.isoWeeks     = getSetISOWeek;\nproto.weeksInYear    = getWeeksInYear;\nproto.isoWeeksInYear = getISOWeeksInYear;\n\n// Day\nproto.date       = getSetDayOfMonth;\nproto.day        = proto.days             = getSetDayOfWeek;\nproto.weekday    = getSetLocaleDayOfWeek;\nproto.isoWeekday = getSetISODayOfWeek;\nproto.dayOfYear  = getSetDayOfYear;\n\n// Hour\nproto.hour = proto.hours = getSetHour;\n\n// Minute\nproto.minute = proto.minutes = getSetMinute;\n\n// Second\nproto.second = proto.seconds = getSetSecond;\n\n// Millisecond\nproto.millisecond = proto.milliseconds = getSetMillisecond;\n\n// Offset\nproto.utcOffset            = getSetOffset;\nproto.utc                  = setOffsetToUTC;\nproto.local                = setOffsetToLocal;\nproto.parseZone            = setOffsetToParsedOffset;\nproto.hasAlignedHourOffset = hasAlignedHourOffset;\nproto.isDST                = isDaylightSavingTime;\nproto.isLocal              = isLocal;\nproto.isUtcOffset          = isUtcOffset;\nproto.isUtc                = isUtc;\nproto.isUTC                = isUtc;\n\n// Timezone\nproto.zoneAbbr = getZoneAbbr;\nproto.zoneName = getZoneName;\n\n// Deprecations\nproto.dates  = deprecate('dates accessor is deprecated. Use date instead.', getSetDayOfMonth);\nproto.months = deprecate('months accessor is deprecated. Use month instead', getSetMonth);\nproto.years  = deprecate('years accessor is deprecated. Use year instead', getSetYear);\nproto.zone   = deprecate('moment().zone is deprecated, use moment().utcOffset instead. http://momentjs.com/guides/#/warnings/zone/', getSetZone);\nproto.isDSTShifted = deprecate('isDSTShifted is deprecated. See http://momentjs.com/guides/#/warnings/dst-shifted/ for more information', isDaylightSavingTimeShifted);\n\nfunction createUnix (input) {\n    return createLocal(input * 1000);\n}\n\nfunction createInZone () {\n    return createLocal.apply(null, arguments).parseZone();\n}\n\nfunction preParsePostFormat (string) {\n    return string;\n}\n\nvar proto$1 = Locale.prototype;\n\nproto$1.calendar        = calendar;\nproto$1.longDateFormat  = longDateFormat;\nproto$1.invalidDate     = invalidDate;\nproto$1.ordinal         = ordinal;\nproto$1.preparse        = preParsePostFormat;\nproto$1.postformat      = preParsePostFormat;\nproto$1.relativeTime    = relativeTime;\nproto$1.pastFuture      = pastFuture;\nproto$1.set             = set;\n\n// Month\nproto$1.months            =        localeMonths;\nproto$1.monthsShort       =        localeMonthsShort;\nproto$1.monthsParse       =        localeMonthsParse;\nproto$1.monthsRegex       = monthsRegex;\nproto$1.monthsShortRegex  = monthsShortRegex;\n\n// Week\nproto$1.week = localeWeek;\nproto$1.firstDayOfYear = localeFirstDayOfYear;\nproto$1.firstDayOfWeek = localeFirstDayOfWeek;\n\n// Day of Week\nproto$1.weekdays       =        localeWeekdays;\nproto$1.weekdaysMin    =        localeWeekdaysMin;\nproto$1.weekdaysShort  =        localeWeekdaysShort;\nproto$1.weekdaysParse  =        localeWeekdaysParse;\n\nproto$1.weekdaysRegex       =        weekdaysRegex;\nproto$1.weekdaysShortRegex  =        weekdaysShortRegex;\nproto$1.weekdaysMinRegex    =        weekdaysMinRegex;\n\n// Hours\nproto$1.isPM = localeIsPM;\nproto$1.meridiem = localeMeridiem;\n\nfunction get$1 (format, index, field, setter) {\n    var locale = getLocale();\n    var utc = createUTC().set(setter, index);\n    return locale[field](utc, format);\n}\n\nfunction listMonthsImpl (format, index, field) {\n    if (isNumber(format)) {\n        index = format;\n        format = undefined;\n    }\n\n    format = format || '';\n\n    if (index != null) {\n        return get$1(format, index, field, 'month');\n    }\n\n    var i;\n    var out = [];\n    for (i = 0; i < 12; i++) {\n        out[i] = get$1(format, i, field, 'month');\n    }\n    return out;\n}\n\n// ()\n// (5)\n// (fmt, 5)\n// (fmt)\n// (true)\n// (true, 5)\n// (true, fmt, 5)\n// (true, fmt)\nfunction listWeekdaysImpl (localeSorted, format, index, field) {\n    if (typeof localeSorted === 'boolean') {\n        if (isNumber(format)) {\n            index = format;\n            format = undefined;\n        }\n\n        format = format || '';\n    } else {\n        format = localeSorted;\n        index = format;\n        localeSorted = false;\n\n        if (isNumber(format)) {\n            index = format;\n            format = undefined;\n        }\n\n        format = format || '';\n    }\n\n    var locale = getLocale(),\n        shift = localeSorted ? locale._week.dow : 0;\n\n    if (index != null) {\n        return get$1(format, (index + shift) % 7, field, 'day');\n    }\n\n    var i;\n    var out = [];\n    for (i = 0; i < 7; i++) {\n        out[i] = get$1(format, (i + shift) % 7, field, 'day');\n    }\n    return out;\n}\n\nfunction listMonths (format, index) {\n    return listMonthsImpl(format, index, 'months');\n}\n\nfunction listMonthsShort (format, index) {\n    return listMonthsImpl(format, index, 'monthsShort');\n}\n\nfunction listWeekdays (localeSorted, format, index) {\n    return listWeekdaysImpl(localeSorted, format, index, 'weekdays');\n}\n\nfunction listWeekdaysShort (localeSorted, format, index) {\n    return listWeekdaysImpl(localeSorted, format, index, 'weekdaysShort');\n}\n\nfunction listWeekdaysMin (localeSorted, format, index) {\n    return listWeekdaysImpl(localeSorted, format, index, 'weekdaysMin');\n}\n\ngetSetGlobalLocale('en', {\n    dayOfMonthOrdinalParse: /\\d{1,2}(th|st|nd|rd)/,\n    ordinal : function (number) {\n        var b = number % 10,\n            output = (toInt(number % 100 / 10) === 1) ? 'th' :\n            (b === 1) ? 'st' :\n            (b === 2) ? 'nd' :\n            (b === 3) ? 'rd' : 'th';\n        return number + output;\n    }\n});\n\n// Side effect imports\nhooks.lang = deprecate('moment.lang is deprecated. Use moment.locale instead.', getSetGlobalLocale);\nhooks.langData = deprecate('moment.langData is deprecated. Use moment.localeData instead.', getLocale);\n\nvar mathAbs = Math.abs;\n\nfunction abs () {\n    var data           = this._data;\n\n    this._milliseconds = mathAbs(this._milliseconds);\n    this._days         = mathAbs(this._days);\n    this._months       = mathAbs(this._months);\n\n    data.milliseconds  = mathAbs(data.milliseconds);\n    data.seconds       = mathAbs(data.seconds);\n    data.minutes       = mathAbs(data.minutes);\n    data.hours         = mathAbs(data.hours);\n    data.months        = mathAbs(data.months);\n    data.years         = mathAbs(data.years);\n\n    return this;\n}\n\nfunction addSubtract$1 (duration, input, value, direction) {\n    var other = createDuration(input, value);\n\n    duration._milliseconds += direction * other._milliseconds;\n    duration._days         += direction * other._days;\n    duration._months       += direction * other._months;\n\n    return duration._bubble();\n}\n\n// supports only 2.0-style add(1, 's') or add(duration)\nfunction add$1 (input, value) {\n    return addSubtract$1(this, input, value, 1);\n}\n\n// supports only 2.0-style subtract(1, 's') or subtract(duration)\nfunction subtract$1 (input, value) {\n    return addSubtract$1(this, input, value, -1);\n}\n\nfunction absCeil (number) {\n    if (number < 0) {\n        return Math.floor(number);\n    } else {\n        return Math.ceil(number);\n    }\n}\n\nfunction bubble () {\n    var milliseconds = this._milliseconds;\n    var days         = this._days;\n    var months       = this._months;\n    var data         = this._data;\n    var seconds, minutes, hours, years, monthsFromDays;\n\n    // if we have a mix of positive and negative values, bubble down first\n    // check: https://github.com/moment/moment/issues/2166\n    if (!((milliseconds >= 0 && days >= 0 && months >= 0) ||\n            (milliseconds <= 0 && days <= 0 && months <= 0))) {\n        milliseconds += absCeil(monthsToDays(months) + days) * 864e5;\n        days = 0;\n        months = 0;\n    }\n\n    // The following code bubbles up values, see the tests for\n    // examples of what that means.\n    data.milliseconds = milliseconds % 1000;\n\n    seconds           = absFloor(milliseconds / 1000);\n    data.seconds      = seconds % 60;\n\n    minutes           = absFloor(seconds / 60);\n    data.minutes      = minutes % 60;\n\n    hours             = absFloor(minutes / 60);\n    data.hours        = hours % 24;\n\n    days += absFloor(hours / 24);\n\n    // convert days to months\n    monthsFromDays = absFloor(daysToMonths(days));\n    months += monthsFromDays;\n    days -= absCeil(monthsToDays(monthsFromDays));\n\n    // 12 months -> 1 year\n    years = absFloor(months / 12);\n    months %= 12;\n\n    data.days   = days;\n    data.months = months;\n    data.years  = years;\n\n    return this;\n}\n\nfunction daysToMonths (days) {\n    // 400 years have 146097 days (taking into account leap year rules)\n    // 400 years have 12 months === 4800\n    return days * 4800 / 146097;\n}\n\nfunction monthsToDays (months) {\n    // the reverse of daysToMonths\n    return months * 146097 / 4800;\n}\n\nfunction as (units) {\n    if (!this.isValid()) {\n        return NaN;\n    }\n    var days;\n    var months;\n    var milliseconds = this._milliseconds;\n\n    units = normalizeUnits(units);\n\n    if (units === 'month' || units === 'year') {\n        days   = this._days   + milliseconds / 864e5;\n        months = this._months + daysToMonths(days);\n        return units === 'month' ? months : months / 12;\n    } else {\n        // handle milliseconds separately because of floating point math errors (issue #1867)\n        days = this._days + Math.round(monthsToDays(this._months));\n        switch (units) {\n            case 'week'   : return days / 7     + milliseconds / 6048e5;\n            case 'day'    : return days         + milliseconds / 864e5;\n            case 'hour'   : return days * 24    + milliseconds / 36e5;\n            case 'minute' : return days * 1440  + milliseconds / 6e4;\n            case 'second' : return days * 86400 + milliseconds / 1000;\n            // Math.floor prevents floating point math errors here\n            case 'millisecond': return Math.floor(days * 864e5) + milliseconds;\n            default: throw new Error('Unknown unit ' + units);\n        }\n    }\n}\n\n// TODO: Use this.as('ms')?\nfunction valueOf$1 () {\n    if (!this.isValid()) {\n        return NaN;\n    }\n    return (\n        this._milliseconds +\n        this._days * 864e5 +\n        (this._months % 12) * 2592e6 +\n        toInt(this._months / 12) * 31536e6\n    );\n}\n\nfunction makeAs (alias) {\n    return function () {\n        return this.as(alias);\n    };\n}\n\nvar asMilliseconds = makeAs('ms');\nvar asSeconds      = makeAs('s');\nvar asMinutes      = makeAs('m');\nvar asHours        = makeAs('h');\nvar asDays         = makeAs('d');\nvar asWeeks        = makeAs('w');\nvar asMonths       = makeAs('M');\nvar asYears        = makeAs('y');\n\nfunction get$2 (units) {\n    units = normalizeUnits(units);\n    return this.isValid() ? this[units + 's']() : NaN;\n}\n\nfunction makeGetter(name) {\n    return function () {\n        return this.isValid() ? this._data[name] : NaN;\n    };\n}\n\nvar milliseconds = makeGetter('milliseconds');\nvar seconds      = makeGetter('seconds');\nvar minutes      = makeGetter('minutes');\nvar hours        = makeGetter('hours');\nvar days         = makeGetter('days');\nvar months       = makeGetter('months');\nvar years        = makeGetter('years');\n\nfunction weeks () {\n    return absFloor(this.days() / 7);\n}\n\nvar round = Math.round;\nvar thresholds = {\n    ss: 44,         // a few seconds to seconds\n    s : 45,         // seconds to minute\n    m : 45,         // minutes to hour\n    h : 22,         // hours to day\n    d : 26,         // days to month\n    M : 11          // months to year\n};\n\n// helper function for moment.fn.from, moment.fn.fromNow, and moment.duration.fn.humanize\nfunction substituteTimeAgo(string, number, withoutSuffix, isFuture, locale) {\n    return locale.relativeTime(number || 1, !!withoutSuffix, string, isFuture);\n}\n\nfunction relativeTime$1 (posNegDuration, withoutSuffix, locale) {\n    var duration = createDuration(posNegDuration).abs();\n    var seconds  = round(duration.as('s'));\n    var minutes  = round(duration.as('m'));\n    var hours    = round(duration.as('h'));\n    var days     = round(duration.as('d'));\n    var months   = round(duration.as('M'));\n    var years    = round(duration.as('y'));\n\n    var a = seconds <= thresholds.ss && ['s', seconds]  ||\n            seconds < thresholds.s   && ['ss', seconds] ||\n            minutes <= 1             && ['m']           ||\n            minutes < thresholds.m   && ['mm', minutes] ||\n            hours   <= 1             && ['h']           ||\n            hours   < thresholds.h   && ['hh', hours]   ||\n            days    <= 1             && ['d']           ||\n            days    < thresholds.d   && ['dd', days]    ||\n            months  <= 1             && ['M']           ||\n            months  < thresholds.M   && ['MM', months]  ||\n            years   <= 1             && ['y']           || ['yy', years];\n\n    a[2] = withoutSuffix;\n    a[3] = +posNegDuration > 0;\n    a[4] = locale;\n    return substituteTimeAgo.apply(null, a);\n}\n\n// This function allows you to set the rounding function for relative time strings\nfunction getSetRelativeTimeRounding (roundingFunction) {\n    if (roundingFunction === undefined) {\n        return round;\n    }\n    if (typeof(roundingFunction) === 'function') {\n        round = roundingFunction;\n        return true;\n    }\n    return false;\n}\n\n// This function allows you to set a threshold for relative time strings\nfunction getSetRelativeTimeThreshold (threshold, limit) {\n    if (thresholds[threshold] === undefined) {\n        return false;\n    }\n    if (limit === undefined) {\n        return thresholds[threshold];\n    }\n    thresholds[threshold] = limit;\n    if (threshold === 's') {\n        thresholds.ss = limit - 1;\n    }\n    return true;\n}\n\nfunction humanize (withSuffix) {\n    if (!this.isValid()) {\n        return this.localeData().invalidDate();\n    }\n\n    var locale = this.localeData();\n    var output = relativeTime$1(this, !withSuffix, locale);\n\n    if (withSuffix) {\n        output = locale.pastFuture(+this, output);\n    }\n\n    return locale.postformat(output);\n}\n\nvar abs$1 = Math.abs;\n\nfunction toISOString$1() {\n    // for ISO strings we do not use the normal bubbling rules:\n    //  * milliseconds bubble up until they become hours\n    //  * days do not bubble at all\n    //  * months bubble up until they become years\n    // This is because there is no context-free conversion between hours and days\n    // (think of clock changes)\n    // and also not between days and months (28-31 days per month)\n    if (!this.isValid()) {\n        return this.localeData().invalidDate();\n    }\n\n    var seconds = abs$1(this._milliseconds) / 1000;\n    var days         = abs$1(this._days);\n    var months       = abs$1(this._months);\n    var minutes, hours, years;\n\n    // 3600 seconds -> 60 minutes -> 1 hour\n    minutes           = absFloor(seconds / 60);\n    hours             = absFloor(minutes / 60);\n    seconds %= 60;\n    minutes %= 60;\n\n    // 12 months -> 1 year\n    years  = absFloor(months / 12);\n    months %= 12;\n\n\n    // inspired by https://github.com/dordille/moment-isoduration/blob/master/moment.isoduration.js\n    var Y = years;\n    var M = months;\n    var D = days;\n    var h = hours;\n    var m = minutes;\n    var s = seconds;\n    var total = this.asSeconds();\n\n    if (!total) {\n        // this is the same as C#'s (Noda) and python (isodate)...\n        // but not other JS (goog.date)\n        return 'P0D';\n    }\n\n    return (total < 0 ? '-' : '') +\n        'P' +\n        (Y ? Y + 'Y' : '') +\n        (M ? M + 'M' : '') +\n        (D ? D + 'D' : '') +\n        ((h || m || s) ? 'T' : '') +\n        (h ? h + 'H' : '') +\n        (m ? m + 'M' : '') +\n        (s ? s + 'S' : '');\n}\n\nvar proto$2 = Duration.prototype;\n\nproto$2.isValid        = isValid$1;\nproto$2.abs            = abs;\nproto$2.add            = add$1;\nproto$2.subtract       = subtract$1;\nproto$2.as             = as;\nproto$2.asMilliseconds = asMilliseconds;\nproto$2.asSeconds      = asSeconds;\nproto$2.asMinutes      = asMinutes;\nproto$2.asHours        = asHours;\nproto$2.asDays         = asDays;\nproto$2.asWeeks        = asWeeks;\nproto$2.asMonths       = asMonths;\nproto$2.asYears        = asYears;\nproto$2.valueOf        = valueOf$1;\nproto$2._bubble        = bubble;\nproto$2.get            = get$2;\nproto$2.milliseconds   = milliseconds;\nproto$2.seconds        = seconds;\nproto$2.minutes        = minutes;\nproto$2.hours          = hours;\nproto$2.days           = days;\nproto$2.weeks          = weeks;\nproto$2.months         = months;\nproto$2.years          = years;\nproto$2.humanize       = humanize;\nproto$2.toISOString    = toISOString$1;\nproto$2.toString       = toISOString$1;\nproto$2.toJSON         = toISOString$1;\nproto$2.locale         = locale;\nproto$2.localeData     = localeData;\n\n// Deprecations\nproto$2.toIsoString = deprecate('toIsoString() is deprecated. Please use toISOString() instead (notice the capitals)', toISOString$1);\nproto$2.lang = lang;\n\n// Side effect imports\n\n// FORMATTING\n\naddFormatToken('X', 0, 0, 'unix');\naddFormatToken('x', 0, 0, 'valueOf');\n\n// PARSING\n\naddRegexToken('x', matchSigned);\naddRegexToken('X', matchTimestamp);\naddParseToken('X', function (input, array, config) {\n    config._d = new Date(parseFloat(input, 10) * 1000);\n});\naddParseToken('x', function (input, array, config) {\n    config._d = new Date(toInt(input));\n});\n\n// Side effect imports\n\n\nhooks.version = '2.18.1';\n\nsetHookCallback(createLocal);\n\nhooks.fn                    = proto;\nhooks.min                   = min;\nhooks.max                   = max;\nhooks.now                   = now;\nhooks.utc                   = createUTC;\nhooks.unix                  = createUnix;\nhooks.months                = listMonths;\nhooks.isDate                = isDate;\nhooks.locale                = getSetGlobalLocale;\nhooks.invalid               = createInvalid;\nhooks.duration              = createDuration;\nhooks.isMoment              = isMoment;\nhooks.weekdays              = listWeekdays;\nhooks.parseZone             = createInZone;\nhooks.localeData            = getLocale;\nhooks.isDuration            = isDuration;\nhooks.monthsShort           = listMonthsShort;\nhooks.weekdaysMin           = listWeekdaysMin;\nhooks.defineLocale          = defineLocale;\nhooks.updateLocale          = updateLocale;\nhooks.locales               = listLocales;\nhooks.weekdaysShort         = listWeekdaysShort;\nhooks.normalizeUnits        = normalizeUnits;\nhooks.relativeTimeRounding = getSetRelativeTimeRounding;\nhooks.relativeTimeThreshold = getSetRelativeTimeThreshold;\nhooks.calendarFormat        = getCalendarFormat;\nhooks.prototype             = proto;\n\nreturn hooks;\n\n})));\n\n/* WEBPACK VAR INJECTION */}.call(exports, __webpack_require__(219)(module)))\n\n/***/ }),\n\n/***/ 538:\n/***/ (function(module, __webpack_exports__, __webpack_require__) {\n\n\"use strict\";\n/* harmony import */ var __WEBPACK_IMPORTED_MODULE_0__Select__ = __webpack_require__(547);\n\n\n/* harmony default export */ __webpack_exports__[\"a\"] = (__WEBPACK_IMPORTED_MODULE_0__Select__[\"a\" /* default */]);\n\n/***/ }),\n\n/***/ 547:\n/***/ (function(module, __webpack_exports__, __webpack_require__) {\n\n\"use strict\";\n/* harmony import */ var __WEBPACK_IMPORTED_MODULE_0_glamorous__ = __webpack_require__(29);\n\n\nvar Select = __WEBPACK_IMPORTED_MODULE_0_glamorous__[\"a\" /* default */].select({\n  // fontSize: '24px',\n  // textAlign: 'center',\n  // margin: '12px auto',\n  // display: 'block',\n  // border: '1px solid #d1d1d1',\n  backgroundColor: '#fff',\n  // padding: '12px',\n  appearance: 'none',\n\n  display: 'flex',\n  flex: '1 1 auto',\n  alignSelf: 'stretch',\n  margin: '12px auto',\n  textAlign: 'center',\n  border: '0',\n  boxShadow: '0px 2px 10px -2px rgba(0, 0, 0, 0.5)',\n  borderRadius: '4px',\n  padding: '6px 18px',\n  fontSize: '24px',\n  lineHeight: '30px',\n  backgroundImage: '\\n    linear-gradient(60deg, transparent 50%, black 50%),\\n    linear-gradient(120deg, black 60%, transparent 50%),\\n    linear-gradient(to right, white, white)',\n  backgroundPosition: '\\n    calc(100% - 20px) calc(1em + -5px),\\n    calc(100% - 15px) calc(1em + -5px),\\n    100% 0',\n  backgroundSize: '\\n    5px 10px,\\n    5px 10px,\\n    1.5em 2.5em',\n  backgroundRepeat: 'no-repeat'\n\n});\n\n/* harmony default export */ __webpack_exports__[\"a\"] = (Select);\n\n/***/ }),\n\n/***/ 563:\n/***/ (function(module, __webpack_exports__, __webpack_require__) {\n\n\"use strict\";\nvar _createClass = function () { function defineProperties(target, props) { for (var i = 0; i < props.length; i++) { var descriptor = props[i]; descriptor.enumerable = descriptor.enumerable || false; descriptor.configurable = true; if (\"value\" in descriptor) descriptor.writable = true; Object.defineProperty(target, descriptor.key, descriptor); } } return function (Constructor, protoProps, staticProps) { if (protoProps) defineProperties(Constructor.prototype, protoProps); if (staticProps) defineProperties(Constructor, staticProps); return Constructor; }; }();\n\nfunction _classCallCheck(instance, Constructor) { if (!(instance instanceof Constructor)) { throw new TypeError(\"Cannot call a class as a function\"); } }\n\nvar FinancialHelpers = function () {\n  function FinancialHelpers() {\n    _classCallCheck(this, FinancialHelpers);\n  }\n\n  _createClass(FinancialHelpers, null, [{\n    key: 'currencyFormatted',\n    value: function currencyFormatted(amount) {\n      var i = parseFloat(amount.replace ? amount.replace(',', '') : amount);\n      if (isNaN(i)) {\n        i = 0.00;\n      }\n      var minus = '';\n      if (i < 0) {\n        minus = '-';\n      }\n      i = Math.abs(i);\n      i = parseInt((i + 0.005) * 100, 10);\n      i /= 100;\n      var s = String(i);\n      if (s.indexOf('.') < 0) {\n        s += '.00';\n      }\n      if (s.indexOf('.') === s.length - 2) {\n        s += '0';\n      }\n      s = minus + s;\n      return s;\n    }\n  }, {\n    key: 'getConvertToAmount',\n    value: function getConvertToAmount(amount) {\n      var i = parseFloat(amount.replace ? amount.replace(',', '') : amount);\n      if (isNaN(i)) {\n        i = 0.00;\n      }\n      i = Math.abs(i);\n      i = parseInt((i + 0.005) * 100, 10);\n      i /= 100;\n      return i;\n    }\n  }]);\n\n  return FinancialHelpers;\n}();\n\n/* harmony default export */ __webpack_exports__[\"a\"] = (FinancialHelpers);\n\n/***/ })\n\n});\n\n\n// WEBPACK FOOTER //\n// static/js/2.85953234.chunk.js","import React, { Component } from 'react';\nimport PropTypes from 'prop-types';\nimport { graphql } from 'react-apollo';\nimport gql from 'graphql-tag';\nimport moment from 'moment';\n\nimport FinancialHelpers from '../../../utils/helpers/financial-hepers.js';\nimport Tile from '../../components/Tile';\nimport Select from '../../components/Select';\nimport Loader from '../../components/loader/loader.jsx';\n\nclass CategoriesSection extends Component {\n  constructor(props) {\n    super(props);\n\n    this.renderOptions = this.renderOptions.bind(this);\n    this.renderCategory = this.renderCategory.bind(this);\n    this.setCategoryId = this.setCategoryId.bind(this);\n\n    this.state = {\n      categoryId: props.categories && props.categories[0] && props.categories[0].id\n    };\n  }\n  componentWillReceiveProps(nextProps) {\n    this.setState(() => ({\n      categoryId: nextProps.categories && nextProps.categories[0] && nextProps.categories[0].id\n    }));\n  }\n  setCategoryId({ target }) {\n    this.setState(() => ({ categoryId: target.value }));\n  }\n  getPercentage({\n    currentBalance,\n    max,\n  }) {\n    let value = currentBalance !== 0 ?\n      Math.floor(\n        ((parseFloat(currentBalance) /\n        parseFloat(max)) * 100), 0\n      ) : 0.001;\n    value = currentBalance > 0 && value < 1 ? 1 : value;\n    return value;\n  }\n  renderOptions() {\n    return this.props.categories.map((category) => (\n      <option value={category.id}>{category.name}</option>\n    ));\n  }\n\n  renderCategory() {\n    return this.props.categories\n      .filter((category) => category.id === this.state.categoryId)\n      .map((category) => {\n        const percent = this.getPercentage({\n          currentBalance: category.currentBalance,\n          max: category.max,\n        });\n        let color = 'success';\n        if (percent >= 75 && percent < 90) {\n          color = 'warning';\n        } else if (percent >= 75 && percent >= 90) {\n          color = 'danger';\n        }\n        const difference = FinancialHelpers.currencyFormatted(\n          category.max - category.currentBalance\n        );\n        return (\n          <Tile>\n            <h4>{category.name}</h4>\n            <h4>{difference}</h4>\n            <progress\n              className={`progress progress-${color}`}\n              value={percent > 100 ? 100 : percent}\n              max=\"100\"\n            />\n          </Tile>\n        );\n      });\n  }\n  render() {\n    return this.props.isLoading ? (<Loader />) : (\n      <div>\n        <Tile>\n          <Select\n            ref={(categorySelector) => { this.categorySelector = categorySelector; }}\n            onChange={this.setCategoryId}\n          >\n            {this.renderOptions()}\n          </Select>\n        </Tile>\n        {this.renderCategory()}\n      </div>\n    );\n  }\n}\nCategoriesSection.propTypes = {\n  categories: PropTypes.array.isRequired,\n  isLoading: PropTypes.bool.isRequired,\n  // month: PropTypes.string,\n  // year: PropTypes.string,\n};\n\nconst qCategoriesForBudget = gql`\nquery qDashboard(\n  $auth0UserId: String!,\n  $startDate: DateTime!,\n  $endDate: DateTime!,\n){\n  allCategories(\n    filter: {\n      user: {\n        auth0UserId: $auth0UserId\n      }\n    }\n  ){\n    id\n    name\n    max\n    positiveTransactions(\n      filter:{\n        transactionDate_gte: $startDate,\n        transactionDate_lte: $endDate\n      }\n    ){\n      id\n      amount\n      transactionDate\n    }\n    negativeTransactions(\n      filter:{\n        transactionDate_gte: $startDate,\n        transactionDate_lte: $endDate\n      }\n    ){\n      id\n      amount\n      transactionDate\n    }\n  }\n}\n`;\n\nfunction getProfile() {\n  // Retrieves the profile data from local storage\n  const profile = localStorage.getItem('profile');\n  return profile ? JSON.parse(localStorage.profile) : {};\n}\n\nconst CategoriesForBudget = graphql(qCategoriesForBudget, {\n\n  options() {\n    const startDate = moment().startOf('month').subtract(0, 'month').toISOString();\n    const endDate = moment().endOf('month').subtract(0, 'month').toISOString();\n    const auth0UserId = getProfile().user_id;\n    return {\n      variables: {\n        startDate,\n        endDate,\n        auth0UserId,\n      },\n    };\n  },\n\n  // ownProps are the props that are passed into the `ProfileWithData`\n  // when it is used by a parent component\n  props: ({ ownProps, data: { loading, allCategories, refetch } }) => ({\n    ownProps,\n    isLoading: loading,\n    categories: prepareFiancialAccounts(allCategories) || [],\n    refetch,\n  }),\n})(CategoriesSection);\n\nexport default CategoriesForBudget;\n\nfunction prepareFiancialAccounts(financialAccounts) {\n  return !financialAccounts || financialAccounts.length < 1 ? null :\n    financialAccounts.reduce((fas, fa) => ([...fas, {\n      ...fa,\n      currentBalance: fa.openingBalance ?\n        fa.openingBalance + getCurrentBalance(fa) :\n        getCurrentBalance(fa),\n    }]), []);\n}\n\nfunction getCurrentBalance(financialAccount) {\n  if (financialAccount.type === 'debt') {\n    return financialAccount.negativeTransactions\n             .reduce((total, t) => total + t.amount, 0) -\n           financialAccount.positiveTransactions\n             .reduce((total, t) => total + t.amount, 0);\n  }\n  return financialAccount.positiveTransactions\n           .reduce((total, t) => total + t.amount, 0) -\n         financialAccount.negativeTransactions\n           .reduce((total, t) => total + t.amount, 0);\n}\n\n\n\n// WEBPACK FOOTER //\n// ./src/ui/pages/categories/categories-section.jsx","//! moment.js\n//! version : 2.18.1\n//! authors : Tim Wood, Iskren Chernev, Moment.js contributors\n//! license : MIT\n//! momentjs.com\n\n;(function (global, factory) {\n    typeof exports === 'object' && typeof module !== 'undefined' ? module.exports = factory() :\n    typeof define === 'function' && define.amd ? define(factory) :\n    global.moment = factory()\n}(this, (function () { 'use strict';\n\nvar hookCallback;\n\nfunction hooks () {\n    return hookCallback.apply(null, arguments);\n}\n\n// This is done to register the method called with moment()\n// without creating circular dependencies.\nfunction setHookCallback (callback) {\n    hookCallback = callback;\n}\n\nfunction isArray(input) {\n    return input instanceof Array || Object.prototype.toString.call(input) === '[object Array]';\n}\n\nfunction isObject(input) {\n    // IE8 will treat undefined and null as object if it wasn't for\n    // input != null\n    return input != null && Object.prototype.toString.call(input) === '[object Object]';\n}\n\nfunction isObjectEmpty(obj) {\n    var k;\n    for (k in obj) {\n        // even if its not own property I'd still call it non-empty\n        return false;\n    }\n    return true;\n}\n\nfunction isUndefined(input) {\n    return input === void 0;\n}\n\nfunction isNumber(input) {\n    return typeof input === 'number' || Object.prototype.toString.call(input) === '[object Number]';\n}\n\nfunction isDate(input) {\n    return input instanceof Date || Object.prototype.toString.call(input) === '[object Date]';\n}\n\nfunction map(arr, fn) {\n    var res = [], i;\n    for (i = 0; i < arr.length; ++i) {\n        res.push(fn(arr[i], i));\n    }\n    return res;\n}\n\nfunction hasOwnProp(a, b) {\n    return Object.prototype.hasOwnProperty.call(a, b);\n}\n\nfunction extend(a, b) {\n    for (var i in b) {\n        if (hasOwnProp(b, i)) {\n            a[i] = b[i];\n        }\n    }\n\n    if (hasOwnProp(b, 'toString')) {\n        a.toString = b.toString;\n    }\n\n    if (hasOwnProp(b, 'valueOf')) {\n        a.valueOf = b.valueOf;\n    }\n\n    return a;\n}\n\nfunction createUTC (input, format, locale, strict) {\n    return createLocalOrUTC(input, format, locale, strict, true).utc();\n}\n\nfunction defaultParsingFlags() {\n    // We need to deep clone this object.\n    return {\n        empty           : false,\n        unusedTokens    : [],\n        unusedInput     : [],\n        overflow        : -2,\n        charsLeftOver   : 0,\n        nullInput       : false,\n        invalidMonth    : null,\n        invalidFormat   : false,\n        userInvalidated : false,\n        iso             : false,\n        parsedDateParts : [],\n        meridiem        : null,\n        rfc2822         : false,\n        weekdayMismatch : false\n    };\n}\n\nfunction getParsingFlags(m) {\n    if (m._pf == null) {\n        m._pf = defaultParsingFlags();\n    }\n    return m._pf;\n}\n\nvar some;\nif (Array.prototype.some) {\n    some = Array.prototype.some;\n} else {\n    some = function (fun) {\n        var t = Object(this);\n        var len = t.length >>> 0;\n\n        for (var i = 0; i < len; i++) {\n            if (i in t && fun.call(this, t[i], i, t)) {\n                return true;\n            }\n        }\n\n        return false;\n    };\n}\n\nvar some$1 = some;\n\nfunction isValid(m) {\n    if (m._isValid == null) {\n        var flags = getParsingFlags(m);\n        var parsedParts = some$1.call(flags.parsedDateParts, function (i) {\n            return i != null;\n        });\n        var isNowValid = !isNaN(m._d.getTime()) &&\n            flags.overflow < 0 &&\n            !flags.empty &&\n            !flags.invalidMonth &&\n            !flags.invalidWeekday &&\n            !flags.nullInput &&\n            !flags.invalidFormat &&\n            !flags.userInvalidated &&\n            (!flags.meridiem || (flags.meridiem && parsedParts));\n\n        if (m._strict) {\n            isNowValid = isNowValid &&\n                flags.charsLeftOver === 0 &&\n                flags.unusedTokens.length === 0 &&\n                flags.bigHour === undefined;\n        }\n\n        if (Object.isFrozen == null || !Object.isFrozen(m)) {\n            m._isValid = isNowValid;\n        }\n        else {\n            return isNowValid;\n        }\n    }\n    return m._isValid;\n}\n\nfunction createInvalid (flags) {\n    var m = createUTC(NaN);\n    if (flags != null) {\n        extend(getParsingFlags(m), flags);\n    }\n    else {\n        getParsingFlags(m).userInvalidated = true;\n    }\n\n    return m;\n}\n\n// Plugins that add properties should also add the key here (null value),\n// so we can properly clone ourselves.\nvar momentProperties = hooks.momentProperties = [];\n\nfunction copyConfig(to, from) {\n    var i, prop, val;\n\n    if (!isUndefined(from._isAMomentObject)) {\n        to._isAMomentObject = from._isAMomentObject;\n    }\n    if (!isUndefined(from._i)) {\n        to._i = from._i;\n    }\n    if (!isUndefined(from._f)) {\n        to._f = from._f;\n    }\n    if (!isUndefined(from._l)) {\n        to._l = from._l;\n    }\n    if (!isUndefined(from._strict)) {\n        to._strict = from._strict;\n    }\n    if (!isUndefined(from._tzm)) {\n        to._tzm = from._tzm;\n    }\n    if (!isUndefined(from._isUTC)) {\n        to._isUTC = from._isUTC;\n    }\n    if (!isUndefined(from._offset)) {\n        to._offset = from._offset;\n    }\n    if (!isUndefined(from._pf)) {\n        to._pf = getParsingFlags(from);\n    }\n    if (!isUndefined(from._locale)) {\n        to._locale = from._locale;\n    }\n\n    if (momentProperties.length > 0) {\n        for (i = 0; i < momentProperties.length; i++) {\n            prop = momentProperties[i];\n            val = from[prop];\n            if (!isUndefined(val)) {\n                to[prop] = val;\n            }\n        }\n    }\n\n    return to;\n}\n\nvar updateInProgress = false;\n\n// Moment prototype object\nfunction Moment(config) {\n    copyConfig(this, config);\n    this._d = new Date(config._d != null ? config._d.getTime() : NaN);\n    if (!this.isValid()) {\n        this._d = new Date(NaN);\n    }\n    // Prevent infinite loop in case updateOffset creates new moment\n    // objects.\n    if (updateInProgress === false) {\n        updateInProgress = true;\n        hooks.updateOffset(this);\n        updateInProgress = false;\n    }\n}\n\nfunction isMoment (obj) {\n    return obj instanceof Moment || (obj != null && obj._isAMomentObject != null);\n}\n\nfunction absFloor (number) {\n    if (number < 0) {\n        // -0 -> 0\n        return Math.ceil(number) || 0;\n    } else {\n        return Math.floor(number);\n    }\n}\n\nfunction toInt(argumentForCoercion) {\n    var coercedNumber = +argumentForCoercion,\n        value = 0;\n\n    if (coercedNumber !== 0 && isFinite(coercedNumber)) {\n        value = absFloor(coercedNumber);\n    }\n\n    return value;\n}\n\n// compare two arrays, return the number of differences\nfunction compareArrays(array1, array2, dontConvert) {\n    var len = Math.min(array1.length, array2.length),\n        lengthDiff = Math.abs(array1.length - array2.length),\n        diffs = 0,\n        i;\n    for (i = 0; i < len; i++) {\n        if ((dontConvert && array1[i] !== array2[i]) ||\n            (!dontConvert && toInt(array1[i]) !== toInt(array2[i]))) {\n            diffs++;\n        }\n    }\n    return diffs + lengthDiff;\n}\n\nfunction warn(msg) {\n    if (hooks.suppressDeprecationWarnings === false &&\n            (typeof console !==  'undefined') && console.warn) {\n        console.warn('Deprecation warning: ' + msg);\n    }\n}\n\nfunction deprecate(msg, fn) {\n    var firstTime = true;\n\n    return extend(function () {\n        if (hooks.deprecationHandler != null) {\n            hooks.deprecationHandler(null, msg);\n        }\n        if (firstTime) {\n            var args = [];\n            var arg;\n            for (var i = 0; i < arguments.length; i++) {\n                arg = '';\n                if (typeof arguments[i] === 'object') {\n                    arg += '\\n[' + i + '] ';\n                    for (var key in arguments[0]) {\n                        arg += key + ': ' + arguments[0][key] + ', ';\n                    }\n                    arg = arg.slice(0, -2); // Remove trailing comma and space\n                } else {\n                    arg = arguments[i];\n                }\n                args.push(arg);\n            }\n            warn(msg + '\\nArguments: ' + Array.prototype.slice.call(args).join('') + '\\n' + (new Error()).stack);\n            firstTime = false;\n        }\n        return fn.apply(this, arguments);\n    }, fn);\n}\n\nvar deprecations = {};\n\nfunction deprecateSimple(name, msg) {\n    if (hooks.deprecationHandler != null) {\n        hooks.deprecationHandler(name, msg);\n    }\n    if (!deprecations[name]) {\n        warn(msg);\n        deprecations[name] = true;\n    }\n}\n\nhooks.suppressDeprecationWarnings = false;\nhooks.deprecationHandler = null;\n\nfunction isFunction(input) {\n    return input instanceof Function || Object.prototype.toString.call(input) === '[object Function]';\n}\n\nfunction set (config) {\n    var prop, i;\n    for (i in config) {\n        prop = config[i];\n        if (isFunction(prop)) {\n            this[i] = prop;\n        } else {\n            this['_' + i] = prop;\n        }\n    }\n    this._config = config;\n    // Lenient ordinal parsing accepts just a number in addition to\n    // number + (possibly) stuff coming from _dayOfMonthOrdinalParse.\n    // TODO: Remove \"ordinalParse\" fallback in next major release.\n    this._dayOfMonthOrdinalParseLenient = new RegExp(\n        (this._dayOfMonthOrdinalParse.source || this._ordinalParse.source) +\n            '|' + (/\\d{1,2}/).source);\n}\n\nfunction mergeConfigs(parentConfig, childConfig) {\n    var res = extend({}, parentConfig), prop;\n    for (prop in childConfig) {\n        if (hasOwnProp(childConfig, prop)) {\n            if (isObject(parentConfig[prop]) && isObject(childConfig[prop])) {\n                res[prop] = {};\n                extend(res[prop], parentConfig[prop]);\n                extend(res[prop], childConfig[prop]);\n            } else if (childConfig[prop] != null) {\n                res[prop] = childConfig[prop];\n            } else {\n                delete res[prop];\n            }\n        }\n    }\n    for (prop in parentConfig) {\n        if (hasOwnProp(parentConfig, prop) &&\n                !hasOwnProp(childConfig, prop) &&\n                isObject(parentConfig[prop])) {\n            // make sure changes to properties don't modify parent config\n            res[prop] = extend({}, res[prop]);\n        }\n    }\n    return res;\n}\n\nfunction Locale(config) {\n    if (config != null) {\n        this.set(config);\n    }\n}\n\nvar keys;\n\nif (Object.keys) {\n    keys = Object.keys;\n} else {\n    keys = function (obj) {\n        var i, res = [];\n        for (i in obj) {\n            if (hasOwnProp(obj, i)) {\n                res.push(i);\n            }\n        }\n        return res;\n    };\n}\n\nvar keys$1 = keys;\n\nvar defaultCalendar = {\n    sameDay : '[Today at] LT',\n    nextDay : '[Tomorrow at] LT',\n    nextWeek : 'dddd [at] LT',\n    lastDay : '[Yesterday at] LT',\n    lastWeek : '[Last] dddd [at] LT',\n    sameElse : 'L'\n};\n\nfunction calendar (key, mom, now) {\n    var output = this._calendar[key] || this._calendar['sameElse'];\n    return isFunction(output) ? output.call(mom, now) : output;\n}\n\nvar defaultLongDateFormat = {\n    LTS  : 'h:mm:ss A',\n    LT   : 'h:mm A',\n    L    : 'MM/DD/YYYY',\n    LL   : 'MMMM D, YYYY',\n    LLL  : 'MMMM D, YYYY h:mm A',\n    LLLL : 'dddd, MMMM D, YYYY h:mm A'\n};\n\nfunction longDateFormat (key) {\n    var format = this._longDateFormat[key],\n        formatUpper = this._longDateFormat[key.toUpperCase()];\n\n    if (format || !formatUpper) {\n        return format;\n    }\n\n    this._longDateFormat[key] = formatUpper.replace(/MMMM|MM|DD|dddd/g, function (val) {\n        return val.slice(1);\n    });\n\n    return this._longDateFormat[key];\n}\n\nvar defaultInvalidDate = 'Invalid date';\n\nfunction invalidDate () {\n    return this._invalidDate;\n}\n\nvar defaultOrdinal = '%d';\nvar defaultDayOfMonthOrdinalParse = /\\d{1,2}/;\n\nfunction ordinal (number) {\n    return this._ordinal.replace('%d', number);\n}\n\nvar defaultRelativeTime = {\n    future : 'in %s',\n    past   : '%s ago',\n    s  : 'a few seconds',\n    ss : '%d seconds',\n    m  : 'a minute',\n    mm : '%d minutes',\n    h  : 'an hour',\n    hh : '%d hours',\n    d  : 'a day',\n    dd : '%d days',\n    M  : 'a month',\n    MM : '%d months',\n    y  : 'a year',\n    yy : '%d years'\n};\n\nfunction relativeTime (number, withoutSuffix, string, isFuture) {\n    var output = this._relativeTime[string];\n    return (isFunction(output)) ?\n        output(number, withoutSuffix, string, isFuture) :\n        output.replace(/%d/i, number);\n}\n\nfunction pastFuture (diff, output) {\n    var format = this._relativeTime[diff > 0 ? 'future' : 'past'];\n    return isFunction(format) ? format(output) : format.replace(/%s/i, output);\n}\n\nvar aliases = {};\n\nfunction addUnitAlias (unit, shorthand) {\n    var lowerCase = unit.toLowerCase();\n    aliases[lowerCase] = aliases[lowerCase + 's'] = aliases[shorthand] = unit;\n}\n\nfunction normalizeUnits(units) {\n    return typeof units === 'string' ? aliases[units] || aliases[units.toLowerCase()] : undefined;\n}\n\nfunction normalizeObjectUnits(inputObject) {\n    var normalizedInput = {},\n        normalizedProp,\n        prop;\n\n    for (prop in inputObject) {\n        if (hasOwnProp(inputObject, prop)) {\n            normalizedProp = normalizeUnits(prop);\n            if (normalizedProp) {\n                normalizedInput[normalizedProp] = inputObject[prop];\n            }\n        }\n    }\n\n    return normalizedInput;\n}\n\nvar priorities = {};\n\nfunction addUnitPriority(unit, priority) {\n    priorities[unit] = priority;\n}\n\nfunction getPrioritizedUnits(unitsObj) {\n    var units = [];\n    for (var u in unitsObj) {\n        units.push({unit: u, priority: priorities[u]});\n    }\n    units.sort(function (a, b) {\n        return a.priority - b.priority;\n    });\n    return units;\n}\n\nfunction makeGetSet (unit, keepTime) {\n    return function (value) {\n        if (value != null) {\n            set$1(this, unit, value);\n            hooks.updateOffset(this, keepTime);\n            return this;\n        } else {\n            return get(this, unit);\n        }\n    };\n}\n\nfunction get (mom, unit) {\n    return mom.isValid() ?\n        mom._d['get' + (mom._isUTC ? 'UTC' : '') + unit]() : NaN;\n}\n\nfunction set$1 (mom, unit, value) {\n    if (mom.isValid()) {\n        mom._d['set' + (mom._isUTC ? 'UTC' : '') + unit](value);\n    }\n}\n\n// MOMENTS\n\nfunction stringGet (units) {\n    units = normalizeUnits(units);\n    if (isFunction(this[units])) {\n        return this[units]();\n    }\n    return this;\n}\n\n\nfunction stringSet (units, value) {\n    if (typeof units === 'object') {\n        units = normalizeObjectUnits(units);\n        var prioritized = getPrioritizedUnits(units);\n        for (var i = 0; i < prioritized.length; i++) {\n            this[prioritized[i].unit](units[prioritized[i].unit]);\n        }\n    } else {\n        units = normalizeUnits(units);\n        if (isFunction(this[units])) {\n            return this[units](value);\n        }\n    }\n    return this;\n}\n\nfunction zeroFill(number, targetLength, forceSign) {\n    var absNumber = '' + Math.abs(number),\n        zerosToFill = targetLength - absNumber.length,\n        sign = number >= 0;\n    return (sign ? (forceSign ? '+' : '') : '-') +\n        Math.pow(10, Math.max(0, zerosToFill)).toString().substr(1) + absNumber;\n}\n\nvar formattingTokens = /(\\[[^\\[]*\\])|(\\\\)?([Hh]mm(ss)?|Mo|MM?M?M?|Do|DDDo|DD?D?D?|ddd?d?|do?|w[o|w]?|W[o|W]?|Qo?|YYYYYY|YYYYY|YYYY|YY|gg(ggg?)?|GG(GGG?)?|e|E|a|A|hh?|HH?|kk?|mm?|ss?|S{1,9}|x|X|zz?|ZZ?|.)/g;\n\nvar localFormattingTokens = /(\\[[^\\[]*\\])|(\\\\)?(LTS|LT|LL?L?L?|l{1,4})/g;\n\nvar formatFunctions = {};\n\nvar formatTokenFunctions = {};\n\n// token:    'M'\n// padded:   ['MM', 2]\n// ordinal:  'Mo'\n// callback: function () { this.month() + 1 }\nfunction addFormatToken (token, padded, ordinal, callback) {\n    var func = callback;\n    if (typeof callback === 'string') {\n        func = function () {\n            return this[callback]();\n        };\n    }\n    if (token) {\n        formatTokenFunctions[token] = func;\n    }\n    if (padded) {\n        formatTokenFunctions[padded[0]] = function () {\n            return zeroFill(func.apply(this, arguments), padded[1], padded[2]);\n        };\n    }\n    if (ordinal) {\n        formatTokenFunctions[ordinal] = function () {\n            return this.localeData().ordinal(func.apply(this, arguments), token);\n        };\n    }\n}\n\nfunction removeFormattingTokens(input) {\n    if (input.match(/\\[[\\s\\S]/)) {\n        return input.replace(/^\\[|\\]$/g, '');\n    }\n    return input.replace(/\\\\/g, '');\n}\n\nfunction makeFormatFunction(format) {\n    var array = format.match(formattingTokens), i, length;\n\n    for (i = 0, length = array.length; i < length; i++) {\n        if (formatTokenFunctions[array[i]]) {\n            array[i] = formatTokenFunctions[array[i]];\n        } else {\n            array[i] = removeFormattingTokens(array[i]);\n        }\n    }\n\n    return function (mom) {\n        var output = '', i;\n        for (i = 0; i < length; i++) {\n            output += isFunction(array[i]) ? array[i].call(mom, format) : array[i];\n        }\n        return output;\n    };\n}\n\n// format date using native date object\nfunction formatMoment(m, format) {\n    if (!m.isValid()) {\n        return m.localeData().invalidDate();\n    }\n\n    format = expandFormat(format, m.localeData());\n    formatFunctions[format] = formatFunctions[format] || makeFormatFunction(format);\n\n    return formatFunctions[format](m);\n}\n\nfunction expandFormat(format, locale) {\n    var i = 5;\n\n    function replaceLongDateFormatTokens(input) {\n        return locale.longDateFormat(input) || input;\n    }\n\n    localFormattingTokens.lastIndex = 0;\n    while (i >= 0 && localFormattingTokens.test(format)) {\n        format = format.replace(localFormattingTokens, replaceLongDateFormatTokens);\n        localFormattingTokens.lastIndex = 0;\n        i -= 1;\n    }\n\n    return format;\n}\n\nvar match1         = /\\d/;            //       0 - 9\nvar match2         = /\\d\\d/;          //      00 - 99\nvar match3         = /\\d{3}/;         //     000 - 999\nvar match4         = /\\d{4}/;         //    0000 - 9999\nvar match6         = /[+-]?\\d{6}/;    // -999999 - 999999\nvar match1to2      = /\\d\\d?/;         //       0 - 99\nvar match3to4      = /\\d\\d\\d\\d?/;     //     999 - 9999\nvar match5to6      = /\\d\\d\\d\\d\\d\\d?/; //   99999 - 999999\nvar match1to3      = /\\d{1,3}/;       //       0 - 999\nvar match1to4      = /\\d{1,4}/;       //       0 - 9999\nvar match1to6      = /[+-]?\\d{1,6}/;  // -999999 - 999999\n\nvar matchUnsigned  = /\\d+/;           //       0 - inf\nvar matchSigned    = /[+-]?\\d+/;      //    -inf - inf\n\nvar matchOffset    = /Z|[+-]\\d\\d:?\\d\\d/gi; // +00:00 -00:00 +0000 -0000 or Z\nvar matchShortOffset = /Z|[+-]\\d\\d(?::?\\d\\d)?/gi; // +00 -00 +00:00 -00:00 +0000 -0000 or Z\n\nvar matchTimestamp = /[+-]?\\d+(\\.\\d{1,3})?/; // 123456789 123456789.123\n\n// any word (or two) characters or numbers including two/three word month in arabic.\n// includes scottish gaelic two word and hyphenated months\nvar matchWord = /[0-9]*['a-z\\u00A0-\\u05FF\\u0700-\\uD7FF\\uF900-\\uFDCF\\uFDF0-\\uFFEF]+|[\\u0600-\\u06FF\\/]+(\\s*?[\\u0600-\\u06FF]+){1,2}/i;\n\n\nvar regexes = {};\n\nfunction addRegexToken (token, regex, strictRegex) {\n    regexes[token] = isFunction(regex) ? regex : function (isStrict, localeData) {\n        return (isStrict && strictRegex) ? strictRegex : regex;\n    };\n}\n\nfunction getParseRegexForToken (token, config) {\n    if (!hasOwnProp(regexes, token)) {\n        return new RegExp(unescapeFormat(token));\n    }\n\n    return regexes[token](config._strict, config._locale);\n}\n\n// Code from http://stackoverflow.com/questions/3561493/is-there-a-regexp-escape-function-in-javascript\nfunction unescapeFormat(s) {\n    return regexEscape(s.replace('\\\\', '').replace(/\\\\(\\[)|\\\\(\\])|\\[([^\\]\\[]*)\\]|\\\\(.)/g, function (matched, p1, p2, p3, p4) {\n        return p1 || p2 || p3 || p4;\n    }));\n}\n\nfunction regexEscape(s) {\n    return s.replace(/[-\\/\\\\^$*+?.()|[\\]{}]/g, '\\\\$&');\n}\n\nvar tokens = {};\n\nfunction addParseToken (token, callback) {\n    var i, func = callback;\n    if (typeof token === 'string') {\n        token = [token];\n    }\n    if (isNumber(callback)) {\n        func = function (input, array) {\n            array[callback] = toInt(input);\n        };\n    }\n    for (i = 0; i < token.length; i++) {\n        tokens[token[i]] = func;\n    }\n}\n\nfunction addWeekParseToken (token, callback) {\n    addParseToken(token, function (input, array, config, token) {\n        config._w = config._w || {};\n        callback(input, config._w, config, token);\n    });\n}\n\nfunction addTimeToArrayFromToken(token, input, config) {\n    if (input != null && hasOwnProp(tokens, token)) {\n        tokens[token](input, config._a, config, token);\n    }\n}\n\nvar YEAR = 0;\nvar MONTH = 1;\nvar DATE = 2;\nvar HOUR = 3;\nvar MINUTE = 4;\nvar SECOND = 5;\nvar MILLISECOND = 6;\nvar WEEK = 7;\nvar WEEKDAY = 8;\n\nvar indexOf;\n\nif (Array.prototype.indexOf) {\n    indexOf = Array.prototype.indexOf;\n} else {\n    indexOf = function (o) {\n        // I know\n        var i;\n        for (i = 0; i < this.length; ++i) {\n            if (this[i] === o) {\n                return i;\n            }\n        }\n        return -1;\n    };\n}\n\nvar indexOf$1 = indexOf;\n\nfunction daysInMonth(year, month) {\n    return new Date(Date.UTC(year, month + 1, 0)).getUTCDate();\n}\n\n// FORMATTING\n\naddFormatToken('M', ['MM', 2], 'Mo', function () {\n    return this.month() + 1;\n});\n\naddFormatToken('MMM', 0, 0, function (format) {\n    return this.localeData().monthsShort(this, format);\n});\n\naddFormatToken('MMMM', 0, 0, function (format) {\n    return this.localeData().months(this, format);\n});\n\n// ALIASES\n\naddUnitAlias('month', 'M');\n\n// PRIORITY\n\naddUnitPriority('month', 8);\n\n// PARSING\n\naddRegexToken('M',    match1to2);\naddRegexToken('MM',   match1to2, match2);\naddRegexToken('MMM',  function (isStrict, locale) {\n    return locale.monthsShortRegex(isStrict);\n});\naddRegexToken('MMMM', function (isStrict, locale) {\n    return locale.monthsRegex(isStrict);\n});\n\naddParseToken(['M', 'MM'], function (input, array) {\n    array[MONTH] = toInt(input) - 1;\n});\n\naddParseToken(['MMM', 'MMMM'], function (input, array, config, token) {\n    var month = config._locale.monthsParse(input, token, config._strict);\n    // if we didn't find a month name, mark the date as invalid.\n    if (month != null) {\n        array[MONTH] = month;\n    } else {\n        getParsingFlags(config).invalidMonth = input;\n    }\n});\n\n// LOCALES\n\nvar MONTHS_IN_FORMAT = /D[oD]?(\\[[^\\[\\]]*\\]|\\s)+MMMM?/;\nvar defaultLocaleMonths = 'January_February_March_April_May_June_July_August_September_October_November_December'.split('_');\nfunction localeMonths (m, format) {\n    if (!m) {\n        return isArray(this._months) ? this._months :\n            this._months['standalone'];\n    }\n    return isArray(this._months) ? this._months[m.month()] :\n        this._months[(this._months.isFormat || MONTHS_IN_FORMAT).test(format) ? 'format' : 'standalone'][m.month()];\n}\n\nvar defaultLocaleMonthsShort = 'Jan_Feb_Mar_Apr_May_Jun_Jul_Aug_Sep_Oct_Nov_Dec'.split('_');\nfunction localeMonthsShort (m, format) {\n    if (!m) {\n        return isArray(this._monthsShort) ? this._monthsShort :\n            this._monthsShort['standalone'];\n    }\n    return isArray(this._monthsShort) ? this._monthsShort[m.month()] :\n        this._monthsShort[MONTHS_IN_FORMAT.test(format) ? 'format' : 'standalone'][m.month()];\n}\n\nfunction handleStrictParse(monthName, format, strict) {\n    var i, ii, mom, llc = monthName.toLocaleLowerCase();\n    if (!this._monthsParse) {\n        // this is not used\n        this._monthsParse = [];\n        this._longMonthsParse = [];\n        this._shortMonthsParse = [];\n        for (i = 0; i < 12; ++i) {\n            mom = createUTC([2000, i]);\n            this._shortMonthsParse[i] = this.monthsShort(mom, '').toLocaleLowerCase();\n            this._longMonthsParse[i] = this.months(mom, '').toLocaleLowerCase();\n        }\n    }\n\n    if (strict) {\n        if (format === 'MMM') {\n            ii = indexOf$1.call(this._shortMonthsParse, llc);\n            return ii !== -1 ? ii : null;\n        } else {\n            ii = indexOf$1.call(this._longMonthsParse, llc);\n            return ii !== -1 ? ii : null;\n        }\n    } else {\n        if (format === 'MMM') {\n            ii = indexOf$1.call(this._shortMonthsParse, llc);\n            if (ii !== -1) {\n                return ii;\n            }\n            ii = indexOf$1.call(this._longMonthsParse, llc);\n            return ii !== -1 ? ii : null;\n        } else {\n            ii = indexOf$1.call(this._longMonthsParse, llc);\n            if (ii !== -1) {\n                return ii;\n            }\n            ii = indexOf$1.call(this._shortMonthsParse, llc);\n            return ii !== -1 ? ii : null;\n        }\n    }\n}\n\nfunction localeMonthsParse (monthName, format, strict) {\n    var i, mom, regex;\n\n    if (this._monthsParseExact) {\n        return handleStrictParse.call(this, monthName, format, strict);\n    }\n\n    if (!this._monthsParse) {\n        this._monthsParse = [];\n        this._longMonthsParse = [];\n        this._shortMonthsParse = [];\n    }\n\n    // TODO: add sorting\n    // Sorting makes sure if one month (or abbr) is a prefix of another\n    // see sorting in computeMonthsParse\n    for (i = 0; i < 12; i++) {\n        // make the regex if we don't have it already\n        mom = createUTC([2000, i]);\n        if (strict && !this._longMonthsParse[i]) {\n            this._longMonthsParse[i] = new RegExp('^' + this.months(mom, '').replace('.', '') + '$', 'i');\n            this._shortMonthsParse[i] = new RegExp('^' + this.monthsShort(mom, '').replace('.', '') + '$', 'i');\n        }\n        if (!strict && !this._monthsParse[i]) {\n            regex = '^' + this.months(mom, '') + '|^' + this.monthsShort(mom, '');\n            this._monthsParse[i] = new RegExp(regex.replace('.', ''), 'i');\n        }\n        // test the regex\n        if (strict && format === 'MMMM' && this._longMonthsParse[i].test(monthName)) {\n            return i;\n        } else if (strict && format === 'MMM' && this._shortMonthsParse[i].test(monthName)) {\n            return i;\n        } else if (!strict && this._monthsParse[i].test(monthName)) {\n            return i;\n        }\n    }\n}\n\n// MOMENTS\n\nfunction setMonth (mom, value) {\n    var dayOfMonth;\n\n    if (!mom.isValid()) {\n        // No op\n        return mom;\n    }\n\n    if (typeof value === 'string') {\n        if (/^\\d+$/.test(value)) {\n            value = toInt(value);\n        } else {\n            value = mom.localeData().monthsParse(value);\n            // TODO: Another silent failure?\n            if (!isNumber(value)) {\n                return mom;\n            }\n        }\n    }\n\n    dayOfMonth = Math.min(mom.date(), daysInMonth(mom.year(), value));\n    mom._d['set' + (mom._isUTC ? 'UTC' : '') + 'Month'](value, dayOfMonth);\n    return mom;\n}\n\nfunction getSetMonth (value) {\n    if (value != null) {\n        setMonth(this, value);\n        hooks.updateOffset(this, true);\n        return this;\n    } else {\n        return get(this, 'Month');\n    }\n}\n\nfunction getDaysInMonth () {\n    return daysInMonth(this.year(), this.month());\n}\n\nvar defaultMonthsShortRegex = matchWord;\nfunction monthsShortRegex (isStrict) {\n    if (this._monthsParseExact) {\n        if (!hasOwnProp(this, '_monthsRegex')) {\n            computeMonthsParse.call(this);\n        }\n        if (isStrict) {\n            return this._monthsShortStrictRegex;\n        } else {\n            return this._monthsShortRegex;\n        }\n    } else {\n        if (!hasOwnProp(this, '_monthsShortRegex')) {\n            this._monthsShortRegex = defaultMonthsShortRegex;\n        }\n        return this._monthsShortStrictRegex && isStrict ?\n            this._monthsShortStrictRegex : this._monthsShortRegex;\n    }\n}\n\nvar defaultMonthsRegex = matchWord;\nfunction monthsRegex (isStrict) {\n    if (this._monthsParseExact) {\n        if (!hasOwnProp(this, '_monthsRegex')) {\n            computeMonthsParse.call(this);\n        }\n        if (isStrict) {\n            return this._monthsStrictRegex;\n        } else {\n            return this._monthsRegex;\n        }\n    } else {\n        if (!hasOwnProp(this, '_monthsRegex')) {\n            this._monthsRegex = defaultMonthsRegex;\n        }\n        return this._monthsStrictRegex && isStrict ?\n            this._monthsStrictRegex : this._monthsRegex;\n    }\n}\n\nfunction computeMonthsParse () {\n    function cmpLenRev(a, b) {\n        return b.length - a.length;\n    }\n\n    var shortPieces = [], longPieces = [], mixedPieces = [],\n        i, mom;\n    for (i = 0; i < 12; i++) {\n        // make the regex if we don't have it already\n        mom = createUTC([2000, i]);\n        shortPieces.push(this.monthsShort(mom, ''));\n        longPieces.push(this.months(mom, ''));\n        mixedPieces.push(this.months(mom, ''));\n        mixedPieces.push(this.monthsShort(mom, ''));\n    }\n    // Sorting makes sure if one month (or abbr) is a prefix of another it\n    // will match the longer piece.\n    shortPieces.sort(cmpLenRev);\n    longPieces.sort(cmpLenRev);\n    mixedPieces.sort(cmpLenRev);\n    for (i = 0; i < 12; i++) {\n        shortPieces[i] = regexEscape(shortPieces[i]);\n        longPieces[i] = regexEscape(longPieces[i]);\n    }\n    for (i = 0; i < 24; i++) {\n        mixedPieces[i] = regexEscape(mixedPieces[i]);\n    }\n\n    this._monthsRegex = new RegExp('^(' + mixedPieces.join('|') + ')', 'i');\n    this._monthsShortRegex = this._monthsRegex;\n    this._monthsStrictRegex = new RegExp('^(' + longPieces.join('|') + ')', 'i');\n    this._monthsShortStrictRegex = new RegExp('^(' + shortPieces.join('|') + ')', 'i');\n}\n\n// FORMATTING\n\naddFormatToken('Y', 0, 0, function () {\n    var y = this.year();\n    return y <= 9999 ? '' + y : '+' + y;\n});\n\naddFormatToken(0, ['YY', 2], 0, function () {\n    return this.year() % 100;\n});\n\naddFormatToken(0, ['YYYY',   4],       0, 'year');\naddFormatToken(0, ['YYYYY',  5],       0, 'year');\naddFormatToken(0, ['YYYYYY', 6, true], 0, 'year');\n\n// ALIASES\n\naddUnitAlias('year', 'y');\n\n// PRIORITIES\n\naddUnitPriority('year', 1);\n\n// PARSING\n\naddRegexToken('Y',      matchSigned);\naddRegexToken('YY',     match1to2, match2);\naddRegexToken('YYYY',   match1to4, match4);\naddRegexToken('YYYYY',  match1to6, match6);\naddRegexToken('YYYYYY', match1to6, match6);\n\naddParseToken(['YYYYY', 'YYYYYY'], YEAR);\naddParseToken('YYYY', function (input, array) {\n    array[YEAR] = input.length === 2 ? hooks.parseTwoDigitYear(input) : toInt(input);\n});\naddParseToken('YY', function (input, array) {\n    array[YEAR] = hooks.parseTwoDigitYear(input);\n});\naddParseToken('Y', function (input, array) {\n    array[YEAR] = parseInt(input, 10);\n});\n\n// HELPERS\n\nfunction daysInYear(year) {\n    return isLeapYear(year) ? 366 : 365;\n}\n\nfunction isLeapYear(year) {\n    return (year % 4 === 0 && year % 100 !== 0) || year % 400 === 0;\n}\n\n// HOOKS\n\nhooks.parseTwoDigitYear = function (input) {\n    return toInt(input) + (toInt(input) > 68 ? 1900 : 2000);\n};\n\n// MOMENTS\n\nvar getSetYear = makeGetSet('FullYear', true);\n\nfunction getIsLeapYear () {\n    return isLeapYear(this.year());\n}\n\nfunction createDate (y, m, d, h, M, s, ms) {\n    // can't just apply() to create a date:\n    // https://stackoverflow.com/q/181348\n    var date = new Date(y, m, d, h, M, s, ms);\n\n    // the date constructor remaps years 0-99 to 1900-1999\n    if (y < 100 && y >= 0 && isFinite(date.getFullYear())) {\n        date.setFullYear(y);\n    }\n    return date;\n}\n\nfunction createUTCDate (y) {\n    var date = new Date(Date.UTC.apply(null, arguments));\n\n    // the Date.UTC function remaps years 0-99 to 1900-1999\n    if (y < 100 && y >= 0 && isFinite(date.getUTCFullYear())) {\n        date.setUTCFullYear(y);\n    }\n    return date;\n}\n\n// start-of-first-week - start-of-year\nfunction firstWeekOffset(year, dow, doy) {\n    var // first-week day -- which january is always in the first week (4 for iso, 1 for other)\n        fwd = 7 + dow - doy,\n        // first-week day local weekday -- which local weekday is fwd\n        fwdlw = (7 + createUTCDate(year, 0, fwd).getUTCDay() - dow) % 7;\n\n    return -fwdlw + fwd - 1;\n}\n\n// https://en.wikipedia.org/wiki/ISO_week_date#Calculating_a_date_given_the_year.2C_week_number_and_weekday\nfunction dayOfYearFromWeeks(year, week, weekday, dow, doy) {\n    var localWeekday = (7 + weekday - dow) % 7,\n        weekOffset = firstWeekOffset(year, dow, doy),\n        dayOfYear = 1 + 7 * (week - 1) + localWeekday + weekOffset,\n        resYear, resDayOfYear;\n\n    if (dayOfYear <= 0) {\n        resYear = year - 1;\n        resDayOfYear = daysInYear(resYear) + dayOfYear;\n    } else if (dayOfYear > daysInYear(year)) {\n        resYear = year + 1;\n        resDayOfYear = dayOfYear - daysInYear(year);\n    } else {\n        resYear = year;\n        resDayOfYear = dayOfYear;\n    }\n\n    return {\n        year: resYear,\n        dayOfYear: resDayOfYear\n    };\n}\n\nfunction weekOfYear(mom, dow, doy) {\n    var weekOffset = firstWeekOffset(mom.year(), dow, doy),\n        week = Math.floor((mom.dayOfYear() - weekOffset - 1) / 7) + 1,\n        resWeek, resYear;\n\n    if (week < 1) {\n        resYear = mom.year() - 1;\n        resWeek = week + weeksInYear(resYear, dow, doy);\n    } else if (week > weeksInYear(mom.year(), dow, doy)) {\n        resWeek = week - weeksInYear(mom.year(), dow, doy);\n        resYear = mom.year() + 1;\n    } else {\n        resYear = mom.year();\n        resWeek = week;\n    }\n\n    return {\n        week: resWeek,\n        year: resYear\n    };\n}\n\nfunction weeksInYear(year, dow, doy) {\n    var weekOffset = firstWeekOffset(year, dow, doy),\n        weekOffsetNext = firstWeekOffset(year + 1, dow, doy);\n    return (daysInYear(year) - weekOffset + weekOffsetNext) / 7;\n}\n\n// FORMATTING\n\naddFormatToken('w', ['ww', 2], 'wo', 'week');\naddFormatToken('W', ['WW', 2], 'Wo', 'isoWeek');\n\n// ALIASES\n\naddUnitAlias('week', 'w');\naddUnitAlias('isoWeek', 'W');\n\n// PRIORITIES\n\naddUnitPriority('week', 5);\naddUnitPriority('isoWeek', 5);\n\n// PARSING\n\naddRegexToken('w',  match1to2);\naddRegexToken('ww', match1to2, match2);\naddRegexToken('W',  match1to2);\naddRegexToken('WW', match1to2, match2);\n\naddWeekParseToken(['w', 'ww', 'W', 'WW'], function (input, week, config, token) {\n    week[token.substr(0, 1)] = toInt(input);\n});\n\n// HELPERS\n\n// LOCALES\n\nfunction localeWeek (mom) {\n    return weekOfYear(mom, this._week.dow, this._week.doy).week;\n}\n\nvar defaultLocaleWeek = {\n    dow : 0, // Sunday is the first day of the week.\n    doy : 6  // The week that contains Jan 1st is the first week of the year.\n};\n\nfunction localeFirstDayOfWeek () {\n    return this._week.dow;\n}\n\nfunction localeFirstDayOfYear () {\n    return this._week.doy;\n}\n\n// MOMENTS\n\nfunction getSetWeek (input) {\n    var week = this.localeData().week(this);\n    return input == null ? week : this.add((input - week) * 7, 'd');\n}\n\nfunction getSetISOWeek (input) {\n    var week = weekOfYear(this, 1, 4).week;\n    return input == null ? week : this.add((input - week) * 7, 'd');\n}\n\n// FORMATTING\n\naddFormatToken('d', 0, 'do', 'day');\n\naddFormatToken('dd', 0, 0, function (format) {\n    return this.localeData().weekdaysMin(this, format);\n});\n\naddFormatToken('ddd', 0, 0, function (format) {\n    return this.localeData().weekdaysShort(this, format);\n});\n\naddFormatToken('dddd', 0, 0, function (format) {\n    return this.localeData().weekdays(this, format);\n});\n\naddFormatToken('e', 0, 0, 'weekday');\naddFormatToken('E', 0, 0, 'isoWeekday');\n\n// ALIASES\n\naddUnitAlias('day', 'd');\naddUnitAlias('weekday', 'e');\naddUnitAlias('isoWeekday', 'E');\n\n// PRIORITY\naddUnitPriority('day', 11);\naddUnitPriority('weekday', 11);\naddUnitPriority('isoWeekday', 11);\n\n// PARSING\n\naddRegexToken('d',    match1to2);\naddRegexToken('e',    match1to2);\naddRegexToken('E',    match1to2);\naddRegexToken('dd',   function (isStrict, locale) {\n    return locale.weekdaysMinRegex(isStrict);\n});\naddRegexToken('ddd',   function (isStrict, locale) {\n    return locale.weekdaysShortRegex(isStrict);\n});\naddRegexToken('dddd',   function (isStrict, locale) {\n    return locale.weekdaysRegex(isStrict);\n});\n\naddWeekParseToken(['dd', 'ddd', 'dddd'], function (input, week, config, token) {\n    var weekday = config._locale.weekdaysParse(input, token, config._strict);\n    // if we didn't get a weekday name, mark the date as invalid\n    if (weekday != null) {\n        week.d = weekday;\n    } else {\n        getParsingFlags(config).invalidWeekday = input;\n    }\n});\n\naddWeekParseToken(['d', 'e', 'E'], function (input, week, config, token) {\n    week[token] = toInt(input);\n});\n\n// HELPERS\n\nfunction parseWeekday(input, locale) {\n    if (typeof input !== 'string') {\n        return input;\n    }\n\n    if (!isNaN(input)) {\n        return parseInt(input, 10);\n    }\n\n    input = locale.weekdaysParse(input);\n    if (typeof input === 'number') {\n        return input;\n    }\n\n    return null;\n}\n\nfunction parseIsoWeekday(input, locale) {\n    if (typeof input === 'string') {\n        return locale.weekdaysParse(input) % 7 || 7;\n    }\n    return isNaN(input) ? null : input;\n}\n\n// LOCALES\n\nvar defaultLocaleWeekdays = 'Sunday_Monday_Tuesday_Wednesday_Thursday_Friday_Saturday'.split('_');\nfunction localeWeekdays (m, format) {\n    if (!m) {\n        return isArray(this._weekdays) ? this._weekdays :\n            this._weekdays['standalone'];\n    }\n    return isArray(this._weekdays) ? this._weekdays[m.day()] :\n        this._weekdays[this._weekdays.isFormat.test(format) ? 'format' : 'standalone'][m.day()];\n}\n\nvar defaultLocaleWeekdaysShort = 'Sun_Mon_Tue_Wed_Thu_Fri_Sat'.split('_');\nfunction localeWeekdaysShort (m) {\n    return (m) ? this._weekdaysShort[m.day()] : this._weekdaysShort;\n}\n\nvar defaultLocaleWeekdaysMin = 'Su_Mo_Tu_We_Th_Fr_Sa'.split('_');\nfunction localeWeekdaysMin (m) {\n    return (m) ? this._weekdaysMin[m.day()] : this._weekdaysMin;\n}\n\nfunction handleStrictParse$1(weekdayName, format, strict) {\n    var i, ii, mom, llc = weekdayName.toLocaleLowerCase();\n    if (!this._weekdaysParse) {\n        this._weekdaysParse = [];\n        this._shortWeekdaysParse = [];\n        this._minWeekdaysParse = [];\n\n        for (i = 0; i < 7; ++i) {\n            mom = createUTC([2000, 1]).day(i);\n            this._minWeekdaysParse[i] = this.weekdaysMin(mom, '').toLocaleLowerCase();\n            this._shortWeekdaysParse[i] = this.weekdaysShort(mom, '').toLocaleLowerCase();\n            this._weekdaysParse[i] = this.weekdays(mom, '').toLocaleLowerCase();\n        }\n    }\n\n    if (strict) {\n        if (format === 'dddd') {\n            ii = indexOf$1.call(this._weekdaysParse, llc);\n            return ii !== -1 ? ii : null;\n        } else if (format === 'ddd') {\n            ii = indexOf$1.call(this._shortWeekdaysParse, llc);\n            return ii !== -1 ? ii : null;\n        } else {\n            ii = indexOf$1.call(this._minWeekdaysParse, llc);\n            return ii !== -1 ? ii : null;\n        }\n    } else {\n        if (format === 'dddd') {\n            ii = indexOf$1.call(this._weekdaysParse, llc);\n            if (ii !== -1) {\n                return ii;\n            }\n            ii = indexOf$1.call(this._shortWeekdaysParse, llc);\n            if (ii !== -1) {\n                return ii;\n            }\n            ii = indexOf$1.call(this._minWeekdaysParse, llc);\n            return ii !== -1 ? ii : null;\n        } else if (format === 'ddd') {\n            ii = indexOf$1.call(this._shortWeekdaysParse, llc);\n            if (ii !== -1) {\n                return ii;\n            }\n            ii = indexOf$1.call(this._weekdaysParse, llc);\n            if (ii !== -1) {\n                return ii;\n            }\n            ii = indexOf$1.call(this._minWeekdaysParse, llc);\n            return ii !== -1 ? ii : null;\n        } else {\n            ii = indexOf$1.call(this._minWeekdaysParse, llc);\n            if (ii !== -1) {\n                return ii;\n            }\n            ii = indexOf$1.call(this._weekdaysParse, llc);\n            if (ii !== -1) {\n                return ii;\n            }\n            ii = indexOf$1.call(this._shortWeekdaysParse, llc);\n            return ii !== -1 ? ii : null;\n        }\n    }\n}\n\nfunction localeWeekdaysParse (weekdayName, format, strict) {\n    var i, mom, regex;\n\n    if (this._weekdaysParseExact) {\n        return handleStrictParse$1.call(this, weekdayName, format, strict);\n    }\n\n    if (!this._weekdaysParse) {\n        this._weekdaysParse = [];\n        this._minWeekdaysParse = [];\n        this._shortWeekdaysParse = [];\n        this._fullWeekdaysParse = [];\n    }\n\n    for (i = 0; i < 7; i++) {\n        // make the regex if we don't have it already\n\n        mom = createUTC([2000, 1]).day(i);\n        if (strict && !this._fullWeekdaysParse[i]) {\n            this._fullWeekdaysParse[i] = new RegExp('^' + this.weekdays(mom, '').replace('.', '\\.?') + '$', 'i');\n            this._shortWeekdaysParse[i] = new RegExp('^' + this.weekdaysShort(mom, '').replace('.', '\\.?') + '$', 'i');\n            this._minWeekdaysParse[i] = new RegExp('^' + this.weekdaysMin(mom, '').replace('.', '\\.?') + '$', 'i');\n        }\n        if (!this._weekdaysParse[i]) {\n            regex = '^' + this.weekdays(mom, '') + '|^' + this.weekdaysShort(mom, '') + '|^' + this.weekdaysMin(mom, '');\n            this._weekdaysParse[i] = new RegExp(regex.replace('.', ''), 'i');\n        }\n        // test the regex\n        if (strict && format === 'dddd' && this._fullWeekdaysParse[i].test(weekdayName)) {\n            return i;\n        } else if (strict && format === 'ddd' && this._shortWeekdaysParse[i].test(weekdayName)) {\n            return i;\n        } else if (strict && format === 'dd' && this._minWeekdaysParse[i].test(weekdayName)) {\n            return i;\n        } else if (!strict && this._weekdaysParse[i].test(weekdayName)) {\n            return i;\n        }\n    }\n}\n\n// MOMENTS\n\nfunction getSetDayOfWeek (input) {\n    if (!this.isValid()) {\n        return input != null ? this : NaN;\n    }\n    var day = this._isUTC ? this._d.getUTCDay() : this._d.getDay();\n    if (input != null) {\n        input = parseWeekday(input, this.localeData());\n        return this.add(input - day, 'd');\n    } else {\n        return day;\n    }\n}\n\nfunction getSetLocaleDayOfWeek (input) {\n    if (!this.isValid()) {\n        return input != null ? this : NaN;\n    }\n    var weekday = (this.day() + 7 - this.localeData()._week.dow) % 7;\n    return input == null ? weekday : this.add(input - weekday, 'd');\n}\n\nfunction getSetISODayOfWeek (input) {\n    if (!this.isValid()) {\n        return input != null ? this : NaN;\n    }\n\n    // behaves the same as moment#day except\n    // as a getter, returns 7 instead of 0 (1-7 range instead of 0-6)\n    // as a setter, sunday should belong to the previous week.\n\n    if (input != null) {\n        var weekday = parseIsoWeekday(input, this.localeData());\n        return this.day(this.day() % 7 ? weekday : weekday - 7);\n    } else {\n        return this.day() || 7;\n    }\n}\n\nvar defaultWeekdaysRegex = matchWord;\nfunction weekdaysRegex (isStrict) {\n    if (this._weekdaysParseExact) {\n        if (!hasOwnProp(this, '_weekdaysRegex')) {\n            computeWeekdaysParse.call(this);\n        }\n        if (isStrict) {\n            return this._weekdaysStrictRegex;\n        } else {\n            return this._weekdaysRegex;\n        }\n    } else {\n        if (!hasOwnProp(this, '_weekdaysRegex')) {\n            this._weekdaysRegex = defaultWeekdaysRegex;\n        }\n        return this._weekdaysStrictRegex && isStrict ?\n            this._weekdaysStrictRegex : this._weekdaysRegex;\n    }\n}\n\nvar defaultWeekdaysShortRegex = matchWord;\nfunction weekdaysShortRegex (isStrict) {\n    if (this._weekdaysParseExact) {\n        if (!hasOwnProp(this, '_weekdaysRegex')) {\n            computeWeekdaysParse.call(this);\n        }\n        if (isStrict) {\n            return this._weekdaysShortStrictRegex;\n        } else {\n            return this._weekdaysShortRegex;\n        }\n    } else {\n        if (!hasOwnProp(this, '_weekdaysShortRegex')) {\n            this._weekdaysShortRegex = defaultWeekdaysShortRegex;\n        }\n        return this._weekdaysShortStrictRegex && isStrict ?\n            this._weekdaysShortStrictRegex : this._weekdaysShortRegex;\n    }\n}\n\nvar defaultWeekdaysMinRegex = matchWord;\nfunction weekdaysMinRegex (isStrict) {\n    if (this._weekdaysParseExact) {\n        if (!hasOwnProp(this, '_weekdaysRegex')) {\n            computeWeekdaysParse.call(this);\n        }\n        if (isStrict) {\n            return this._weekdaysMinStrictRegex;\n        } else {\n            return this._weekdaysMinRegex;\n        }\n    } else {\n        if (!hasOwnProp(this, '_weekdaysMinRegex')) {\n            this._weekdaysMinRegex = defaultWeekdaysMinRegex;\n        }\n        return this._weekdaysMinStrictRegex && isStrict ?\n            this._weekdaysMinStrictRegex : this._weekdaysMinRegex;\n    }\n}\n\n\nfunction computeWeekdaysParse () {\n    function cmpLenRev(a, b) {\n        return b.length - a.length;\n    }\n\n    var minPieces = [], shortPieces = [], longPieces = [], mixedPieces = [],\n        i, mom, minp, shortp, longp;\n    for (i = 0; i < 7; i++) {\n        // make the regex if we don't have it already\n        mom = createUTC([2000, 1]).day(i);\n        minp = this.weekdaysMin(mom, '');\n        shortp = this.weekdaysShort(mom, '');\n        longp = this.weekdays(mom, '');\n        minPieces.push(minp);\n        shortPieces.push(shortp);\n        longPieces.push(longp);\n        mixedPieces.push(minp);\n        mixedPieces.push(shortp);\n        mixedPieces.push(longp);\n    }\n    // Sorting makes sure if one weekday (or abbr) is a prefix of another it\n    // will match the longer piece.\n    minPieces.sort(cmpLenRev);\n    shortPieces.sort(cmpLenRev);\n    longPieces.sort(cmpLenRev);\n    mixedPieces.sort(cmpLenRev);\n    for (i = 0; i < 7; i++) {\n        shortPieces[i] = regexEscape(shortPieces[i]);\n        longPieces[i] = regexEscape(longPieces[i]);\n        mixedPieces[i] = regexEscape(mixedPieces[i]);\n    }\n\n    this._weekdaysRegex = new RegExp('^(' + mixedPieces.join('|') + ')', 'i');\n    this._weekdaysShortRegex = this._weekdaysRegex;\n    this._weekdaysMinRegex = this._weekdaysRegex;\n\n    this._weekdaysStrictRegex = new RegExp('^(' + longPieces.join('|') + ')', 'i');\n    this._weekdaysShortStrictRegex = new RegExp('^(' + shortPieces.join('|') + ')', 'i');\n    this._weekdaysMinStrictRegex = new RegExp('^(' + minPieces.join('|') + ')', 'i');\n}\n\n// FORMATTING\n\nfunction hFormat() {\n    return this.hours() % 12 || 12;\n}\n\nfunction kFormat() {\n    return this.hours() || 24;\n}\n\naddFormatToken('H', ['HH', 2], 0, 'hour');\naddFormatToken('h', ['hh', 2], 0, hFormat);\naddFormatToken('k', ['kk', 2], 0, kFormat);\n\naddFormatToken('hmm', 0, 0, function () {\n    return '' + hFormat.apply(this) + zeroFill(this.minutes(), 2);\n});\n\naddFormatToken('hmmss', 0, 0, function () {\n    return '' + hFormat.apply(this) + zeroFill(this.minutes(), 2) +\n        zeroFill(this.seconds(), 2);\n});\n\naddFormatToken('Hmm', 0, 0, function () {\n    return '' + this.hours() + zeroFill(this.minutes(), 2);\n});\n\naddFormatToken('Hmmss', 0, 0, function () {\n    return '' + this.hours() + zeroFill(this.minutes(), 2) +\n        zeroFill(this.seconds(), 2);\n});\n\nfunction meridiem (token, lowercase) {\n    addFormatToken(token, 0, 0, function () {\n        return this.localeData().meridiem(this.hours(), this.minutes(), lowercase);\n    });\n}\n\nmeridiem('a', true);\nmeridiem('A', false);\n\n// ALIASES\n\naddUnitAlias('hour', 'h');\n\n// PRIORITY\naddUnitPriority('hour', 13);\n\n// PARSING\n\nfunction matchMeridiem (isStrict, locale) {\n    return locale._meridiemParse;\n}\n\naddRegexToken('a',  matchMeridiem);\naddRegexToken('A',  matchMeridiem);\naddRegexToken('H',  match1to2);\naddRegexToken('h',  match1to2);\naddRegexToken('k',  match1to2);\naddRegexToken('HH', match1to2, match2);\naddRegexToken('hh', match1to2, match2);\naddRegexToken('kk', match1to2, match2);\n\naddRegexToken('hmm', match3to4);\naddRegexToken('hmmss', match5to6);\naddRegexToken('Hmm', match3to4);\naddRegexToken('Hmmss', match5to6);\n\naddParseToken(['H', 'HH'], HOUR);\naddParseToken(['k', 'kk'], function (input, array, config) {\n    var kInput = toInt(input);\n    array[HOUR] = kInput === 24 ? 0 : kInput;\n});\naddParseToken(['a', 'A'], function (input, array, config) {\n    config._isPm = config._locale.isPM(input);\n    config._meridiem = input;\n});\naddParseToken(['h', 'hh'], function (input, array, config) {\n    array[HOUR] = toInt(input);\n    getParsingFlags(config).bigHour = true;\n});\naddParseToken('hmm', function (input, array, config) {\n    var pos = input.length - 2;\n    array[HOUR] = toInt(input.substr(0, pos));\n    array[MINUTE] = toInt(input.substr(pos));\n    getParsingFlags(config).bigHour = true;\n});\naddParseToken('hmmss', function (input, array, config) {\n    var pos1 = input.length - 4;\n    var pos2 = input.length - 2;\n    array[HOUR] = toInt(input.substr(0, pos1));\n    array[MINUTE] = toInt(input.substr(pos1, 2));\n    array[SECOND] = toInt(input.substr(pos2));\n    getParsingFlags(config).bigHour = true;\n});\naddParseToken('Hmm', function (input, array, config) {\n    var pos = input.length - 2;\n    array[HOUR] = toInt(input.substr(0, pos));\n    array[MINUTE] = toInt(input.substr(pos));\n});\naddParseToken('Hmmss', function (input, array, config) {\n    var pos1 = input.length - 4;\n    var pos2 = input.length - 2;\n    array[HOUR] = toInt(input.substr(0, pos1));\n    array[MINUTE] = toInt(input.substr(pos1, 2));\n    array[SECOND] = toInt(input.substr(pos2));\n});\n\n// LOCALES\n\nfunction localeIsPM (input) {\n    // IE8 Quirks Mode & IE7 Standards Mode do not allow accessing strings like arrays\n    // Using charAt should be more compatible.\n    return ((input + '').toLowerCase().charAt(0) === 'p');\n}\n\nvar defaultLocaleMeridiemParse = /[ap]\\.?m?\\.?/i;\nfunction localeMeridiem (hours, minutes, isLower) {\n    if (hours > 11) {\n        return isLower ? 'pm' : 'PM';\n    } else {\n        return isLower ? 'am' : 'AM';\n    }\n}\n\n\n// MOMENTS\n\n// Setting the hour should keep the time, because the user explicitly\n// specified which hour he wants. So trying to maintain the same hour (in\n// a new timezone) makes sense. Adding/subtracting hours does not follow\n// this rule.\nvar getSetHour = makeGetSet('Hours', true);\n\n// months\n// week\n// weekdays\n// meridiem\nvar baseConfig = {\n    calendar: defaultCalendar,\n    longDateFormat: defaultLongDateFormat,\n    invalidDate: defaultInvalidDate,\n    ordinal: defaultOrdinal,\n    dayOfMonthOrdinalParse: defaultDayOfMonthOrdinalParse,\n    relativeTime: defaultRelativeTime,\n\n    months: defaultLocaleMonths,\n    monthsShort: defaultLocaleMonthsShort,\n\n    week: defaultLocaleWeek,\n\n    weekdays: defaultLocaleWeekdays,\n    weekdaysMin: defaultLocaleWeekdaysMin,\n    weekdaysShort: defaultLocaleWeekdaysShort,\n\n    meridiemParse: defaultLocaleMeridiemParse\n};\n\n// internal storage for locale config files\nvar locales = {};\nvar localeFamilies = {};\nvar globalLocale;\n\nfunction normalizeLocale(key) {\n    return key ? key.toLowerCase().replace('_', '-') : key;\n}\n\n// pick the locale from the array\n// try ['en-au', 'en-gb'] as 'en-au', 'en-gb', 'en', as in move through the list trying each\n// substring from most specific to least, but move to the next array item if it's a more specific variant than the current root\nfunction chooseLocale(names) {\n    var i = 0, j, next, locale, split;\n\n    while (i < names.length) {\n        split = normalizeLocale(names[i]).split('-');\n        j = split.length;\n        next = normalizeLocale(names[i + 1]);\n        next = next ? next.split('-') : null;\n        while (j > 0) {\n            locale = loadLocale(split.slice(0, j).join('-'));\n            if (locale) {\n                return locale;\n            }\n            if (next && next.length >= j && compareArrays(split, next, true) >= j - 1) {\n                //the next array item is better than a shallower substring of this one\n                break;\n            }\n            j--;\n        }\n        i++;\n    }\n    return null;\n}\n\nfunction loadLocale(name) {\n    var oldLocale = null;\n    // TODO: Find a better way to register and load all the locales in Node\n    if (!locales[name] && (typeof module !== 'undefined') &&\n            module && module.exports) {\n        try {\n            oldLocale = globalLocale._abbr;\n            require('./locale/' + name);\n            // because defineLocale currently also sets the global locale, we\n            // want to undo that for lazy loaded locales\n            getSetGlobalLocale(oldLocale);\n        } catch (e) { }\n    }\n    return locales[name];\n}\n\n// This function will load locale and then set the global locale.  If\n// no arguments are passed in, it will simply return the current global\n// locale key.\nfunction getSetGlobalLocale (key, values) {\n    var data;\n    if (key) {\n        if (isUndefined(values)) {\n            data = getLocale(key);\n        }\n        else {\n            data = defineLocale(key, values);\n        }\n\n        if (data) {\n            // moment.duration._locale = moment._locale = data;\n            globalLocale = data;\n        }\n    }\n\n    return globalLocale._abbr;\n}\n\nfunction defineLocale (name, config) {\n    if (config !== null) {\n        var parentConfig = baseConfig;\n        config.abbr = name;\n        if (locales[name] != null) {\n            deprecateSimple('defineLocaleOverride',\n                    'use moment.updateLocale(localeName, config) to change ' +\n                    'an existing locale. moment.defineLocale(localeName, ' +\n                    'config) should only be used for creating a new locale ' +\n                    'See http://momentjs.com/guides/#/warnings/define-locale/ for more info.');\n            parentConfig = locales[name]._config;\n        } else if (config.parentLocale != null) {\n            if (locales[config.parentLocale] != null) {\n                parentConfig = locales[config.parentLocale]._config;\n            } else {\n                if (!localeFamilies[config.parentLocale]) {\n                    localeFamilies[config.parentLocale] = [];\n                }\n                localeFamilies[config.parentLocale].push({\n                    name: name,\n                    config: config\n                });\n                return null;\n            }\n        }\n        locales[name] = new Locale(mergeConfigs(parentConfig, config));\n\n        if (localeFamilies[name]) {\n            localeFamilies[name].forEach(function (x) {\n                defineLocale(x.name, x.config);\n            });\n        }\n\n        // backwards compat for now: also set the locale\n        // make sure we set the locale AFTER all child locales have been\n        // created, so we won't end up with the child locale set.\n        getSetGlobalLocale(name);\n\n\n        return locales[name];\n    } else {\n        // useful for testing\n        delete locales[name];\n        return null;\n    }\n}\n\nfunction updateLocale(name, config) {\n    if (config != null) {\n        var locale, parentConfig = baseConfig;\n        // MERGE\n        if (locales[name] != null) {\n            parentConfig = locales[name]._config;\n        }\n        config = mergeConfigs(parentConfig, config);\n        locale = new Locale(config);\n        locale.parentLocale = locales[name];\n        locales[name] = locale;\n\n        // backwards compat for now: also set the locale\n        getSetGlobalLocale(name);\n    } else {\n        // pass null for config to unupdate, useful for tests\n        if (locales[name] != null) {\n            if (locales[name].parentLocale != null) {\n                locales[name] = locales[name].parentLocale;\n            } else if (locales[name] != null) {\n                delete locales[name];\n            }\n        }\n    }\n    return locales[name];\n}\n\n// returns locale data\nfunction getLocale (key) {\n    var locale;\n\n    if (key && key._locale && key._locale._abbr) {\n        key = key._locale._abbr;\n    }\n\n    if (!key) {\n        return globalLocale;\n    }\n\n    if (!isArray(key)) {\n        //short-circuit everything else\n        locale = loadLocale(key);\n        if (locale) {\n            return locale;\n        }\n        key = [key];\n    }\n\n    return chooseLocale(key);\n}\n\nfunction listLocales() {\n    return keys$1(locales);\n}\n\nfunction checkOverflow (m) {\n    var overflow;\n    var a = m._a;\n\n    if (a && getParsingFlags(m).overflow === -2) {\n        overflow =\n            a[MONTH]       < 0 || a[MONTH]       > 11  ? MONTH :\n            a[DATE]        < 1 || a[DATE]        > daysInMonth(a[YEAR], a[MONTH]) ? DATE :\n            a[HOUR]        < 0 || a[HOUR]        > 24 || (a[HOUR] === 24 && (a[MINUTE] !== 0 || a[SECOND] !== 0 || a[MILLISECOND] !== 0)) ? HOUR :\n            a[MINUTE]      < 0 || a[MINUTE]      > 59  ? MINUTE :\n            a[SECOND]      < 0 || a[SECOND]      > 59  ? SECOND :\n            a[MILLISECOND] < 0 || a[MILLISECOND] > 999 ? MILLISECOND :\n            -1;\n\n        if (getParsingFlags(m)._overflowDayOfYear && (overflow < YEAR || overflow > DATE)) {\n            overflow = DATE;\n        }\n        if (getParsingFlags(m)._overflowWeeks && overflow === -1) {\n            overflow = WEEK;\n        }\n        if (getParsingFlags(m)._overflowWeekday && overflow === -1) {\n            overflow = WEEKDAY;\n        }\n\n        getParsingFlags(m).overflow = overflow;\n    }\n\n    return m;\n}\n\n// iso 8601 regex\n// 0000-00-00 0000-W00 or 0000-W00-0 + T + 00 or 00:00 or 00:00:00 or 00:00:00.000 + +00:00 or +0000 or +00)\nvar extendedIsoRegex = /^\\s*((?:[+-]\\d{6}|\\d{4})-(?:\\d\\d-\\d\\d|W\\d\\d-\\d|W\\d\\d|\\d\\d\\d|\\d\\d))(?:(T| )(\\d\\d(?::\\d\\d(?::\\d\\d(?:[.,]\\d+)?)?)?)([\\+\\-]\\d\\d(?::?\\d\\d)?|\\s*Z)?)?$/;\nvar basicIsoRegex = /^\\s*((?:[+-]\\d{6}|\\d{4})(?:\\d\\d\\d\\d|W\\d\\d\\d|W\\d\\d|\\d\\d\\d|\\d\\d))(?:(T| )(\\d\\d(?:\\d\\d(?:\\d\\d(?:[.,]\\d+)?)?)?)([\\+\\-]\\d\\d(?::?\\d\\d)?|\\s*Z)?)?$/;\n\nvar tzRegex = /Z|[+-]\\d\\d(?::?\\d\\d)?/;\n\nvar isoDates = [\n    ['YYYYYY-MM-DD', /[+-]\\d{6}-\\d\\d-\\d\\d/],\n    ['YYYY-MM-DD', /\\d{4}-\\d\\d-\\d\\d/],\n    ['GGGG-[W]WW-E', /\\d{4}-W\\d\\d-\\d/],\n    ['GGGG-[W]WW', /\\d{4}-W\\d\\d/, false],\n    ['YYYY-DDD', /\\d{4}-\\d{3}/],\n    ['YYYY-MM', /\\d{4}-\\d\\d/, false],\n    ['YYYYYYMMDD', /[+-]\\d{10}/],\n    ['YYYYMMDD', /\\d{8}/],\n    // YYYYMM is NOT allowed by the standard\n    ['GGGG[W]WWE', /\\d{4}W\\d{3}/],\n    ['GGGG[W]WW', /\\d{4}W\\d{2}/, false],\n    ['YYYYDDD', /\\d{7}/]\n];\n\n// iso time formats and regexes\nvar isoTimes = [\n    ['HH:mm:ss.SSSS', /\\d\\d:\\d\\d:\\d\\d\\.\\d+/],\n    ['HH:mm:ss,SSSS', /\\d\\d:\\d\\d:\\d\\d,\\d+/],\n    ['HH:mm:ss', /\\d\\d:\\d\\d:\\d\\d/],\n    ['HH:mm', /\\d\\d:\\d\\d/],\n    ['HHmmss.SSSS', /\\d\\d\\d\\d\\d\\d\\.\\d+/],\n    ['HHmmss,SSSS', /\\d\\d\\d\\d\\d\\d,\\d+/],\n    ['HHmmss', /\\d\\d\\d\\d\\d\\d/],\n    ['HHmm', /\\d\\d\\d\\d/],\n    ['HH', /\\d\\d/]\n];\n\nvar aspNetJsonRegex = /^\\/?Date\\((\\-?\\d+)/i;\n\n// date from iso format\nfunction configFromISO(config) {\n    var i, l,\n        string = config._i,\n        match = extendedIsoRegex.exec(string) || basicIsoRegex.exec(string),\n        allowTime, dateFormat, timeFormat, tzFormat;\n\n    if (match) {\n        getParsingFlags(config).iso = true;\n\n        for (i = 0, l = isoDates.length; i < l; i++) {\n            if (isoDates[i][1].exec(match[1])) {\n                dateFormat = isoDates[i][0];\n                allowTime = isoDates[i][2] !== false;\n                break;\n            }\n        }\n        if (dateFormat == null) {\n            config._isValid = false;\n            return;\n        }\n        if (match[3]) {\n            for (i = 0, l = isoTimes.length; i < l; i++) {\n                if (isoTimes[i][1].exec(match[3])) {\n                    // match[2] should be 'T' or space\n                    timeFormat = (match[2] || ' ') + isoTimes[i][0];\n                    break;\n                }\n            }\n            if (timeFormat == null) {\n                config._isValid = false;\n                return;\n            }\n        }\n        if (!allowTime && timeFormat != null) {\n            config._isValid = false;\n            return;\n        }\n        if (match[4]) {\n            if (tzRegex.exec(match[4])) {\n                tzFormat = 'Z';\n            } else {\n                config._isValid = false;\n                return;\n            }\n        }\n        config._f = dateFormat + (timeFormat || '') + (tzFormat || '');\n        configFromStringAndFormat(config);\n    } else {\n        config._isValid = false;\n    }\n}\n\n// RFC 2822 regex: For details see https://tools.ietf.org/html/rfc2822#section-3.3\nvar basicRfcRegex = /^((?:Mon|Tue|Wed|Thu|Fri|Sat|Sun),?\\s)?(\\d?\\d\\s(?:Jan|Feb|Mar|Apr|May|Jun|Jul|Aug|Sep|Oct|Nov|Dec)\\s(?:\\d\\d)?\\d\\d\\s)(\\d\\d:\\d\\d)(\\:\\d\\d)?(\\s(?:UT|GMT|[ECMP][SD]T|[A-IK-Za-ik-z]|[+-]\\d{4}))$/;\n\n// date and time from ref 2822 format\nfunction configFromRFC2822(config) {\n    var string, match, dayFormat,\n        dateFormat, timeFormat, tzFormat;\n    var timezones = {\n        ' GMT': ' +0000',\n        ' EDT': ' -0400',\n        ' EST': ' -0500',\n        ' CDT': ' -0500',\n        ' CST': ' -0600',\n        ' MDT': ' -0600',\n        ' MST': ' -0700',\n        ' PDT': ' -0700',\n        ' PST': ' -0800'\n    };\n    var military = 'YXWVUTSRQPONZABCDEFGHIKLM';\n    var timezone, timezoneIndex;\n\n    string = config._i\n        .replace(/\\([^\\)]*\\)|[\\n\\t]/g, ' ') // Remove comments and folding whitespace\n        .replace(/(\\s\\s+)/g, ' ') // Replace multiple-spaces with a single space\n        .replace(/^\\s|\\s$/g, ''); // Remove leading and trailing spaces\n    match = basicRfcRegex.exec(string);\n\n    if (match) {\n        dayFormat = match[1] ? 'ddd' + ((match[1].length === 5) ? ', ' : ' ') : '';\n        dateFormat = 'D MMM ' + ((match[2].length > 10) ? 'YYYY ' : 'YY ');\n        timeFormat = 'HH:mm' + (match[4] ? ':ss' : '');\n\n        // TODO: Replace the vanilla JS Date object with an indepentent day-of-week check.\n        if (match[1]) { // day of week given\n            var momentDate = new Date(match[2]);\n            var momentDay = ['Sun','Mon','Tue','Wed','Thu','Fri','Sat'][momentDate.getDay()];\n\n            if (match[1].substr(0,3) !== momentDay) {\n                getParsingFlags(config).weekdayMismatch = true;\n                config._isValid = false;\n                return;\n            }\n        }\n\n        switch (match[5].length) {\n            case 2: // military\n                if (timezoneIndex === 0) {\n                    timezone = ' +0000';\n                } else {\n                    timezoneIndex = military.indexOf(match[5][1].toUpperCase()) - 12;\n                    timezone = ((timezoneIndex < 0) ? ' -' : ' +') +\n                        (('' + timezoneIndex).replace(/^-?/, '0')).match(/..$/)[0] + '00';\n                }\n                break;\n            case 4: // Zone\n                timezone = timezones[match[5]];\n                break;\n            default: // UT or +/-9999\n                timezone = timezones[' GMT'];\n        }\n        match[5] = timezone;\n        config._i = match.splice(1).join('');\n        tzFormat = ' ZZ';\n        config._f = dayFormat + dateFormat + timeFormat + tzFormat;\n        configFromStringAndFormat(config);\n        getParsingFlags(config).rfc2822 = true;\n    } else {\n        config._isValid = false;\n    }\n}\n\n// date from iso format or fallback\nfunction configFromString(config) {\n    var matched = aspNetJsonRegex.exec(config._i);\n\n    if (matched !== null) {\n        config._d = new Date(+matched[1]);\n        return;\n    }\n\n    configFromISO(config);\n    if (config._isValid === false) {\n        delete config._isValid;\n    } else {\n        return;\n    }\n\n    configFromRFC2822(config);\n    if (config._isValid === false) {\n        delete config._isValid;\n    } else {\n        return;\n    }\n\n    // Final attempt, use Input Fallback\n    hooks.createFromInputFallback(config);\n}\n\nhooks.createFromInputFallback = deprecate(\n    'value provided is not in a recognized RFC2822 or ISO format. moment construction falls back to js Date(), ' +\n    'which is not reliable across all browsers and versions. Non RFC2822/ISO date formats are ' +\n    'discouraged and will be removed in an upcoming major release. Please refer to ' +\n    'http://momentjs.com/guides/#/warnings/js-date/ for more info.',\n    function (config) {\n        config._d = new Date(config._i + (config._useUTC ? ' UTC' : ''));\n    }\n);\n\n// Pick the first defined of two or three arguments.\nfunction defaults(a, b, c) {\n    if (a != null) {\n        return a;\n    }\n    if (b != null) {\n        return b;\n    }\n    return c;\n}\n\nfunction currentDateArray(config) {\n    // hooks is actually the exported moment object\n    var nowValue = new Date(hooks.now());\n    if (config._useUTC) {\n        return [nowValue.getUTCFullYear(), nowValue.getUTCMonth(), nowValue.getUTCDate()];\n    }\n    return [nowValue.getFullYear(), nowValue.getMonth(), nowValue.getDate()];\n}\n\n// convert an array to a date.\n// the array should mirror the parameters below\n// note: all values past the year are optional and will default to the lowest possible value.\n// [year, month, day , hour, minute, second, millisecond]\nfunction configFromArray (config) {\n    var i, date, input = [], currentDate, yearToUse;\n\n    if (config._d) {\n        return;\n    }\n\n    currentDate = currentDateArray(config);\n\n    //compute day of the year from weeks and weekdays\n    if (config._w && config._a[DATE] == null && config._a[MONTH] == null) {\n        dayOfYearFromWeekInfo(config);\n    }\n\n    //if the day of the year is set, figure out what it is\n    if (config._dayOfYear != null) {\n        yearToUse = defaults(config._a[YEAR], currentDate[YEAR]);\n\n        if (config._dayOfYear > daysInYear(yearToUse) || config._dayOfYear === 0) {\n            getParsingFlags(config)._overflowDayOfYear = true;\n        }\n\n        date = createUTCDate(yearToUse, 0, config._dayOfYear);\n        config._a[MONTH] = date.getUTCMonth();\n        config._a[DATE] = date.getUTCDate();\n    }\n\n    // Default to current date.\n    // * if no year, month, day of month are given, default to today\n    // * if day of month is given, default month and year\n    // * if month is given, default only year\n    // * if year is given, don't default anything\n    for (i = 0; i < 3 && config._a[i] == null; ++i) {\n        config._a[i] = input[i] = currentDate[i];\n    }\n\n    // Zero out whatever was not defaulted, including time\n    for (; i < 7; i++) {\n        config._a[i] = input[i] = (config._a[i] == null) ? (i === 2 ? 1 : 0) : config._a[i];\n    }\n\n    // Check for 24:00:00.000\n    if (config._a[HOUR] === 24 &&\n            config._a[MINUTE] === 0 &&\n            config._a[SECOND] === 0 &&\n            config._a[MILLISECOND] === 0) {\n        config._nextDay = true;\n        config._a[HOUR] = 0;\n    }\n\n    config._d = (config._useUTC ? createUTCDate : createDate).apply(null, input);\n    // Apply timezone offset from input. The actual utcOffset can be changed\n    // with parseZone.\n    if (config._tzm != null) {\n        config._d.setUTCMinutes(config._d.getUTCMinutes() - config._tzm);\n    }\n\n    if (config._nextDay) {\n        config._a[HOUR] = 24;\n    }\n}\n\nfunction dayOfYearFromWeekInfo(config) {\n    var w, weekYear, week, weekday, dow, doy, temp, weekdayOverflow;\n\n    w = config._w;\n    if (w.GG != null || w.W != null || w.E != null) {\n        dow = 1;\n        doy = 4;\n\n        // TODO: We need to take the current isoWeekYear, but that depends on\n        // how we interpret now (local, utc, fixed offset). So create\n        // a now version of current config (take local/utc/offset flags, and\n        // create now).\n        weekYear = defaults(w.GG, config._a[YEAR], weekOfYear(createLocal(), 1, 4).year);\n        week = defaults(w.W, 1);\n        weekday = defaults(w.E, 1);\n        if (weekday < 1 || weekday > 7) {\n            weekdayOverflow = true;\n        }\n    } else {\n        dow = config._locale._week.dow;\n        doy = config._locale._week.doy;\n\n        var curWeek = weekOfYear(createLocal(), dow, doy);\n\n        weekYear = defaults(w.gg, config._a[YEAR], curWeek.year);\n\n        // Default to current week.\n        week = defaults(w.w, curWeek.week);\n\n        if (w.d != null) {\n            // weekday -- low day numbers are considered next week\n            weekday = w.d;\n            if (weekday < 0 || weekday > 6) {\n                weekdayOverflow = true;\n            }\n        } else if (w.e != null) {\n            // local weekday -- counting starts from begining of week\n            weekday = w.e + dow;\n            if (w.e < 0 || w.e > 6) {\n                weekdayOverflow = true;\n            }\n        } else {\n            // default to begining of week\n            weekday = dow;\n        }\n    }\n    if (week < 1 || week > weeksInYear(weekYear, dow, doy)) {\n        getParsingFlags(config)._overflowWeeks = true;\n    } else if (weekdayOverflow != null) {\n        getParsingFlags(config)._overflowWeekday = true;\n    } else {\n        temp = dayOfYearFromWeeks(weekYear, week, weekday, dow, doy);\n        config._a[YEAR] = temp.year;\n        config._dayOfYear = temp.dayOfYear;\n    }\n}\n\n// constant that refers to the ISO standard\nhooks.ISO_8601 = function () {};\n\n// constant that refers to the RFC 2822 form\nhooks.RFC_2822 = function () {};\n\n// date from string and format string\nfunction configFromStringAndFormat(config) {\n    // TODO: Move this to another part of the creation flow to prevent circular deps\n    if (config._f === hooks.ISO_8601) {\n        configFromISO(config);\n        return;\n    }\n    if (config._f === hooks.RFC_2822) {\n        configFromRFC2822(config);\n        return;\n    }\n    config._a = [];\n    getParsingFlags(config).empty = true;\n\n    // This array is used to make a Date, either with `new Date` or `Date.UTC`\n    var string = '' + config._i,\n        i, parsedInput, tokens, token, skipped,\n        stringLength = string.length,\n        totalParsedInputLength = 0;\n\n    tokens = expandFormat(config._f, config._locale).match(formattingTokens) || [];\n\n    for (i = 0; i < tokens.length; i++) {\n        token = tokens[i];\n        parsedInput = (string.match(getParseRegexForToken(token, config)) || [])[0];\n        // console.log('token', token, 'parsedInput', parsedInput,\n        //         'regex', getParseRegexForToken(token, config));\n        if (parsedInput) {\n            skipped = string.substr(0, string.indexOf(parsedInput));\n            if (skipped.length > 0) {\n                getParsingFlags(config).unusedInput.push(skipped);\n            }\n            string = string.slice(string.indexOf(parsedInput) + parsedInput.length);\n            totalParsedInputLength += parsedInput.length;\n        }\n        // don't parse if it's not a known token\n        if (formatTokenFunctions[token]) {\n            if (parsedInput) {\n                getParsingFlags(config).empty = false;\n            }\n            else {\n                getParsingFlags(config).unusedTokens.push(token);\n            }\n            addTimeToArrayFromToken(token, parsedInput, config);\n        }\n        else if (config._strict && !parsedInput) {\n            getParsingFlags(config).unusedTokens.push(token);\n        }\n    }\n\n    // add remaining unparsed input length to the string\n    getParsingFlags(config).charsLeftOver = stringLength - totalParsedInputLength;\n    if (string.length > 0) {\n        getParsingFlags(config).unusedInput.push(string);\n    }\n\n    // clear _12h flag if hour is <= 12\n    if (config._a[HOUR] <= 12 &&\n        getParsingFlags(config).bigHour === true &&\n        config._a[HOUR] > 0) {\n        getParsingFlags(config).bigHour = undefined;\n    }\n\n    getParsingFlags(config).parsedDateParts = config._a.slice(0);\n    getParsingFlags(config).meridiem = config._meridiem;\n    // handle meridiem\n    config._a[HOUR] = meridiemFixWrap(config._locale, config._a[HOUR], config._meridiem);\n\n    configFromArray(config);\n    checkOverflow(config);\n}\n\n\nfunction meridiemFixWrap (locale, hour, meridiem) {\n    var isPm;\n\n    if (meridiem == null) {\n        // nothing to do\n        return hour;\n    }\n    if (locale.meridiemHour != null) {\n        return locale.meridiemHour(hour, meridiem);\n    } else if (locale.isPM != null) {\n        // Fallback\n        isPm = locale.isPM(meridiem);\n        if (isPm && hour < 12) {\n            hour += 12;\n        }\n        if (!isPm && hour === 12) {\n            hour = 0;\n        }\n        return hour;\n    } else {\n        // this is not supposed to happen\n        return hour;\n    }\n}\n\n// date from string and array of format strings\nfunction configFromStringAndArray(config) {\n    var tempConfig,\n        bestMoment,\n\n        scoreToBeat,\n        i,\n        currentScore;\n\n    if (config._f.length === 0) {\n        getParsingFlags(config).invalidFormat = true;\n        config._d = new Date(NaN);\n        return;\n    }\n\n    for (i = 0; i < config._f.length; i++) {\n        currentScore = 0;\n        tempConfig = copyConfig({}, config);\n        if (config._useUTC != null) {\n            tempConfig._useUTC = config._useUTC;\n        }\n        tempConfig._f = config._f[i];\n        configFromStringAndFormat(tempConfig);\n\n        if (!isValid(tempConfig)) {\n            continue;\n        }\n\n        // if there is any input that was not parsed add a penalty for that format\n        currentScore += getParsingFlags(tempConfig).charsLeftOver;\n\n        //or tokens\n        currentScore += getParsingFlags(tempConfig).unusedTokens.length * 10;\n\n        getParsingFlags(tempConfig).score = currentScore;\n\n        if (scoreToBeat == null || currentScore < scoreToBeat) {\n            scoreToBeat = currentScore;\n            bestMoment = tempConfig;\n        }\n    }\n\n    extend(config, bestMoment || tempConfig);\n}\n\nfunction configFromObject(config) {\n    if (config._d) {\n        return;\n    }\n\n    var i = normalizeObjectUnits(config._i);\n    config._a = map([i.year, i.month, i.day || i.date, i.hour, i.minute, i.second, i.millisecond], function (obj) {\n        return obj && parseInt(obj, 10);\n    });\n\n    configFromArray(config);\n}\n\nfunction createFromConfig (config) {\n    var res = new Moment(checkOverflow(prepareConfig(config)));\n    if (res._nextDay) {\n        // Adding is smart enough around DST\n        res.add(1, 'd');\n        res._nextDay = undefined;\n    }\n\n    return res;\n}\n\nfunction prepareConfig (config) {\n    var input = config._i,\n        format = config._f;\n\n    config._locale = config._locale || getLocale(config._l);\n\n    if (input === null || (format === undefined && input === '')) {\n        return createInvalid({nullInput: true});\n    }\n\n    if (typeof input === 'string') {\n        config._i = input = config._locale.preparse(input);\n    }\n\n    if (isMoment(input)) {\n        return new Moment(checkOverflow(input));\n    } else if (isDate(input)) {\n        config._d = input;\n    } else if (isArray(format)) {\n        configFromStringAndArray(config);\n    } else if (format) {\n        configFromStringAndFormat(config);\n    }  else {\n        configFromInput(config);\n    }\n\n    if (!isValid(config)) {\n        config._d = null;\n    }\n\n    return config;\n}\n\nfunction configFromInput(config) {\n    var input = config._i;\n    if (isUndefined(input)) {\n        config._d = new Date(hooks.now());\n    } else if (isDate(input)) {\n        config._d = new Date(input.valueOf());\n    } else if (typeof input === 'string') {\n        configFromString(config);\n    } else if (isArray(input)) {\n        config._a = map(input.slice(0), function (obj) {\n            return parseInt(obj, 10);\n        });\n        configFromArray(config);\n    } else if (isObject(input)) {\n        configFromObject(config);\n    } else if (isNumber(input)) {\n        // from milliseconds\n        config._d = new Date(input);\n    } else {\n        hooks.createFromInputFallback(config);\n    }\n}\n\nfunction createLocalOrUTC (input, format, locale, strict, isUTC) {\n    var c = {};\n\n    if (locale === true || locale === false) {\n        strict = locale;\n        locale = undefined;\n    }\n\n    if ((isObject(input) && isObjectEmpty(input)) ||\n            (isArray(input) && input.length === 0)) {\n        input = undefined;\n    }\n    // object construction must be done this way.\n    // https://github.com/moment/moment/issues/1423\n    c._isAMomentObject = true;\n    c._useUTC = c._isUTC = isUTC;\n    c._l = locale;\n    c._i = input;\n    c._f = format;\n    c._strict = strict;\n\n    return createFromConfig(c);\n}\n\nfunction createLocal (input, format, locale, strict) {\n    return createLocalOrUTC(input, format, locale, strict, false);\n}\n\nvar prototypeMin = deprecate(\n    'moment().min is deprecated, use moment.max instead. http://momentjs.com/guides/#/warnings/min-max/',\n    function () {\n        var other = createLocal.apply(null, arguments);\n        if (this.isValid() && other.isValid()) {\n            return other < this ? this : other;\n        } else {\n            return createInvalid();\n        }\n    }\n);\n\nvar prototypeMax = deprecate(\n    'moment().max is deprecated, use moment.min instead. http://momentjs.com/guides/#/warnings/min-max/',\n    function () {\n        var other = createLocal.apply(null, arguments);\n        if (this.isValid() && other.isValid()) {\n            return other > this ? this : other;\n        } else {\n            return createInvalid();\n        }\n    }\n);\n\n// Pick a moment m from moments so that m[fn](other) is true for all\n// other. This relies on the function fn to be transitive.\n//\n// moments should either be an array of moment objects or an array, whose\n// first element is an array of moment objects.\nfunction pickBy(fn, moments) {\n    var res, i;\n    if (moments.length === 1 && isArray(moments[0])) {\n        moments = moments[0];\n    }\n    if (!moments.length) {\n        return createLocal();\n    }\n    res = moments[0];\n    for (i = 1; i < moments.length; ++i) {\n        if (!moments[i].isValid() || moments[i][fn](res)) {\n            res = moments[i];\n        }\n    }\n    return res;\n}\n\n// TODO: Use [].sort instead?\nfunction min () {\n    var args = [].slice.call(arguments, 0);\n\n    return pickBy('isBefore', args);\n}\n\nfunction max () {\n    var args = [].slice.call(arguments, 0);\n\n    return pickBy('isAfter', args);\n}\n\nvar now = function () {\n    return Date.now ? Date.now() : +(new Date());\n};\n\nvar ordering = ['year', 'quarter', 'month', 'week', 'day', 'hour', 'minute', 'second', 'millisecond'];\n\nfunction isDurationValid(m) {\n    for (var key in m) {\n        if (!(ordering.indexOf(key) !== -1 && (m[key] == null || !isNaN(m[key])))) {\n            return false;\n        }\n    }\n\n    var unitHasDecimal = false;\n    for (var i = 0; i < ordering.length; ++i) {\n        if (m[ordering[i]]) {\n            if (unitHasDecimal) {\n                return false; // only allow non-integers for smallest unit\n            }\n            if (parseFloat(m[ordering[i]]) !== toInt(m[ordering[i]])) {\n                unitHasDecimal = true;\n            }\n        }\n    }\n\n    return true;\n}\n\nfunction isValid$1() {\n    return this._isValid;\n}\n\nfunction createInvalid$1() {\n    return createDuration(NaN);\n}\n\nfunction Duration (duration) {\n    var normalizedInput = normalizeObjectUnits(duration),\n        years = normalizedInput.year || 0,\n        quarters = normalizedInput.quarter || 0,\n        months = normalizedInput.month || 0,\n        weeks = normalizedInput.week || 0,\n        days = normalizedInput.day || 0,\n        hours = normalizedInput.hour || 0,\n        minutes = normalizedInput.minute || 0,\n        seconds = normalizedInput.second || 0,\n        milliseconds = normalizedInput.millisecond || 0;\n\n    this._isValid = isDurationValid(normalizedInput);\n\n    // representation for dateAddRemove\n    this._milliseconds = +milliseconds +\n        seconds * 1e3 + // 1000\n        minutes * 6e4 + // 1000 * 60\n        hours * 1000 * 60 * 60; //using 1000 * 60 * 60 instead of 36e5 to avoid floating point rounding errors https://github.com/moment/moment/issues/2978\n    // Because of dateAddRemove treats 24 hours as different from a\n    // day when working around DST, we need to store them separately\n    this._days = +days +\n        weeks * 7;\n    // It is impossible translate months into days without knowing\n    // which months you are are talking about, so we have to store\n    // it separately.\n    this._months = +months +\n        quarters * 3 +\n        years * 12;\n\n    this._data = {};\n\n    this._locale = getLocale();\n\n    this._bubble();\n}\n\nfunction isDuration (obj) {\n    return obj instanceof Duration;\n}\n\nfunction absRound (number) {\n    if (number < 0) {\n        return Math.round(-1 * number) * -1;\n    } else {\n        return Math.round(number);\n    }\n}\n\n// FORMATTING\n\nfunction offset (token, separator) {\n    addFormatToken(token, 0, 0, function () {\n        var offset = this.utcOffset();\n        var sign = '+';\n        if (offset < 0) {\n            offset = -offset;\n            sign = '-';\n        }\n        return sign + zeroFill(~~(offset / 60), 2) + separator + zeroFill(~~(offset) % 60, 2);\n    });\n}\n\noffset('Z', ':');\noffset('ZZ', '');\n\n// PARSING\n\naddRegexToken('Z',  matchShortOffset);\naddRegexToken('ZZ', matchShortOffset);\naddParseToken(['Z', 'ZZ'], function (input, array, config) {\n    config._useUTC = true;\n    config._tzm = offsetFromString(matchShortOffset, input);\n});\n\n// HELPERS\n\n// timezone chunker\n// '+10:00' > ['10',  '00']\n// '-1530'  > ['-15', '30']\nvar chunkOffset = /([\\+\\-]|\\d\\d)/gi;\n\nfunction offsetFromString(matcher, string) {\n    var matches = (string || '').match(matcher);\n\n    if (matches === null) {\n        return null;\n    }\n\n    var chunk   = matches[matches.length - 1] || [];\n    var parts   = (chunk + '').match(chunkOffset) || ['-', 0, 0];\n    var minutes = +(parts[1] * 60) + toInt(parts[2]);\n\n    return minutes === 0 ?\n      0 :\n      parts[0] === '+' ? minutes : -minutes;\n}\n\n// Return a moment from input, that is local/utc/zone equivalent to model.\nfunction cloneWithOffset(input, model) {\n    var res, diff;\n    if (model._isUTC) {\n        res = model.clone();\n        diff = (isMoment(input) || isDate(input) ? input.valueOf() : createLocal(input).valueOf()) - res.valueOf();\n        // Use low-level api, because this fn is low-level api.\n        res._d.setTime(res._d.valueOf() + diff);\n        hooks.updateOffset(res, false);\n        return res;\n    } else {\n        return createLocal(input).local();\n    }\n}\n\nfunction getDateOffset (m) {\n    // On Firefox.24 Date#getTimezoneOffset returns a floating point.\n    // https://github.com/moment/moment/pull/1871\n    return -Math.round(m._d.getTimezoneOffset() / 15) * 15;\n}\n\n// HOOKS\n\n// This function will be called whenever a moment is mutated.\n// It is intended to keep the offset in sync with the timezone.\nhooks.updateOffset = function () {};\n\n// MOMENTS\n\n// keepLocalTime = true means only change the timezone, without\n// affecting the local hour. So 5:31:26 +0300 --[utcOffset(2, true)]-->\n// 5:31:26 +0200 It is possible that 5:31:26 doesn't exist with offset\n// +0200, so we adjust the time as needed, to be valid.\n//\n// Keeping the time actually adds/subtracts (one hour)\n// from the actual represented time. That is why we call updateOffset\n// a second time. In case it wants us to change the offset again\n// _changeInProgress == true case, then we have to adjust, because\n// there is no such time in the given timezone.\nfunction getSetOffset (input, keepLocalTime, keepMinutes) {\n    var offset = this._offset || 0,\n        localAdjust;\n    if (!this.isValid()) {\n        return input != null ? this : NaN;\n    }\n    if (input != null) {\n        if (typeof input === 'string') {\n            input = offsetFromString(matchShortOffset, input);\n            if (input === null) {\n                return this;\n            }\n        } else if (Math.abs(input) < 16 && !keepMinutes) {\n            input = input * 60;\n        }\n        if (!this._isUTC && keepLocalTime) {\n            localAdjust = getDateOffset(this);\n        }\n        this._offset = input;\n        this._isUTC = true;\n        if (localAdjust != null) {\n            this.add(localAdjust, 'm');\n        }\n        if (offset !== input) {\n            if (!keepLocalTime || this._changeInProgress) {\n                addSubtract(this, createDuration(input - offset, 'm'), 1, false);\n            } else if (!this._changeInProgress) {\n                this._changeInProgress = true;\n                hooks.updateOffset(this, true);\n                this._changeInProgress = null;\n            }\n        }\n        return this;\n    } else {\n        return this._isUTC ? offset : getDateOffset(this);\n    }\n}\n\nfunction getSetZone (input, keepLocalTime) {\n    if (input != null) {\n        if (typeof input !== 'string') {\n            input = -input;\n        }\n\n        this.utcOffset(input, keepLocalTime);\n\n        return this;\n    } else {\n        return -this.utcOffset();\n    }\n}\n\nfunction setOffsetToUTC (keepLocalTime) {\n    return this.utcOffset(0, keepLocalTime);\n}\n\nfunction setOffsetToLocal (keepLocalTime) {\n    if (this._isUTC) {\n        this.utcOffset(0, keepLocalTime);\n        this._isUTC = false;\n\n        if (keepLocalTime) {\n            this.subtract(getDateOffset(this), 'm');\n        }\n    }\n    return this;\n}\n\nfunction setOffsetToParsedOffset () {\n    if (this._tzm != null) {\n        this.utcOffset(this._tzm, false, true);\n    } else if (typeof this._i === 'string') {\n        var tZone = offsetFromString(matchOffset, this._i);\n        if (tZone != null) {\n            this.utcOffset(tZone);\n        }\n        else {\n            this.utcOffset(0, true);\n        }\n    }\n    return this;\n}\n\nfunction hasAlignedHourOffset (input) {\n    if (!this.isValid()) {\n        return false;\n    }\n    input = input ? createLocal(input).utcOffset() : 0;\n\n    return (this.utcOffset() - input) % 60 === 0;\n}\n\nfunction isDaylightSavingTime () {\n    return (\n        this.utcOffset() > this.clone().month(0).utcOffset() ||\n        this.utcOffset() > this.clone().month(5).utcOffset()\n    );\n}\n\nfunction isDaylightSavingTimeShifted () {\n    if (!isUndefined(this._isDSTShifted)) {\n        return this._isDSTShifted;\n    }\n\n    var c = {};\n\n    copyConfig(c, this);\n    c = prepareConfig(c);\n\n    if (c._a) {\n        var other = c._isUTC ? createUTC(c._a) : createLocal(c._a);\n        this._isDSTShifted = this.isValid() &&\n            compareArrays(c._a, other.toArray()) > 0;\n    } else {\n        this._isDSTShifted = false;\n    }\n\n    return this._isDSTShifted;\n}\n\nfunction isLocal () {\n    return this.isValid() ? !this._isUTC : false;\n}\n\nfunction isUtcOffset () {\n    return this.isValid() ? this._isUTC : false;\n}\n\nfunction isUtc () {\n    return this.isValid() ? this._isUTC && this._offset === 0 : false;\n}\n\n// ASP.NET json date format regex\nvar aspNetRegex = /^(\\-)?(?:(\\d*)[. ])?(\\d+)\\:(\\d+)(?:\\:(\\d+)(\\.\\d*)?)?$/;\n\n// from http://docs.closure-library.googlecode.com/git/closure_goog_date_date.js.source.html\n// somewhat more in line with 4.4.3.2 2004 spec, but allows decimal anywhere\n// and further modified to allow for strings containing both week and day\nvar isoRegex = /^(-)?P(?:(-?[0-9,.]*)Y)?(?:(-?[0-9,.]*)M)?(?:(-?[0-9,.]*)W)?(?:(-?[0-9,.]*)D)?(?:T(?:(-?[0-9,.]*)H)?(?:(-?[0-9,.]*)M)?(?:(-?[0-9,.]*)S)?)?$/;\n\nfunction createDuration (input, key) {\n    var duration = input,\n        // matching against regexp is expensive, do it on demand\n        match = null,\n        sign,\n        ret,\n        diffRes;\n\n    if (isDuration(input)) {\n        duration = {\n            ms : input._milliseconds,\n            d  : input._days,\n            M  : input._months\n        };\n    } else if (isNumber(input)) {\n        duration = {};\n        if (key) {\n            duration[key] = input;\n        } else {\n            duration.milliseconds = input;\n        }\n    } else if (!!(match = aspNetRegex.exec(input))) {\n        sign = (match[1] === '-') ? -1 : 1;\n        duration = {\n            y  : 0,\n            d  : toInt(match[DATE])                         * sign,\n            h  : toInt(match[HOUR])                         * sign,\n            m  : toInt(match[MINUTE])                       * sign,\n            s  : toInt(match[SECOND])                       * sign,\n            ms : toInt(absRound(match[MILLISECOND] * 1000)) * sign // the millisecond decimal point is included in the match\n        };\n    } else if (!!(match = isoRegex.exec(input))) {\n        sign = (match[1] === '-') ? -1 : 1;\n        duration = {\n            y : parseIso(match[2], sign),\n            M : parseIso(match[3], sign),\n            w : parseIso(match[4], sign),\n            d : parseIso(match[5], sign),\n            h : parseIso(match[6], sign),\n            m : parseIso(match[7], sign),\n            s : parseIso(match[8], sign)\n        };\n    } else if (duration == null) {// checks for null or undefined\n        duration = {};\n    } else if (typeof duration === 'object' && ('from' in duration || 'to' in duration)) {\n        diffRes = momentsDifference(createLocal(duration.from), createLocal(duration.to));\n\n        duration = {};\n        duration.ms = diffRes.milliseconds;\n        duration.M = diffRes.months;\n    }\n\n    ret = new Duration(duration);\n\n    if (isDuration(input) && hasOwnProp(input, '_locale')) {\n        ret._locale = input._locale;\n    }\n\n    return ret;\n}\n\ncreateDuration.fn = Duration.prototype;\ncreateDuration.invalid = createInvalid$1;\n\nfunction parseIso (inp, sign) {\n    // We'd normally use ~~inp for this, but unfortunately it also\n    // converts floats to ints.\n    // inp may be undefined, so careful calling replace on it.\n    var res = inp && parseFloat(inp.replace(',', '.'));\n    // apply sign while we're at it\n    return (isNaN(res) ? 0 : res) * sign;\n}\n\nfunction positiveMomentsDifference(base, other) {\n    var res = {milliseconds: 0, months: 0};\n\n    res.months = other.month() - base.month() +\n        (other.year() - base.year()) * 12;\n    if (base.clone().add(res.months, 'M').isAfter(other)) {\n        --res.months;\n    }\n\n    res.milliseconds = +other - +(base.clone().add(res.months, 'M'));\n\n    return res;\n}\n\nfunction momentsDifference(base, other) {\n    var res;\n    if (!(base.isValid() && other.isValid())) {\n        return {milliseconds: 0, months: 0};\n    }\n\n    other = cloneWithOffset(other, base);\n    if (base.isBefore(other)) {\n        res = positiveMomentsDifference(base, other);\n    } else {\n        res = positiveMomentsDifference(other, base);\n        res.milliseconds = -res.milliseconds;\n        res.months = -res.months;\n    }\n\n    return res;\n}\n\n// TODO: remove 'name' arg after deprecation is removed\nfunction createAdder(direction, name) {\n    return function (val, period) {\n        var dur, tmp;\n        //invert the arguments, but complain about it\n        if (period !== null && !isNaN(+period)) {\n            deprecateSimple(name, 'moment().' + name  + '(period, number) is deprecated. Please use moment().' + name + '(number, period). ' +\n            'See http://momentjs.com/guides/#/warnings/add-inverted-param/ for more info.');\n            tmp = val; val = period; period = tmp;\n        }\n\n        val = typeof val === 'string' ? +val : val;\n        dur = createDuration(val, period);\n        addSubtract(this, dur, direction);\n        return this;\n    };\n}\n\nfunction addSubtract (mom, duration, isAdding, updateOffset) {\n    var milliseconds = duration._milliseconds,\n        days = absRound(duration._days),\n        months = absRound(duration._months);\n\n    if (!mom.isValid()) {\n        // No op\n        return;\n    }\n\n    updateOffset = updateOffset == null ? true : updateOffset;\n\n    if (milliseconds) {\n        mom._d.setTime(mom._d.valueOf() + milliseconds * isAdding);\n    }\n    if (days) {\n        set$1(mom, 'Date', get(mom, 'Date') + days * isAdding);\n    }\n    if (months) {\n        setMonth(mom, get(mom, 'Month') + months * isAdding);\n    }\n    if (updateOffset) {\n        hooks.updateOffset(mom, days || months);\n    }\n}\n\nvar add      = createAdder(1, 'add');\nvar subtract = createAdder(-1, 'subtract');\n\nfunction getCalendarFormat(myMoment, now) {\n    var diff = myMoment.diff(now, 'days', true);\n    return diff < -6 ? 'sameElse' :\n            diff < -1 ? 'lastWeek' :\n            diff < 0 ? 'lastDay' :\n            diff < 1 ? 'sameDay' :\n            diff < 2 ? 'nextDay' :\n            diff < 7 ? 'nextWeek' : 'sameElse';\n}\n\nfunction calendar$1 (time, formats) {\n    // We want to compare the start of today, vs this.\n    // Getting start-of-today depends on whether we're local/utc/offset or not.\n    var now = time || createLocal(),\n        sod = cloneWithOffset(now, this).startOf('day'),\n        format = hooks.calendarFormat(this, sod) || 'sameElse';\n\n    var output = formats && (isFunction(formats[format]) ? formats[format].call(this, now) : formats[format]);\n\n    return this.format(output || this.localeData().calendar(format, this, createLocal(now)));\n}\n\nfunction clone () {\n    return new Moment(this);\n}\n\nfunction isAfter (input, units) {\n    var localInput = isMoment(input) ? input : createLocal(input);\n    if (!(this.isValid() && localInput.isValid())) {\n        return false;\n    }\n    units = normalizeUnits(!isUndefined(units) ? units : 'millisecond');\n    if (units === 'millisecond') {\n        return this.valueOf() > localInput.valueOf();\n    } else {\n        return localInput.valueOf() < this.clone().startOf(units).valueOf();\n    }\n}\n\nfunction isBefore (input, units) {\n    var localInput = isMoment(input) ? input : createLocal(input);\n    if (!(this.isValid() && localInput.isValid())) {\n        return false;\n    }\n    units = normalizeUnits(!isUndefined(units) ? units : 'millisecond');\n    if (units === 'millisecond') {\n        return this.valueOf() < localInput.valueOf();\n    } else {\n        return this.clone().endOf(units).valueOf() < localInput.valueOf();\n    }\n}\n\nfunction isBetween (from, to, units, inclusivity) {\n    inclusivity = inclusivity || '()';\n    return (inclusivity[0] === '(' ? this.isAfter(from, units) : !this.isBefore(from, units)) &&\n        (inclusivity[1] === ')' ? this.isBefore(to, units) : !this.isAfter(to, units));\n}\n\nfunction isSame (input, units) {\n    var localInput = isMoment(input) ? input : createLocal(input),\n        inputMs;\n    if (!(this.isValid() && localInput.isValid())) {\n        return false;\n    }\n    units = normalizeUnits(units || 'millisecond');\n    if (units === 'millisecond') {\n        return this.valueOf() === localInput.valueOf();\n    } else {\n        inputMs = localInput.valueOf();\n        return this.clone().startOf(units).valueOf() <= inputMs && inputMs <= this.clone().endOf(units).valueOf();\n    }\n}\n\nfunction isSameOrAfter (input, units) {\n    return this.isSame(input, units) || this.isAfter(input,units);\n}\n\nfunction isSameOrBefore (input, units) {\n    return this.isSame(input, units) || this.isBefore(input,units);\n}\n\nfunction diff (input, units, asFloat) {\n    var that,\n        zoneDelta,\n        delta, output;\n\n    if (!this.isValid()) {\n        return NaN;\n    }\n\n    that = cloneWithOffset(input, this);\n\n    if (!that.isValid()) {\n        return NaN;\n    }\n\n    zoneDelta = (that.utcOffset() - this.utcOffset()) * 6e4;\n\n    units = normalizeUnits(units);\n\n    if (units === 'year' || units === 'month' || units === 'quarter') {\n        output = monthDiff(this, that);\n        if (units === 'quarter') {\n            output = output / 3;\n        } else if (units === 'year') {\n            output = output / 12;\n        }\n    } else {\n        delta = this - that;\n        output = units === 'second' ? delta / 1e3 : // 1000\n            units === 'minute' ? delta / 6e4 : // 1000 * 60\n            units === 'hour' ? delta / 36e5 : // 1000 * 60 * 60\n            units === 'day' ? (delta - zoneDelta) / 864e5 : // 1000 * 60 * 60 * 24, negate dst\n            units === 'week' ? (delta - zoneDelta) / 6048e5 : // 1000 * 60 * 60 * 24 * 7, negate dst\n            delta;\n    }\n    return asFloat ? output : absFloor(output);\n}\n\nfunction monthDiff (a, b) {\n    // difference in months\n    var wholeMonthDiff = ((b.year() - a.year()) * 12) + (b.month() - a.month()),\n        // b is in (anchor - 1 month, anchor + 1 month)\n        anchor = a.clone().add(wholeMonthDiff, 'months'),\n        anchor2, adjust;\n\n    if (b - anchor < 0) {\n        anchor2 = a.clone().add(wholeMonthDiff - 1, 'months');\n        // linear across the month\n        adjust = (b - anchor) / (anchor - anchor2);\n    } else {\n        anchor2 = a.clone().add(wholeMonthDiff + 1, 'months');\n        // linear across the month\n        adjust = (b - anchor) / (anchor2 - anchor);\n    }\n\n    //check for negative zero, return zero if negative zero\n    return -(wholeMonthDiff + adjust) || 0;\n}\n\nhooks.defaultFormat = 'YYYY-MM-DDTHH:mm:ssZ';\nhooks.defaultFormatUtc = 'YYYY-MM-DDTHH:mm:ss[Z]';\n\nfunction toString () {\n    return this.clone().locale('en').format('ddd MMM DD YYYY HH:mm:ss [GMT]ZZ');\n}\n\nfunction toISOString() {\n    if (!this.isValid()) {\n        return null;\n    }\n    var m = this.clone().utc();\n    if (m.year() < 0 || m.year() > 9999) {\n        return formatMoment(m, 'YYYYYY-MM-DD[T]HH:mm:ss.SSS[Z]');\n    }\n    if (isFunction(Date.prototype.toISOString)) {\n        // native implementation is ~50x faster, use it when we can\n        return this.toDate().toISOString();\n    }\n    return formatMoment(m, 'YYYY-MM-DD[T]HH:mm:ss.SSS[Z]');\n}\n\n/**\n * Return a human readable representation of a moment that can\n * also be evaluated to get a new moment which is the same\n *\n * @link https://nodejs.org/dist/latest/docs/api/util.html#util_custom_inspect_function_on_objects\n */\nfunction inspect () {\n    if (!this.isValid()) {\n        return 'moment.invalid(/* ' + this._i + ' */)';\n    }\n    var func = 'moment';\n    var zone = '';\n    if (!this.isLocal()) {\n        func = this.utcOffset() === 0 ? 'moment.utc' : 'moment.parseZone';\n        zone = 'Z';\n    }\n    var prefix = '[' + func + '(\"]';\n    var year = (0 <= this.year() && this.year() <= 9999) ? 'YYYY' : 'YYYYYY';\n    var datetime = '-MM-DD[T]HH:mm:ss.SSS';\n    var suffix = zone + '[\")]';\n\n    return this.format(prefix + year + datetime + suffix);\n}\n\nfunction format (inputString) {\n    if (!inputString) {\n        inputString = this.isUtc() ? hooks.defaultFormatUtc : hooks.defaultFormat;\n    }\n    var output = formatMoment(this, inputString);\n    return this.localeData().postformat(output);\n}\n\nfunction from (time, withoutSuffix) {\n    if (this.isValid() &&\n            ((isMoment(time) && time.isValid()) ||\n             createLocal(time).isValid())) {\n        return createDuration({to: this, from: time}).locale(this.locale()).humanize(!withoutSuffix);\n    } else {\n        return this.localeData().invalidDate();\n    }\n}\n\nfunction fromNow (withoutSuffix) {\n    return this.from(createLocal(), withoutSuffix);\n}\n\nfunction to (time, withoutSuffix) {\n    if (this.isValid() &&\n            ((isMoment(time) && time.isValid()) ||\n             createLocal(time).isValid())) {\n        return createDuration({from: this, to: time}).locale(this.locale()).humanize(!withoutSuffix);\n    } else {\n        return this.localeData().invalidDate();\n    }\n}\n\nfunction toNow (withoutSuffix) {\n    return this.to(createLocal(), withoutSuffix);\n}\n\n// If passed a locale key, it will set the locale for this\n// instance.  Otherwise, it will return the locale configuration\n// variables for this instance.\nfunction locale (key) {\n    var newLocaleData;\n\n    if (key === undefined) {\n        return this._locale._abbr;\n    } else {\n        newLocaleData = getLocale(key);\n        if (newLocaleData != null) {\n            this._locale = newLocaleData;\n        }\n        return this;\n    }\n}\n\nvar lang = deprecate(\n    'moment().lang() is deprecated. Instead, use moment().localeData() to get the language configuration. Use moment().locale() to change languages.',\n    function (key) {\n        if (key === undefined) {\n            return this.localeData();\n        } else {\n            return this.locale(key);\n        }\n    }\n);\n\nfunction localeData () {\n    return this._locale;\n}\n\nfunction startOf (units) {\n    units = normalizeUnits(units);\n    // the following switch intentionally omits break keywords\n    // to utilize falling through the cases.\n    switch (units) {\n        case 'year':\n            this.month(0);\n            /* falls through */\n        case 'quarter':\n        case 'month':\n            this.date(1);\n            /* falls through */\n        case 'week':\n        case 'isoWeek':\n        case 'day':\n        case 'date':\n            this.hours(0);\n            /* falls through */\n        case 'hour':\n            this.minutes(0);\n            /* falls through */\n        case 'minute':\n            this.seconds(0);\n            /* falls through */\n        case 'second':\n            this.milliseconds(0);\n    }\n\n    // weeks are a special case\n    if (units === 'week') {\n        this.weekday(0);\n    }\n    if (units === 'isoWeek') {\n        this.isoWeekday(1);\n    }\n\n    // quarters are also special\n    if (units === 'quarter') {\n        this.month(Math.floor(this.month() / 3) * 3);\n    }\n\n    return this;\n}\n\nfunction endOf (units) {\n    units = normalizeUnits(units);\n    if (units === undefined || units === 'millisecond') {\n        return this;\n    }\n\n    // 'date' is an alias for 'day', so it should be considered as such.\n    if (units === 'date') {\n        units = 'day';\n    }\n\n    return this.startOf(units).add(1, (units === 'isoWeek' ? 'week' : units)).subtract(1, 'ms');\n}\n\nfunction valueOf () {\n    return this._d.valueOf() - ((this._offset || 0) * 60000);\n}\n\nfunction unix () {\n    return Math.floor(this.valueOf() / 1000);\n}\n\nfunction toDate () {\n    return new Date(this.valueOf());\n}\n\nfunction toArray () {\n    var m = this;\n    return [m.year(), m.month(), m.date(), m.hour(), m.minute(), m.second(), m.millisecond()];\n}\n\nfunction toObject () {\n    var m = this;\n    return {\n        years: m.year(),\n        months: m.month(),\n        date: m.date(),\n        hours: m.hours(),\n        minutes: m.minutes(),\n        seconds: m.seconds(),\n        milliseconds: m.milliseconds()\n    };\n}\n\nfunction toJSON () {\n    // new Date(NaN).toJSON() === null\n    return this.isValid() ? this.toISOString() : null;\n}\n\nfunction isValid$2 () {\n    return isValid(this);\n}\n\nfunction parsingFlags () {\n    return extend({}, getParsingFlags(this));\n}\n\nfunction invalidAt () {\n    return getParsingFlags(this).overflow;\n}\n\nfunction creationData() {\n    return {\n        input: this._i,\n        format: this._f,\n        locale: this._locale,\n        isUTC: this._isUTC,\n        strict: this._strict\n    };\n}\n\n// FORMATTING\n\naddFormatToken(0, ['gg', 2], 0, function () {\n    return this.weekYear() % 100;\n});\n\naddFormatToken(0, ['GG', 2], 0, function () {\n    return this.isoWeekYear() % 100;\n});\n\nfunction addWeekYearFormatToken (token, getter) {\n    addFormatToken(0, [token, token.length], 0, getter);\n}\n\naddWeekYearFormatToken('gggg',     'weekYear');\naddWeekYearFormatToken('ggggg',    'weekYear');\naddWeekYearFormatToken('GGGG',  'isoWeekYear');\naddWeekYearFormatToken('GGGGG', 'isoWeekYear');\n\n// ALIASES\n\naddUnitAlias('weekYear', 'gg');\naddUnitAlias('isoWeekYear', 'GG');\n\n// PRIORITY\n\naddUnitPriority('weekYear', 1);\naddUnitPriority('isoWeekYear', 1);\n\n\n// PARSING\n\naddRegexToken('G',      matchSigned);\naddRegexToken('g',      matchSigned);\naddRegexToken('GG',     match1to2, match2);\naddRegexToken('gg',     match1to2, match2);\naddRegexToken('GGGG',   match1to4, match4);\naddRegexToken('gggg',   match1to4, match4);\naddRegexToken('GGGGG',  match1to6, match6);\naddRegexToken('ggggg',  match1to6, match6);\n\naddWeekParseToken(['gggg', 'ggggg', 'GGGG', 'GGGGG'], function (input, week, config, token) {\n    week[token.substr(0, 2)] = toInt(input);\n});\n\naddWeekParseToken(['gg', 'GG'], function (input, week, config, token) {\n    week[token] = hooks.parseTwoDigitYear(input);\n});\n\n// MOMENTS\n\nfunction getSetWeekYear (input) {\n    return getSetWeekYearHelper.call(this,\n            input,\n            this.week(),\n            this.weekday(),\n            this.localeData()._week.dow,\n            this.localeData()._week.doy);\n}\n\nfunction getSetISOWeekYear (input) {\n    return getSetWeekYearHelper.call(this,\n            input, this.isoWeek(), this.isoWeekday(), 1, 4);\n}\n\nfunction getISOWeeksInYear () {\n    return weeksInYear(this.year(), 1, 4);\n}\n\nfunction getWeeksInYear () {\n    var weekInfo = this.localeData()._week;\n    return weeksInYear(this.year(), weekInfo.dow, weekInfo.doy);\n}\n\nfunction getSetWeekYearHelper(input, week, weekday, dow, doy) {\n    var weeksTarget;\n    if (input == null) {\n        return weekOfYear(this, dow, doy).year;\n    } else {\n        weeksTarget = weeksInYear(input, dow, doy);\n        if (week > weeksTarget) {\n            week = weeksTarget;\n        }\n        return setWeekAll.call(this, input, week, weekday, dow, doy);\n    }\n}\n\nfunction setWeekAll(weekYear, week, weekday, dow, doy) {\n    var dayOfYearData = dayOfYearFromWeeks(weekYear, week, weekday, dow, doy),\n        date = createUTCDate(dayOfYearData.year, 0, dayOfYearData.dayOfYear);\n\n    this.year(date.getUTCFullYear());\n    this.month(date.getUTCMonth());\n    this.date(date.getUTCDate());\n    return this;\n}\n\n// FORMATTING\n\naddFormatToken('Q', 0, 'Qo', 'quarter');\n\n// ALIASES\n\naddUnitAlias('quarter', 'Q');\n\n// PRIORITY\n\naddUnitPriority('quarter', 7);\n\n// PARSING\n\naddRegexToken('Q', match1);\naddParseToken('Q', function (input, array) {\n    array[MONTH] = (toInt(input) - 1) * 3;\n});\n\n// MOMENTS\n\nfunction getSetQuarter (input) {\n    return input == null ? Math.ceil((this.month() + 1) / 3) : this.month((input - 1) * 3 + this.month() % 3);\n}\n\n// FORMATTING\n\naddFormatToken('D', ['DD', 2], 'Do', 'date');\n\n// ALIASES\n\naddUnitAlias('date', 'D');\n\n// PRIOROITY\naddUnitPriority('date', 9);\n\n// PARSING\n\naddRegexToken('D',  match1to2);\naddRegexToken('DD', match1to2, match2);\naddRegexToken('Do', function (isStrict, locale) {\n    // TODO: Remove \"ordinalParse\" fallback in next major release.\n    return isStrict ?\n      (locale._dayOfMonthOrdinalParse || locale._ordinalParse) :\n      locale._dayOfMonthOrdinalParseLenient;\n});\n\naddParseToken(['D', 'DD'], DATE);\naddParseToken('Do', function (input, array) {\n    array[DATE] = toInt(input.match(match1to2)[0], 10);\n});\n\n// MOMENTS\n\nvar getSetDayOfMonth = makeGetSet('Date', true);\n\n// FORMATTING\n\naddFormatToken('DDD', ['DDDD', 3], 'DDDo', 'dayOfYear');\n\n// ALIASES\n\naddUnitAlias('dayOfYear', 'DDD');\n\n// PRIORITY\naddUnitPriority('dayOfYear', 4);\n\n// PARSING\n\naddRegexToken('DDD',  match1to3);\naddRegexToken('DDDD', match3);\naddParseToken(['DDD', 'DDDD'], function (input, array, config) {\n    config._dayOfYear = toInt(input);\n});\n\n// HELPERS\n\n// MOMENTS\n\nfunction getSetDayOfYear (input) {\n    var dayOfYear = Math.round((this.clone().startOf('day') - this.clone().startOf('year')) / 864e5) + 1;\n    return input == null ? dayOfYear : this.add((input - dayOfYear), 'd');\n}\n\n// FORMATTING\n\naddFormatToken('m', ['mm', 2], 0, 'minute');\n\n// ALIASES\n\naddUnitAlias('minute', 'm');\n\n// PRIORITY\n\naddUnitPriority('minute', 14);\n\n// PARSING\n\naddRegexToken('m',  match1to2);\naddRegexToken('mm', match1to2, match2);\naddParseToken(['m', 'mm'], MINUTE);\n\n// MOMENTS\n\nvar getSetMinute = makeGetSet('Minutes', false);\n\n// FORMATTING\n\naddFormatToken('s', ['ss', 2], 0, 'second');\n\n// ALIASES\n\naddUnitAlias('second', 's');\n\n// PRIORITY\n\naddUnitPriority('second', 15);\n\n// PARSING\n\naddRegexToken('s',  match1to2);\naddRegexToken('ss', match1to2, match2);\naddParseToken(['s', 'ss'], SECOND);\n\n// MOMENTS\n\nvar getSetSecond = makeGetSet('Seconds', false);\n\n// FORMATTING\n\naddFormatToken('S', 0, 0, function () {\n    return ~~(this.millisecond() / 100);\n});\n\naddFormatToken(0, ['SS', 2], 0, function () {\n    return ~~(this.millisecond() / 10);\n});\n\naddFormatToken(0, ['SSS', 3], 0, 'millisecond');\naddFormatToken(0, ['SSSS', 4], 0, function () {\n    return this.millisecond() * 10;\n});\naddFormatToken(0, ['SSSSS', 5], 0, function () {\n    return this.millisecond() * 100;\n});\naddFormatToken(0, ['SSSSSS', 6], 0, function () {\n    return this.millisecond() * 1000;\n});\naddFormatToken(0, ['SSSSSSS', 7], 0, function () {\n    return this.millisecond() * 10000;\n});\naddFormatToken(0, ['SSSSSSSS', 8], 0, function () {\n    return this.millisecond() * 100000;\n});\naddFormatToken(0, ['SSSSSSSSS', 9], 0, function () {\n    return this.millisecond() * 1000000;\n});\n\n\n// ALIASES\n\naddUnitAlias('millisecond', 'ms');\n\n// PRIORITY\n\naddUnitPriority('millisecond', 16);\n\n// PARSING\n\naddRegexToken('S',    match1to3, match1);\naddRegexToken('SS',   match1to3, match2);\naddRegexToken('SSS',  match1to3, match3);\n\nvar token;\nfor (token = 'SSSS'; token.length <= 9; token += 'S') {\n    addRegexToken(token, matchUnsigned);\n}\n\nfunction parseMs(input, array) {\n    array[MILLISECOND] = toInt(('0.' + input) * 1000);\n}\n\nfor (token = 'S'; token.length <= 9; token += 'S') {\n    addParseToken(token, parseMs);\n}\n// MOMENTS\n\nvar getSetMillisecond = makeGetSet('Milliseconds', false);\n\n// FORMATTING\n\naddFormatToken('z',  0, 0, 'zoneAbbr');\naddFormatToken('zz', 0, 0, 'zoneName');\n\n// MOMENTS\n\nfunction getZoneAbbr () {\n    return this._isUTC ? 'UTC' : '';\n}\n\nfunction getZoneName () {\n    return this._isUTC ? 'Coordinated Universal Time' : '';\n}\n\nvar proto = Moment.prototype;\n\nproto.add               = add;\nproto.calendar          = calendar$1;\nproto.clone             = clone;\nproto.diff              = diff;\nproto.endOf             = endOf;\nproto.format            = format;\nproto.from              = from;\nproto.fromNow           = fromNow;\nproto.to                = to;\nproto.toNow             = toNow;\nproto.get               = stringGet;\nproto.invalidAt         = invalidAt;\nproto.isAfter           = isAfter;\nproto.isBefore          = isBefore;\nproto.isBetween         = isBetween;\nproto.isSame            = isSame;\nproto.isSameOrAfter     = isSameOrAfter;\nproto.isSameOrBefore    = isSameOrBefore;\nproto.isValid           = isValid$2;\nproto.lang              = lang;\nproto.locale            = locale;\nproto.localeData        = localeData;\nproto.max               = prototypeMax;\nproto.min               = prototypeMin;\nproto.parsingFlags      = parsingFlags;\nproto.set               = stringSet;\nproto.startOf           = startOf;\nproto.subtract          = subtract;\nproto.toArray           = toArray;\nproto.toObject          = toObject;\nproto.toDate            = toDate;\nproto.toISOString       = toISOString;\nproto.inspect           = inspect;\nproto.toJSON            = toJSON;\nproto.toString          = toString;\nproto.unix              = unix;\nproto.valueOf           = valueOf;\nproto.creationData      = creationData;\n\n// Year\nproto.year       = getSetYear;\nproto.isLeapYear = getIsLeapYear;\n\n// Week Year\nproto.weekYear    = getSetWeekYear;\nproto.isoWeekYear = getSetISOWeekYear;\n\n// Quarter\nproto.quarter = proto.quarters = getSetQuarter;\n\n// Month\nproto.month       = getSetMonth;\nproto.daysInMonth = getDaysInMonth;\n\n// Week\nproto.week           = proto.weeks        = getSetWeek;\nproto.isoWeek        = proto.isoWeeks     = getSetISOWeek;\nproto.weeksInYear    = getWeeksInYear;\nproto.isoWeeksInYear = getISOWeeksInYear;\n\n// Day\nproto.date       = getSetDayOfMonth;\nproto.day        = proto.days             = getSetDayOfWeek;\nproto.weekday    = getSetLocaleDayOfWeek;\nproto.isoWeekday = getSetISODayOfWeek;\nproto.dayOfYear  = getSetDayOfYear;\n\n// Hour\nproto.hour = proto.hours = getSetHour;\n\n// Minute\nproto.minute = proto.minutes = getSetMinute;\n\n// Second\nproto.second = proto.seconds = getSetSecond;\n\n// Millisecond\nproto.millisecond = proto.milliseconds = getSetMillisecond;\n\n// Offset\nproto.utcOffset            = getSetOffset;\nproto.utc                  = setOffsetToUTC;\nproto.local                = setOffsetToLocal;\nproto.parseZone            = setOffsetToParsedOffset;\nproto.hasAlignedHourOffset = hasAlignedHourOffset;\nproto.isDST                = isDaylightSavingTime;\nproto.isLocal              = isLocal;\nproto.isUtcOffset          = isUtcOffset;\nproto.isUtc                = isUtc;\nproto.isUTC                = isUtc;\n\n// Timezone\nproto.zoneAbbr = getZoneAbbr;\nproto.zoneName = getZoneName;\n\n// Deprecations\nproto.dates  = deprecate('dates accessor is deprecated. Use date instead.', getSetDayOfMonth);\nproto.months = deprecate('months accessor is deprecated. Use month instead', getSetMonth);\nproto.years  = deprecate('years accessor is deprecated. Use year instead', getSetYear);\nproto.zone   = deprecate('moment().zone is deprecated, use moment().utcOffset instead. http://momentjs.com/guides/#/warnings/zone/', getSetZone);\nproto.isDSTShifted = deprecate('isDSTShifted is deprecated. See http://momentjs.com/guides/#/warnings/dst-shifted/ for more information', isDaylightSavingTimeShifted);\n\nfunction createUnix (input) {\n    return createLocal(input * 1000);\n}\n\nfunction createInZone () {\n    return createLocal.apply(null, arguments).parseZone();\n}\n\nfunction preParsePostFormat (string) {\n    return string;\n}\n\nvar proto$1 = Locale.prototype;\n\nproto$1.calendar        = calendar;\nproto$1.longDateFormat  = longDateFormat;\nproto$1.invalidDate     = invalidDate;\nproto$1.ordinal         = ordinal;\nproto$1.preparse        = preParsePostFormat;\nproto$1.postformat      = preParsePostFormat;\nproto$1.relativeTime    = relativeTime;\nproto$1.pastFuture      = pastFuture;\nproto$1.set             = set;\n\n// Month\nproto$1.months            =        localeMonths;\nproto$1.monthsShort       =        localeMonthsShort;\nproto$1.monthsParse       =        localeMonthsParse;\nproto$1.monthsRegex       = monthsRegex;\nproto$1.monthsShortRegex  = monthsShortRegex;\n\n// Week\nproto$1.week = localeWeek;\nproto$1.firstDayOfYear = localeFirstDayOfYear;\nproto$1.firstDayOfWeek = localeFirstDayOfWeek;\n\n// Day of Week\nproto$1.weekdays       =        localeWeekdays;\nproto$1.weekdaysMin    =        localeWeekdaysMin;\nproto$1.weekdaysShort  =        localeWeekdaysShort;\nproto$1.weekdaysParse  =        localeWeekdaysParse;\n\nproto$1.weekdaysRegex       =        weekdaysRegex;\nproto$1.weekdaysShortRegex  =        weekdaysShortRegex;\nproto$1.weekdaysMinRegex    =        weekdaysMinRegex;\n\n// Hours\nproto$1.isPM = localeIsPM;\nproto$1.meridiem = localeMeridiem;\n\nfunction get$1 (format, index, field, setter) {\n    var locale = getLocale();\n    var utc = createUTC().set(setter, index);\n    return locale[field](utc, format);\n}\n\nfunction listMonthsImpl (format, index, field) {\n    if (isNumber(format)) {\n        index = format;\n        format = undefined;\n    }\n\n    format = format || '';\n\n    if (index != null) {\n        return get$1(format, index, field, 'month');\n    }\n\n    var i;\n    var out = [];\n    for (i = 0; i < 12; i++) {\n        out[i] = get$1(format, i, field, 'month');\n    }\n    return out;\n}\n\n// ()\n// (5)\n// (fmt, 5)\n// (fmt)\n// (true)\n// (true, 5)\n// (true, fmt, 5)\n// (true, fmt)\nfunction listWeekdaysImpl (localeSorted, format, index, field) {\n    if (typeof localeSorted === 'boolean') {\n        if (isNumber(format)) {\n            index = format;\n            format = undefined;\n        }\n\n        format = format || '';\n    } else {\n        format = localeSorted;\n        index = format;\n        localeSorted = false;\n\n        if (isNumber(format)) {\n            index = format;\n            format = undefined;\n        }\n\n        format = format || '';\n    }\n\n    var locale = getLocale(),\n        shift = localeSorted ? locale._week.dow : 0;\n\n    if (index != null) {\n        return get$1(format, (index + shift) % 7, field, 'day');\n    }\n\n    var i;\n    var out = [];\n    for (i = 0; i < 7; i++) {\n        out[i] = get$1(format, (i + shift) % 7, field, 'day');\n    }\n    return out;\n}\n\nfunction listMonths (format, index) {\n    return listMonthsImpl(format, index, 'months');\n}\n\nfunction listMonthsShort (format, index) {\n    return listMonthsImpl(format, index, 'monthsShort');\n}\n\nfunction listWeekdays (localeSorted, format, index) {\n    return listWeekdaysImpl(localeSorted, format, index, 'weekdays');\n}\n\nfunction listWeekdaysShort (localeSorted, format, index) {\n    return listWeekdaysImpl(localeSorted, format, index, 'weekdaysShort');\n}\n\nfunction listWeekdaysMin (localeSorted, format, index) {\n    return listWeekdaysImpl(localeSorted, format, index, 'weekdaysMin');\n}\n\ngetSetGlobalLocale('en', {\n    dayOfMonthOrdinalParse: /\\d{1,2}(th|st|nd|rd)/,\n    ordinal : function (number) {\n        var b = number % 10,\n            output = (toInt(number % 100 / 10) === 1) ? 'th' :\n            (b === 1) ? 'st' :\n            (b === 2) ? 'nd' :\n            (b === 3) ? 'rd' : 'th';\n        return number + output;\n    }\n});\n\n// Side effect imports\nhooks.lang = deprecate('moment.lang is deprecated. Use moment.locale instead.', getSetGlobalLocale);\nhooks.langData = deprecate('moment.langData is deprecated. Use moment.localeData instead.', getLocale);\n\nvar mathAbs = Math.abs;\n\nfunction abs () {\n    var data           = this._data;\n\n    this._milliseconds = mathAbs(this._milliseconds);\n    this._days         = mathAbs(this._days);\n    this._months       = mathAbs(this._months);\n\n    data.milliseconds  = mathAbs(data.milliseconds);\n    data.seconds       = mathAbs(data.seconds);\n    data.minutes       = mathAbs(data.minutes);\n    data.hours         = mathAbs(data.hours);\n    data.months        = mathAbs(data.months);\n    data.years         = mathAbs(data.years);\n\n    return this;\n}\n\nfunction addSubtract$1 (duration, input, value, direction) {\n    var other = createDuration(input, value);\n\n    duration._milliseconds += direction * other._milliseconds;\n    duration._days         += direction * other._days;\n    duration._months       += direction * other._months;\n\n    return duration._bubble();\n}\n\n// supports only 2.0-style add(1, 's') or add(duration)\nfunction add$1 (input, value) {\n    return addSubtract$1(this, input, value, 1);\n}\n\n// supports only 2.0-style subtract(1, 's') or subtract(duration)\nfunction subtract$1 (input, value) {\n    return addSubtract$1(this, input, value, -1);\n}\n\nfunction absCeil (number) {\n    if (number < 0) {\n        return Math.floor(number);\n    } else {\n        return Math.ceil(number);\n    }\n}\n\nfunction bubble () {\n    var milliseconds = this._milliseconds;\n    var days         = this._days;\n    var months       = this._months;\n    var data         = this._data;\n    var seconds, minutes, hours, years, monthsFromDays;\n\n    // if we have a mix of positive and negative values, bubble down first\n    // check: https://github.com/moment/moment/issues/2166\n    if (!((milliseconds >= 0 && days >= 0 && months >= 0) ||\n            (milliseconds <= 0 && days <= 0 && months <= 0))) {\n        milliseconds += absCeil(monthsToDays(months) + days) * 864e5;\n        days = 0;\n        months = 0;\n    }\n\n    // The following code bubbles up values, see the tests for\n    // examples of what that means.\n    data.milliseconds = milliseconds % 1000;\n\n    seconds           = absFloor(milliseconds / 1000);\n    data.seconds      = seconds % 60;\n\n    minutes           = absFloor(seconds / 60);\n    data.minutes      = minutes % 60;\n\n    hours             = absFloor(minutes / 60);\n    data.hours        = hours % 24;\n\n    days += absFloor(hours / 24);\n\n    // convert days to months\n    monthsFromDays = absFloor(daysToMonths(days));\n    months += monthsFromDays;\n    days -= absCeil(monthsToDays(monthsFromDays));\n\n    // 12 months -> 1 year\n    years = absFloor(months / 12);\n    months %= 12;\n\n    data.days   = days;\n    data.months = months;\n    data.years  = years;\n\n    return this;\n}\n\nfunction daysToMonths (days) {\n    // 400 years have 146097 days (taking into account leap year rules)\n    // 400 years have 12 months === 4800\n    return days * 4800 / 146097;\n}\n\nfunction monthsToDays (months) {\n    // the reverse of daysToMonths\n    return months * 146097 / 4800;\n}\n\nfunction as (units) {\n    if (!this.isValid()) {\n        return NaN;\n    }\n    var days;\n    var months;\n    var milliseconds = this._milliseconds;\n\n    units = normalizeUnits(units);\n\n    if (units === 'month' || units === 'year') {\n        days   = this._days   + milliseconds / 864e5;\n        months = this._months + daysToMonths(days);\n        return units === 'month' ? months : months / 12;\n    } else {\n        // handle milliseconds separately because of floating point math errors (issue #1867)\n        days = this._days + Math.round(monthsToDays(this._months));\n        switch (units) {\n            case 'week'   : return days / 7     + milliseconds / 6048e5;\n            case 'day'    : return days         + milliseconds / 864e5;\n            case 'hour'   : return days * 24    + milliseconds / 36e5;\n            case 'minute' : return days * 1440  + milliseconds / 6e4;\n            case 'second' : return days * 86400 + milliseconds / 1000;\n            // Math.floor prevents floating point math errors here\n            case 'millisecond': return Math.floor(days * 864e5) + milliseconds;\n            default: throw new Error('Unknown unit ' + units);\n        }\n    }\n}\n\n// TODO: Use this.as('ms')?\nfunction valueOf$1 () {\n    if (!this.isValid()) {\n        return NaN;\n    }\n    return (\n        this._milliseconds +\n        this._days * 864e5 +\n        (this._months % 12) * 2592e6 +\n        toInt(this._months / 12) * 31536e6\n    );\n}\n\nfunction makeAs (alias) {\n    return function () {\n        return this.as(alias);\n    };\n}\n\nvar asMilliseconds = makeAs('ms');\nvar asSeconds      = makeAs('s');\nvar asMinutes      = makeAs('m');\nvar asHours        = makeAs('h');\nvar asDays         = makeAs('d');\nvar asWeeks        = makeAs('w');\nvar asMonths       = makeAs('M');\nvar asYears        = makeAs('y');\n\nfunction get$2 (units) {\n    units = normalizeUnits(units);\n    return this.isValid() ? this[units + 's']() : NaN;\n}\n\nfunction makeGetter(name) {\n    return function () {\n        return this.isValid() ? this._data[name] : NaN;\n    };\n}\n\nvar milliseconds = makeGetter('milliseconds');\nvar seconds      = makeGetter('seconds');\nvar minutes      = makeGetter('minutes');\nvar hours        = makeGetter('hours');\nvar days         = makeGetter('days');\nvar months       = makeGetter('months');\nvar years        = makeGetter('years');\n\nfunction weeks () {\n    return absFloor(this.days() / 7);\n}\n\nvar round = Math.round;\nvar thresholds = {\n    ss: 44,         // a few seconds to seconds\n    s : 45,         // seconds to minute\n    m : 45,         // minutes to hour\n    h : 22,         // hours to day\n    d : 26,         // days to month\n    M : 11          // months to year\n};\n\n// helper function for moment.fn.from, moment.fn.fromNow, and moment.duration.fn.humanize\nfunction substituteTimeAgo(string, number, withoutSuffix, isFuture, locale) {\n    return locale.relativeTime(number || 1, !!withoutSuffix, string, isFuture);\n}\n\nfunction relativeTime$1 (posNegDuration, withoutSuffix, locale) {\n    var duration = createDuration(posNegDuration).abs();\n    var seconds  = round(duration.as('s'));\n    var minutes  = round(duration.as('m'));\n    var hours    = round(duration.as('h'));\n    var days     = round(duration.as('d'));\n    var months   = round(duration.as('M'));\n    var years    = round(duration.as('y'));\n\n    var a = seconds <= thresholds.ss && ['s', seconds]  ||\n            seconds < thresholds.s   && ['ss', seconds] ||\n            minutes <= 1             && ['m']           ||\n            minutes < thresholds.m   && ['mm', minutes] ||\n            hours   <= 1             && ['h']           ||\n            hours   < thresholds.h   && ['hh', hours]   ||\n            days    <= 1             && ['d']           ||\n            days    < thresholds.d   && ['dd', days]    ||\n            months  <= 1             && ['M']           ||\n            months  < thresholds.M   && ['MM', months]  ||\n            years   <= 1             && ['y']           || ['yy', years];\n\n    a[2] = withoutSuffix;\n    a[3] = +posNegDuration > 0;\n    a[4] = locale;\n    return substituteTimeAgo.apply(null, a);\n}\n\n// This function allows you to set the rounding function for relative time strings\nfunction getSetRelativeTimeRounding (roundingFunction) {\n    if (roundingFunction === undefined) {\n        return round;\n    }\n    if (typeof(roundingFunction) === 'function') {\n        round = roundingFunction;\n        return true;\n    }\n    return false;\n}\n\n// This function allows you to set a threshold for relative time strings\nfunction getSetRelativeTimeThreshold (threshold, limit) {\n    if (thresholds[threshold] === undefined) {\n        return false;\n    }\n    if (limit === undefined) {\n        return thresholds[threshold];\n    }\n    thresholds[threshold] = limit;\n    if (threshold === 's') {\n        thresholds.ss = limit - 1;\n    }\n    return true;\n}\n\nfunction humanize (withSuffix) {\n    if (!this.isValid()) {\n        return this.localeData().invalidDate();\n    }\n\n    var locale = this.localeData();\n    var output = relativeTime$1(this, !withSuffix, locale);\n\n    if (withSuffix) {\n        output = locale.pastFuture(+this, output);\n    }\n\n    return locale.postformat(output);\n}\n\nvar abs$1 = Math.abs;\n\nfunction toISOString$1() {\n    // for ISO strings we do not use the normal bubbling rules:\n    //  * milliseconds bubble up until they become hours\n    //  * days do not bubble at all\n    //  * months bubble up until they become years\n    // This is because there is no context-free conversion between hours and days\n    // (think of clock changes)\n    // and also not between days and months (28-31 days per month)\n    if (!this.isValid()) {\n        return this.localeData().invalidDate();\n    }\n\n    var seconds = abs$1(this._milliseconds) / 1000;\n    var days         = abs$1(this._days);\n    var months       = abs$1(this._months);\n    var minutes, hours, years;\n\n    // 3600 seconds -> 60 minutes -> 1 hour\n    minutes           = absFloor(seconds / 60);\n    hours             = absFloor(minutes / 60);\n    seconds %= 60;\n    minutes %= 60;\n\n    // 12 months -> 1 year\n    years  = absFloor(months / 12);\n    months %= 12;\n\n\n    // inspired by https://github.com/dordille/moment-isoduration/blob/master/moment.isoduration.js\n    var Y = years;\n    var M = months;\n    var D = days;\n    var h = hours;\n    var m = minutes;\n    var s = seconds;\n    var total = this.asSeconds();\n\n    if (!total) {\n        // this is the same as C#'s (Noda) and python (isodate)...\n        // but not other JS (goog.date)\n        return 'P0D';\n    }\n\n    return (total < 0 ? '-' : '') +\n        'P' +\n        (Y ? Y + 'Y' : '') +\n        (M ? M + 'M' : '') +\n        (D ? D + 'D' : '') +\n        ((h || m || s) ? 'T' : '') +\n        (h ? h + 'H' : '') +\n        (m ? m + 'M' : '') +\n        (s ? s + 'S' : '');\n}\n\nvar proto$2 = Duration.prototype;\n\nproto$2.isValid        = isValid$1;\nproto$2.abs            = abs;\nproto$2.add            = add$1;\nproto$2.subtract       = subtract$1;\nproto$2.as             = as;\nproto$2.asMilliseconds = asMilliseconds;\nproto$2.asSeconds      = asSeconds;\nproto$2.asMinutes      = asMinutes;\nproto$2.asHours        = asHours;\nproto$2.asDays         = asDays;\nproto$2.asWeeks        = asWeeks;\nproto$2.asMonths       = asMonths;\nproto$2.asYears        = asYears;\nproto$2.valueOf        = valueOf$1;\nproto$2._bubble        = bubble;\nproto$2.get            = get$2;\nproto$2.milliseconds   = milliseconds;\nproto$2.seconds        = seconds;\nproto$2.minutes        = minutes;\nproto$2.hours          = hours;\nproto$2.days           = days;\nproto$2.weeks          = weeks;\nproto$2.months         = months;\nproto$2.years          = years;\nproto$2.humanize       = humanize;\nproto$2.toISOString    = toISOString$1;\nproto$2.toString       = toISOString$1;\nproto$2.toJSON         = toISOString$1;\nproto$2.locale         = locale;\nproto$2.localeData     = localeData;\n\n// Deprecations\nproto$2.toIsoString = deprecate('toIsoString() is deprecated. Please use toISOString() instead (notice the capitals)', toISOString$1);\nproto$2.lang = lang;\n\n// Side effect imports\n\n// FORMATTING\n\naddFormatToken('X', 0, 0, 'unix');\naddFormatToken('x', 0, 0, 'valueOf');\n\n// PARSING\n\naddRegexToken('x', matchSigned);\naddRegexToken('X', matchTimestamp);\naddParseToken('X', function (input, array, config) {\n    config._d = new Date(parseFloat(input, 10) * 1000);\n});\naddParseToken('x', function (input, array, config) {\n    config._d = new Date(toInt(input));\n});\n\n// Side effect imports\n\n\nhooks.version = '2.18.1';\n\nsetHookCallback(createLocal);\n\nhooks.fn                    = proto;\nhooks.min                   = min;\nhooks.max                   = max;\nhooks.now                   = now;\nhooks.utc                   = createUTC;\nhooks.unix                  = createUnix;\nhooks.months                = listMonths;\nhooks.isDate                = isDate;\nhooks.locale                = getSetGlobalLocale;\nhooks.invalid               = createInvalid;\nhooks.duration              = createDuration;\nhooks.isMoment              = isMoment;\nhooks.weekdays              = listWeekdays;\nhooks.parseZone             = createInZone;\nhooks.localeData            = getLocale;\nhooks.isDuration            = isDuration;\nhooks.monthsShort           = listMonthsShort;\nhooks.weekdaysMin           = listWeekdaysMin;\nhooks.defineLocale          = defineLocale;\nhooks.updateLocale          = updateLocale;\nhooks.locales               = listLocales;\nhooks.weekdaysShort         = listWeekdaysShort;\nhooks.normalizeUnits        = normalizeUnits;\nhooks.relativeTimeRounding = getSetRelativeTimeRounding;\nhooks.relativeTimeThreshold = getSetRelativeTimeThreshold;\nhooks.calendarFormat        = getCalendarFormat;\nhooks.prototype             = proto;\n\nreturn hooks;\n\n})));\n\n\n\n//////////////////\n// WEBPACK FOOTER\n// ./~/moment/moment.js\n// module id = 534\n// module chunks = 0 1 2","import Select from './Select';\n\nexport default Select;\n\n\n\n// WEBPACK FOOTER //\n// ./src/ui/components/Select/index.js","import glamorous from 'glamorous';\n\nconst Select = glamorous.select({\n  // fontSize: '24px',\n  // textAlign: 'center',\n  // margin: '12px auto',\n  // display: 'block',\n  // border: '1px solid #d1d1d1',\n  backgroundColor: '#fff',\n  // padding: '12px',\n  appearance: 'none',\n\n  display: 'flex',\n  flex: '1 1 auto',\n  alignSelf: 'stretch',\n  margin: '12px auto',\n  textAlign: 'center',\n  border: '0',\n  boxShadow: '0px 2px 10px -2px rgba(0, 0, 0, 0.5)',\n  borderRadius: '4px',\n  padding: '6px 18px',\n  fontSize: '24px',\n  lineHeight: '30px',\n  backgroundImage: `\n    linear-gradient(60deg, transparent 50%, black 50%),\n    linear-gradient(120deg, black 60%, transparent 50%),\n    linear-gradient(to right, white, white)`,\n  backgroundPosition: `\n    calc(100% - 20px) calc(1em + -5px),\n    calc(100% - 15px) calc(1em + -5px),\n    100% 0`,\n  backgroundSize: `\n    5px 10px,\n    5px 10px,\n    1.5em 2.5em`,\n  backgroundRepeat: 'no-repeat',\n\n  // '::after': {\n  //   content: '\"\\\\f095\"',\n  //   fontFamily: 'FontAwesome',\n  //   left: '-5px',\n  //   position: 'absolute',\n  //   top: '0',\n  // }\n});\n\nexport default Select;\n\n\n\n// WEBPACK FOOTER //\n// ./src/ui/components/Select/Select.jsx","export default class FinancialHelpers {\n  static currencyFormatted(amount) {\n    let i = parseFloat(amount.replace ? amount.replace(',', '') : amount);\n    if (isNaN(i)) { i = 0.00; }\n    let minus = '';\n    if (i < 0) { minus = '-'; }\n    i = Math.abs(i);\n    i = parseInt((i + 0.005) * 100, 10);\n    i /= 100;\n    let s = String(i);\n    if (s.indexOf('.') < 0) { s += '.00'; }\n    if (s.indexOf('.') === (s.length - 2)) { s += '0'; }\n    s = minus + s;\n    return s;\n  }\n  static getConvertToAmount(amount) {\n    let i = parseFloat(amount.replace ? amount.replace(',', '') : amount);\n    if (isNaN(i)) { i = 0.00; }\n    i = Math.abs(i);\n    i = parseInt((i + 0.005) * 100, 10);\n    i /= 100;\n    return i;\n  }\n}\n\n\n\n// WEBPACK FOOTER //\n// ./src/utils/helpers/financial-hepers.js"],"sourceRoot":""}